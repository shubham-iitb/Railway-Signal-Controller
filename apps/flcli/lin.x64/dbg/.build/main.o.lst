   1              		.file	"main.c"
   2              		.text
   3              	.Ltext0:
   4              		.local	ptr
   5              		.comm	ptr,8,8
   6              		.local	enableBenchmarking
   7              		.comm	enableBenchmarking,1,1
   8              		.globl	delay
  10              	delay:
  11              	.LFB4:
  12              		.file 1 "main.c"
   1:main.c        **** /* 
   2:main.c        ****  * Copyright (C) 2012-2014 Chris McClelland
   3:main.c        ****  *
   4:main.c        ****  * This program is free software: you can redistribute it and/or modify
   5:main.c        ****  * it under the terms of the GNU General Public License as published by
   6:main.c        ****  * the Free Software Foundation, either version 3 of the License, or
   7:main.c        ****  * (at your option) any later version.
   8:main.c        ****  *
   9:main.c        ****  * This program is distributed in the hope that it will be useful,
  10:main.c        ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:main.c        ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:main.c        ****  * GNU General Public License for more details.
  13:main.c        ****  *  
  14:main.c        ****  * You should have received a copy of the GNU General Public License
  15:main.c        ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:main.c        ****  */
  17:main.c        **** #include <stdio.h>
  18:main.c        **** #include <time.h>
  19:main.c        **** #include <stdlib.h>
  20:main.c        **** #include <string.h>
  21:main.c        **** #include <errno.h>
  22:main.c        **** #include <stdint.h>
  23:main.c        **** #include <makestuff.h>
  24:main.c        **** #include <libfpgalink.h>
  25:main.c        **** #include <libbuffer.h>
  26:main.c        **** #include <liberror.h>
  27:main.c        **** #include <libdump.h>
  28:main.c        **** #include <argtable2.h>
  29:main.c        **** #include <readline/readline.h>
  30:main.c        **** #include <readline/history.h>
  31:main.c        **** #ifdef WIN32
  32:main.c        **** #include <Windows.h>
  33:main.c        **** #else
  34:main.c        **** #include <sys/time.h>
  35:main.c        **** #endif
  36:main.c        **** 
  37:main.c        **** bool sigIsRaised(void);
  38:main.c        **** void sigRegisterHandler(void);
  39:main.c        **** 
  40:main.c        **** static const char *ptr;
  41:main.c        **** static bool enableBenchmarking = false;
  42:main.c        **** 
  43:main.c        **** ///////////////////////////////////////////////////////////////////////////////////////////////////
  44:main.c        **** ///////////////////////////////////////////////////////////////////////////////////////////////////
  45:main.c        **** 
  46:main.c        **** void delay(unsigned int mseconds)
  47:main.c        **** {
  13              		.loc 1 47 0
  14              		.cfi_startproc
  15 0000 55       		pushq	%rbp
  16              		.cfi_def_cfa_offset 16
  17              		.cfi_offset 6, -16
  18 0001 4889E5   		movq	%rsp, %rbp
  19              		.cfi_def_cfa_register 6
  20 0004 53       		pushq	%rbx
  21 0005 4883EC28 		subq	$40, %rsp
  22              		.cfi_offset 3, -24
  23 0009 897DDC   		movl	%edi, -36(%rbp)
  48:main.c        **** 	clock_t goal = mseconds + clock();
  24              		.loc 1 48 0
  25 000c 8B5DDC   		movl	-36(%rbp), %ebx
  26 000f E8000000 		call	clock
  26      00
  27 0014 4801D8   		addq	%rbx, %rax
  28 0017 488945E8 		movq	%rax, -24(%rbp)
  49:main.c        **** 	while (goal > clock());
  29              		.loc 1 49 0
  30 001b 90       		nop
  31              	.L2:
  32              		.loc 1 49 0 is_stmt 0 discriminator 1
  33 001c E8000000 		call	clock
  33      00
  34 0021 483B45E8 		cmpq	-24(%rbp), %rax
  35 0025 7CF5     		jl	.L2
  50:main.c        **** }
  36              		.loc 1 50 0 is_stmt 1
  37 0027 90       		nop
  38 0028 4883C428 		addq	$40, %rsp
  39 002c 5B       		popq	%rbx
  40 002d 5D       		popq	%rbp
  41              		.cfi_def_cfa 7, 8
  42 002e C3       		ret
  43              		.cfi_endproc
  44              	.LFE4:
  46              		.globl	myxor
  48              	myxor:
  49              	.LFB5:
  51:main.c        **** 
  52:main.c        **** int myxor(int arr[])
  53:main.c        **** {
  50              		.loc 1 53 0
  51              		.cfi_startproc
  52 002f 55       		pushq	%rbp
  53              		.cfi_def_cfa_offset 16
  54              		.cfi_offset 6, -16
  55 0030 4889E5   		movq	%rsp, %rbp
  56              		.cfi_def_cfa_register 6
  57 0033 48897DE8 		movq	%rdi, -24(%rbp)
  54:main.c        **** 	int count = 0;
  58              		.loc 1 54 0
  59 0037 C745F800 		movl	$0, -8(%rbp)
  59      000000
  60              	.LBB2:
  55:main.c        **** 	for(int i=0; i<8; i++)
  61              		.loc 1 55 0
  62 003e C745FC00 		movl	$0, -4(%rbp)
  62      000000
  63 0045 EB23     		jmp	.L4
  64              	.L6:
  56:main.c        **** 		if(arr[i] == 1) count++;
  65              		.loc 1 56 0
  66 0047 8B45FC   		movl	-4(%rbp), %eax
  67 004a 4898     		cltq
  68 004c 488D1485 		leaq	0(,%rax,4), %rdx
  68      00000000 
  69 0054 488B45E8 		movq	-24(%rbp), %rax
  70 0058 4801D0   		addq	%rdx, %rax
  71 005b 8B00     		movl	(%rax), %eax
  72 005d 83F801   		cmpl	$1, %eax
  73 0060 7504     		jne	.L5
  74              		.loc 1 56 0 is_stmt 0 discriminator 1
  75 0062 8345F801 		addl	$1, -8(%rbp)
  76              	.L5:
  55:main.c        **** 	for(int i=0; i<8; i++)
  77              		.loc 1 55 0 is_stmt 1 discriminator 2
  78 0066 8345FC01 		addl	$1, -4(%rbp)
  79              	.L4:
  55:main.c        **** 	for(int i=0; i<8; i++)
  80              		.loc 1 55 0 is_stmt 0 discriminator 1
  81 006a 837DFC07 		cmpl	$7, -4(%rbp)
  82 006e 7ED7     		jle	.L6
  83              	.LBE2:
  57:main.c        **** 
  58:main.c        **** 	if(count%2 == 1) return 1;
  84              		.loc 1 58 0 is_stmt 1
  85 0070 8B45F8   		movl	-8(%rbp), %eax
  86 0073 99       		cltd
  87 0074 C1EA1F   		shrl	$31, %edx
  88 0077 01D0     		addl	%edx, %eax
  89 0079 83E001   		andl	$1, %eax
  90 007c 29D0     		subl	%edx, %eax
  91 007e 83F801   		cmpl	$1, %eax
  92 0081 7507     		jne	.L7
  93              		.loc 1 58 0 is_stmt 0 discriminator 1
  94 0083 B8010000 		movl	$1, %eax
  94      00
  95 0088 EB05     		jmp	.L8
  96              	.L7:
  59:main.c        **** 	else return 0;
  97              		.loc 1 59 0 is_stmt 1
  98 008a B8000000 		movl	$0, %eax
  98      00
  99              	.L8:
  60:main.c        **** }
 100              		.loc 1 60 0
 101 008f 5D       		popq	%rbp
 102              		.cfi_def_cfa 7, 8
 103 0090 C3       		ret
 104              		.cfi_endproc
 105              	.LFE5:
 107              		.globl	bitArrayToInt
 109              	bitArrayToInt:
 110              	.LFB6:
  61:main.c        **** 
  62:main.c        **** int bitArrayToInt(int arr[], int count)
  63:main.c        **** {
 111              		.loc 1 63 0
 112              		.cfi_startproc
 113 0091 55       		pushq	%rbp
 114              		.cfi_def_cfa_offset 16
 115              		.cfi_offset 6, -16
 116 0092 4889E5   		movq	%rsp, %rbp
 117              		.cfi_def_cfa_register 6
 118 0095 48897DE8 		movq	%rdi, -24(%rbp)
 119 0099 8975E4   		movl	%esi, -28(%rbp)
  64:main.c        **** 	int ret = 0;
 120              		.loc 1 64 0
 121 009c C745F400 		movl	$0, -12(%rbp)
 121      000000
 122              	.LBB3:
  65:main.c        **** 	int tmp;
  66:main.c        **** 	for (int i = 0; i < count; i++) {
 123              		.loc 1 66 0
 124 00a3 C745F800 		movl	$0, -8(%rbp)
 124      000000
 125 00aa EB35     		jmp	.L10
 126              	.L11:
  67:main.c        **** 		tmp = arr[count - i -1];
 127              		.loc 1 67 0 discriminator 3
 128 00ac 8B45E4   		movl	-28(%rbp), %eax
 129 00af 2B45F8   		subl	-8(%rbp), %eax
 130 00b2 4898     		cltq
 131 00b4 48C1E002 		salq	$2, %rax
 132 00b8 488D50FC 		leaq	-4(%rax), %rdx
 133 00bc 488B45E8 		movq	-24(%rbp), %rax
 134 00c0 4801D0   		addq	%rdx, %rax
 135 00c3 8B00     		movl	(%rax), %eax
 136 00c5 8945FC   		movl	%eax, -4(%rbp)
  68:main.c        **** 		ret |= tmp << (count - i - 1);
 137              		.loc 1 68 0 discriminator 3
 138 00c8 8B45E4   		movl	-28(%rbp), %eax
 139 00cb 2B45F8   		subl	-8(%rbp), %eax
 140 00ce 83E801   		subl	$1, %eax
 141 00d1 8B55FC   		movl	-4(%rbp), %edx
 142 00d4 89C1     		movl	%eax, %ecx
 143 00d6 D3E2     		sall	%cl, %edx
 144 00d8 89D0     		movl	%edx, %eax
 145 00da 0945F4   		orl	%eax, -12(%rbp)
  66:main.c        **** 		tmp = arr[count - i -1];
 146              		.loc 1 66 0 discriminator 3
 147 00dd 8345F801 		addl	$1, -8(%rbp)
 148              	.L10:
  66:main.c        **** 		tmp = arr[count - i -1];
 149              		.loc 1 66 0 is_stmt 0 discriminator 1
 150 00e1 8B45F8   		movl	-8(%rbp), %eax
 151 00e4 3B45E4   		cmpl	-28(%rbp), %eax
 152 00e7 7CC3     		jl	.L11
 153              	.LBE3:
  69:main.c        **** 	}
  70:main.c        **** 	return ret;
 154              		.loc 1 70 0 is_stmt 1
 155 00e9 8B45F4   		movl	-12(%rbp), %eax
  71:main.c        **** }
 156              		.loc 1 71 0
 157 00ec 5D       		popq	%rbp
 158              		.cfi_def_cfa 7, 8
 159 00ed C3       		ret
 160              		.cfi_endproc
 161              	.LFE6:
 163              		.globl	BinTouint8
 165              	BinTouint8:
 166              	.LFB7:
  72:main.c        **** 
  73:main.c        **** void BinTouint8(uint8 bin[], int arr[])
  74:main.c        **** {
 167              		.loc 1 74 0
 168              		.cfi_startproc
 169 00ee 55       		pushq	%rbp
 170              		.cfi_def_cfa_offset 16
 171              		.cfi_offset 6, -16
 172 00ef 4889E5   		movq	%rsp, %rbp
 173              		.cfi_def_cfa_register 6
 174 00f2 53       		pushq	%rbx
 175 00f3 4881ECB8 		subq	$184, %rsp
 175      000000
 176              		.cfi_offset 3, -24
 177 00fa 4889BD48 		movq	%rdi, -184(%rbp)
 177      FFFFFF
 178 0101 4889B540 		movq	%rsi, -192(%rbp)
 178      FFFFFF
 179              		.loc 1 74 0
 180 0108 64488B04 		movq	%fs:40, %rax
 180      25280000 
 180      00
 181 0111 488945E8 		movq	%rax, -24(%rbp)
 182 0115 31C0     		xorl	%eax, %eax
 183              	.LBB4:
  75:main.c        **** 	int arr0[8], arr1[8], arr2[8], arr3[8];
  76:main.c        **** 	for (int i = 0; i < 8; ++i)
 184              		.loc 1 76 0
 185 0117 C7855CFF 		movl	$0, -164(%rbp)
 185      FFFF0000 
 185      0000
 186 0121 E9B60000 		jmp	.L14
 186      00
 187              	.L15:
  77:main.c        **** 	{
  78:main.c        **** 		arr0[i] = arr[i];
 188              		.loc 1 78 0 discriminator 3
 189 0126 8B855CFF 		movl	-164(%rbp), %eax
 189      FFFF
 190 012c 4898     		cltq
 191 012e 488D1485 		leaq	0(,%rax,4), %rdx
 191      00000000 
 192 0136 488B8540 		movq	-192(%rbp), %rax
 192      FFFFFF
 193 013d 4801D0   		addq	%rdx, %rax
 194 0140 8B10     		movl	(%rax), %edx
 195 0142 8B855CFF 		movl	-164(%rbp), %eax
 195      FFFF
 196 0148 4898     		cltq
 197 014a 89948560 		movl	%edx, -160(%rbp,%rax,4)
 197      FFFFFF
  79:main.c        **** 		arr1[i] = arr[i+8];
 198              		.loc 1 79 0 discriminator 3
 199 0151 8B855CFF 		movl	-164(%rbp), %eax
 199      FFFF
 200 0157 4898     		cltq
 201 0159 4883C008 		addq	$8, %rax
 202 015d 488D1485 		leaq	0(,%rax,4), %rdx
 202      00000000 
 203 0165 488B8540 		movq	-192(%rbp), %rax
 203      FFFFFF
 204 016c 4801D0   		addq	%rdx, %rax
 205 016f 8B10     		movl	(%rax), %edx
 206 0171 8B855CFF 		movl	-164(%rbp), %eax
 206      FFFF
 207 0177 4898     		cltq
 208 0179 89548580 		movl	%edx, -128(%rbp,%rax,4)
  80:main.c        **** 		arr2[i] = arr[i+16];
 209              		.loc 1 80 0 discriminator 3
 210 017d 8B855CFF 		movl	-164(%rbp), %eax
 210      FFFF
 211 0183 4898     		cltq
 212 0185 4883C010 		addq	$16, %rax
 213 0189 488D1485 		leaq	0(,%rax,4), %rdx
 213      00000000 
 214 0191 488B8540 		movq	-192(%rbp), %rax
 214      FFFFFF
 215 0198 4801D0   		addq	%rdx, %rax
 216 019b 8B10     		movl	(%rax), %edx
 217 019d 8B855CFF 		movl	-164(%rbp), %eax
 217      FFFF
 218 01a3 4898     		cltq
 219 01a5 895485A0 		movl	%edx, -96(%rbp,%rax,4)
  81:main.c        **** 		arr3[i] = arr[i+24];
 220              		.loc 1 81 0 discriminator 3
 221 01a9 8B855CFF 		movl	-164(%rbp), %eax
 221      FFFF
 222 01af 4898     		cltq
 223 01b1 4883C018 		addq	$24, %rax
 224 01b5 488D1485 		leaq	0(,%rax,4), %rdx
 224      00000000 
 225 01bd 488B8540 		movq	-192(%rbp), %rax
 225      FFFFFF
 226 01c4 4801D0   		addq	%rdx, %rax
 227 01c7 8B10     		movl	(%rax), %edx
 228 01c9 8B855CFF 		movl	-164(%rbp), %eax
 228      FFFF
 229 01cf 4898     		cltq
 230 01d1 895485C0 		movl	%edx, -64(%rbp,%rax,4)
  76:main.c        **** 	{
 231              		.loc 1 76 0 discriminator 3
 232 01d5 83855CFF 		addl	$1, -164(%rbp)
 232      FFFF01
 233              	.L14:
  76:main.c        **** 	{
 234              		.loc 1 76 0 is_stmt 0 discriminator 1
 235 01dc 83BD5CFF 		cmpl	$7, -164(%rbp)
 235      FFFF07
 236 01e3 0F8E3DFF 		jle	.L15
 236      FFFF
 237              	.LBE4:
  82:main.c        **** 	}
  83:main.c        **** 	
  84:main.c        **** 	bin[0] = bitArrayToInt(arr0, 8);
 238              		.loc 1 84 0 is_stmt 1
 239 01e9 488D8560 		leaq	-160(%rbp), %rax
 239      FFFFFF
 240 01f0 BE080000 		movl	$8, %esi
 240      00
 241 01f5 4889C7   		movq	%rax, %rdi
 242 01f8 E8000000 		call	bitArrayToInt
 242      00
 243 01fd 89C2     		movl	%eax, %edx
 244 01ff 488B8548 		movq	-184(%rbp), %rax
 244      FFFFFF
 245 0206 8810     		movb	%dl, (%rax)
  85:main.c        **** 	bin[1] = bitArrayToInt(arr1, 8);
 246              		.loc 1 85 0
 247 0208 488B8548 		movq	-184(%rbp), %rax
 247      FFFFFF
 248 020f 488D5801 		leaq	1(%rax), %rbx
 249 0213 488D4580 		leaq	-128(%rbp), %rax
 250 0217 BE080000 		movl	$8, %esi
 250      00
 251 021c 4889C7   		movq	%rax, %rdi
 252 021f E8000000 		call	bitArrayToInt
 252      00
 253 0224 8803     		movb	%al, (%rbx)
  86:main.c        **** 	bin[2] = bitArrayToInt(arr2, 8);
 254              		.loc 1 86 0
 255 0226 488B8548 		movq	-184(%rbp), %rax
 255      FFFFFF
 256 022d 488D5802 		leaq	2(%rax), %rbx
 257 0231 488D45A0 		leaq	-96(%rbp), %rax
 258 0235 BE080000 		movl	$8, %esi
 258      00
 259 023a 4889C7   		movq	%rax, %rdi
 260 023d E8000000 		call	bitArrayToInt
 260      00
 261 0242 8803     		movb	%al, (%rbx)
  87:main.c        **** 	bin[3] = bitArrayToInt(arr3, 8);
 262              		.loc 1 87 0
 263 0244 488B8548 		movq	-184(%rbp), %rax
 263      FFFFFF
 264 024b 488D5803 		leaq	3(%rax), %rbx
 265 024f 488D45C0 		leaq	-64(%rbp), %rax
 266 0253 BE080000 		movl	$8, %esi
 266      00
 267 0258 4889C7   		movq	%rax, %rdi
 268 025b E8000000 		call	bitArrayToInt
 268      00
 269 0260 8803     		movb	%al, (%rbx)
  88:main.c        **** }
 270              		.loc 1 88 0
 271 0262 90       		nop
 272 0263 488B45E8 		movq	-24(%rbp), %rax
 273 0267 64483304 		xorq	%fs:40, %rax
 273      25280000 
 273      00
 274 0270 7405     		je	.L16
 275 0272 E8000000 		call	__stack_chk_fail
 275      00
 276              	.L16:
 277 0277 4881C4B8 		addq	$184, %rsp
 277      000000
 278 027e 5B       		popq	%rbx
 279 027f 5D       		popq	%rbp
 280              		.cfi_def_cfa 7, 8
 281 0280 C3       		ret
 282              		.cfi_endproc
 283              	.LFE7:
 285              		.globl	decToBinary
 287              	decToBinary:
 288              	.LFB8:
  89:main.c        **** 
  90:main.c        **** void decToBinary(int n, int arr[], int count)
  91:main.c        **** {
 289              		.loc 1 91 0
 290              		.cfi_startproc
 291 0281 55       		pushq	%rbp
 292              		.cfi_def_cfa_offset 16
 293              		.cfi_offset 6, -16
 294 0282 4889E5   		movq	%rsp, %rbp
 295              		.cfi_def_cfa_register 6
 296 0285 53       		pushq	%rbx
 297 0286 4883EC48 		subq	$72, %rsp
 298              		.cfi_offset 3, -24
 299 028a 897DBC   		movl	%edi, -68(%rbp)
 300 028d 488975B0 		movq	%rsi, -80(%rbp)
 301 0291 8955B8   		movl	%edx, -72(%rbp)
 302              		.loc 1 91 0
 303 0294 64488B04 		movq	%fs:40, %rax
 303      25280000 
 303      00
 304 029d 488945E8 		movq	%rax, -24(%rbp)
 305 02a1 31C0     		xorl	%eax, %eax
 306 02a3 4889E0   		movq	%rsp, %rax
 307 02a6 4889C6   		movq	%rax, %rsi
  92:main.c        **** 	int binaryNum[count];
 308              		.loc 1 92 0
 309 02a9 8B45B8   		movl	-72(%rbp), %eax
 310 02ac 4863D0   		movslq	%eax, %rdx
 311 02af 4883EA01 		subq	$1, %rdx
 312 02b3 488955D8 		movq	%rdx, -40(%rbp)
 313 02b7 4863D0   		movslq	%eax, %rdx
 314 02ba 4989D0   		movq	%rdx, %r8
 315 02bd 41B90000 		movl	$0, %r9d
 315      0000
 316 02c3 4863D0   		movslq	%eax, %rdx
 317 02c6 4889D1   		movq	%rdx, %rcx
 318 02c9 BB000000 		movl	$0, %ebx
 318      00
 319 02ce 4898     		cltq
 320 02d0 48C1E002 		salq	$2, %rax
 321 02d4 488D5003 		leaq	3(%rax), %rdx
 322 02d8 B8100000 		movl	$16, %eax
 322      00
 323 02dd 4883E801 		subq	$1, %rax
 324 02e1 4801D0   		addq	%rdx, %rax
 325 02e4 BB100000 		movl	$16, %ebx
 325      00
 326 02e9 BA000000 		movl	$0, %edx
 326      00
 327 02ee 48F7F3   		divq	%rbx
 328 02f1 486BC010 		imulq	$16, %rax, %rax
 329 02f5 4829C4   		subq	%rax, %rsp
 330 02f8 4889E0   		movq	%rsp, %rax
 331 02fb 4883C003 		addq	$3, %rax
 332 02ff 48C1E802 		shrq	$2, %rax
 333 0303 48C1E002 		salq	$2, %rax
 334 0307 488945E0 		movq	%rax, -32(%rbp)
 335              	.LBB5:
  93:main.c        **** 	for (int i = 0; i < count; ++i)
 336              		.loc 1 93 0
 337 030b C745CC00 		movl	$0, -52(%rbp)
 337      000000
 338 0312 EB15     		jmp	.L18
 339              	.L19:
  94:main.c        **** 		binaryNum[i] = 0;
 340              		.loc 1 94 0 discriminator 3
 341 0314 488B45E0 		movq	-32(%rbp), %rax
 342 0318 8B55CC   		movl	-52(%rbp), %edx
 343 031b 4863D2   		movslq	%edx, %rdx
 344 031e C7049000 		movl	$0, (%rax,%rdx,4)
 344      000000
  93:main.c        **** 	for (int i = 0; i < count; ++i)
 345              		.loc 1 93 0 discriminator 3
 346 0325 8345CC01 		addl	$1, -52(%rbp)
 347              	.L18:
  93:main.c        **** 	for (int i = 0; i < count; ++i)
 348              		.loc 1 93 0 is_stmt 0 discriminator 1
 349 0329 8B45CC   		movl	-52(%rbp), %eax
 350 032c 3B45B8   		cmpl	-72(%rbp), %eax
 351 032f 7CE3     		jl	.L19
 352              	.LBE5:
  95:main.c        **** 
  96:main.c        **** 	int i = 0;
 353              		.loc 1 96 0 is_stmt 1
 354 0331 C745D000 		movl	$0, -48(%rbp)
 354      000000
  97:main.c        **** 	while (n > 0) {
 355              		.loc 1 97 0
 356 0338 EB30     		jmp	.L20
 357              	.L21:
  98:main.c        **** 		binaryNum[i] = n % 2;
 358              		.loc 1 98 0
 359 033a 8B45BC   		movl	-68(%rbp), %eax
 360 033d 99       		cltd
 361 033e C1EA1F   		shrl	$31, %edx
 362 0341 01D0     		addl	%edx, %eax
 363 0343 83E001   		andl	$1, %eax
 364 0346 29D0     		subl	%edx, %eax
 365 0348 89C1     		movl	%eax, %ecx
 366 034a 488B45E0 		movq	-32(%rbp), %rax
 367 034e 8B55D0   		movl	-48(%rbp), %edx
 368 0351 4863D2   		movslq	%edx, %rdx
 369 0354 890C90   		movl	%ecx, (%rax,%rdx,4)
  99:main.c        **** 		n = n / 2;
 370              		.loc 1 99 0
 371 0357 8B45BC   		movl	-68(%rbp), %eax
 372 035a 89C2     		movl	%eax, %edx
 373 035c C1EA1F   		shrl	$31, %edx
 374 035f 01D0     		addl	%edx, %eax
 375 0361 D1F8     		sarl	%eax
 376 0363 8945BC   		movl	%eax, -68(%rbp)
 100:main.c        **** 		i++;
 377              		.loc 1 100 0
 378 0366 8345D001 		addl	$1, -48(%rbp)
 379              	.L20:
  97:main.c        **** 		binaryNum[i] = n % 2;
 380              		.loc 1 97 0
 381 036a 837DBC00 		cmpl	$0, -68(%rbp)
 382 036e 7FCA     		jg	.L21
 383              	.LBB6:
 101:main.c        **** 	}
 102:main.c        **** 
 103:main.c        ****     // printing binary array in reverse order
 104:main.c        **** 	for (int i=0; i<count; i++)
 384              		.loc 1 104 0
 385 0370 C745D400 		movl	$0, -44(%rbp)
 385      000000
 386 0377 EB28     		jmp	.L22
 387              	.L23:
 105:main.c        **** 		arr[i] = binaryNum[i];
 388              		.loc 1 105 0 discriminator 3
 389 0379 8B45D4   		movl	-44(%rbp), %eax
 390 037c 4898     		cltq
 391 037e 488D1485 		leaq	0(,%rax,4), %rdx
 391      00000000 
 392 0386 488B45B0 		movq	-80(%rbp), %rax
 393 038a 488D0C02 		leaq	(%rdx,%rax), %rcx
 394 038e 488B45E0 		movq	-32(%rbp), %rax
 395 0392 8B55D4   		movl	-44(%rbp), %edx
 396 0395 4863D2   		movslq	%edx, %rdx
 397 0398 8B0490   		movl	(%rax,%rdx,4), %eax
 398 039b 8901     		movl	%eax, (%rcx)
 104:main.c        **** 		arr[i] = binaryNum[i];
 399              		.loc 1 104 0 discriminator 3
 400 039d 8345D401 		addl	$1, -44(%rbp)
 401              	.L22:
 104:main.c        **** 		arr[i] = binaryNum[i];
 402              		.loc 1 104 0 is_stmt 0 discriminator 1
 403 03a1 8B45D4   		movl	-44(%rbp), %eax
 404 03a4 3B45B8   		cmpl	-72(%rbp), %eax
 405 03a7 7CD0     		jl	.L23
 406              	.LBE6:
 407 03a9 4889F4   		movq	%rsi, %rsp
 106:main.c        **** }
 408              		.loc 1 106 0 is_stmt 1
 409 03ac 90       		nop
 410 03ad 488B45E8 		movq	-24(%rbp), %rax
 411 03b1 64483304 		xorq	%fs:40, %rax
 411      25280000 
 411      00
 412 03ba 7405     		je	.L24
 413 03bc E8000000 		call	__stack_chk_fail
 413      00
 414              	.L24:
 415 03c1 488B5DF8 		movq	-8(%rbp), %rbx
 416 03c5 C9       		leave
 417              		.cfi_def_cfa 7, 8
 418 03c6 C3       		ret
 419              		.cfi_endproc
 420              	.LFE8:
 422              		.globl	encrypter
 424              	encrypter:
 425              	.LFB9:
 107:main.c        **** 
 108:main.c        **** void encrypter(int P[], int K[], int bin[])
 109:main.c        **** {
 426              		.loc 1 109 0
 427              		.cfi_startproc
 428 03c7 55       		pushq	%rbp
 429              		.cfi_def_cfa_offset 16
 430              		.cfi_offset 6, -16
 431 03c8 4889E5   		movq	%rsp, %rbp
 432              		.cfi_def_cfa_register 6
 433 03cb 4881EC60 		subq	$608, %rsp
 433      020000
 434 03d2 4889BDB8 		movq	%rdi, -584(%rbp)
 434      FDFFFF
 435 03d9 4889B5B0 		movq	%rsi, -592(%rbp)
 435      FDFFFF
 436 03e0 488995A8 		movq	%rdx, -600(%rbp)
 436      FDFFFF
 437              		.loc 1 109 0
 438 03e7 64488B04 		movq	%fs:40, %rax
 438      25280000 
 438      00
 439 03f0 488945F8 		movq	%rax, -8(%rbp)
 440 03f4 31C0     		xorl	%eax, %eax
 110:main.c        ****   //int plain_text[32];
 111:main.c        **** 	int key[32];
 112:main.c        **** 	int cipher_text[32];
 113:main.c        **** 	int T[4];
 114:main.c        **** 	int count1=0;
 441              		.loc 1 114 0
 442 03f6 C785C0FD 		movl	$0, -576(%rbp)
 442      FFFF0000 
 442      0000
 443              	.LBB7:
 115:main.c        **** 
 116:main.c        **** 	for (int i = 0; i < 32; ++i)
 444              		.loc 1 116 0
 445 0400 C785C4FD 		movl	$0, -572(%rbp)
 445      FFFF0000 
 445      0000
 446 040a E9850000 		jmp	.L26
 446      00
 447              	.L28:
 117:main.c        **** 	{
 118:main.c        **** 		cipher_text[i] = P[i];
 448              		.loc 1 118 0
 449 040f 8B85C4FD 		movl	-572(%rbp), %eax
 449      FFFF
 450 0415 4898     		cltq
 451 0417 488D1485 		leaq	0(,%rax,4), %rdx
 451      00000000 
 452 041f 488B85B8 		movq	-584(%rbp), %rax
 452      FDFFFF
 453 0426 4801D0   		addq	%rdx, %rax
 454 0429 8B10     		movl	(%rax), %edx
 455 042b 8B85C4FD 		movl	-572(%rbp), %eax
 455      FFFF
 456 0431 4898     		cltq
 457 0433 899485F0 		movl	%edx, -272(%rbp,%rax,4)
 457      FEFFFF
 119:main.c        **** 		key[i] = K[i];
 458              		.loc 1 119 0
 459 043a 8B85C4FD 		movl	-572(%rbp), %eax
 459      FFFF
 460 0440 4898     		cltq
 461 0442 488D1485 		leaq	0(,%rax,4), %rdx
 461      00000000 
 462 044a 488B85B0 		movq	-592(%rbp), %rax
 462      FDFFFF
 463 0451 4801D0   		addq	%rdx, %rax
 464 0454 8B10     		movl	(%rax), %edx
 465 0456 8B85C4FD 		movl	-572(%rbp), %eax
 465      FFFF
 466 045c 4898     		cltq
 467 045e 89948570 		movl	%edx, -400(%rbp,%rax,4)
 467      FEFFFF
 120:main.c        **** 		if(K[i] == 1) 
 468              		.loc 1 120 0
 469 0465 8B85C4FD 		movl	-572(%rbp), %eax
 469      FFFF
 470 046b 4898     		cltq
 471 046d 488D1485 		leaq	0(,%rax,4), %rdx
 471      00000000 
 472 0475 488B85B0 		movq	-592(%rbp), %rax
 472      FDFFFF
 473 047c 4801D0   		addq	%rdx, %rax
 474 047f 8B00     		movl	(%rax), %eax
 475 0481 83F801   		cmpl	$1, %eax
 476 0484 7507     		jne	.L27
 121:main.c        **** 			count1++;
 477              		.loc 1 121 0
 478 0486 8385C0FD 		addl	$1, -576(%rbp)
 478      FFFF01
 479              	.L27:
 116:main.c        **** 	{
 480              		.loc 1 116 0 discriminator 2
 481 048d 8385C4FD 		addl	$1, -572(%rbp)
 481      FFFF01
 482              	.L26:
 116:main.c        **** 	{
 483              		.loc 1 116 0 is_stmt 0 discriminator 1
 484 0494 83BDC4FD 		cmpl	$31, -572(%rbp)
 484      FFFF1F
 485 049b 0F8E6EFF 		jle	.L28
 485      FFFF
 486              	.LBE7:
 487              	.LBB8:
 122:main.c        **** 	}
 123:main.c        **** 
 124:main.c        **** 	int arr0[8];
 125:main.c        **** 	int arr1[8];
 126:main.c        **** 	int arr2[8];
 127:main.c        **** 	int arr3[8];
 128:main.c        **** 
 129:main.c        **** 	for(int i=0; i<8; i++)
 488              		.loc 1 129 0 is_stmt 1
 489 04a1 C785C8FD 		movl	$0, -568(%rbp)
 489      FFFF0000 
 489      0000
 490 04ab E9940000 		jmp	.L29
 490      00
 491              	.L30:
 130:main.c        **** 	{
 131:main.c        **** 		arr0[i] = key[4*i];
 492              		.loc 1 131 0 discriminator 3
 493 04b0 8B85C8FD 		movl	-568(%rbp), %eax
 493      FFFF
 494 04b6 C1E002   		sall	$2, %eax
 495 04b9 4898     		cltq
 496 04bb 8B948570 		movl	-400(%rbp,%rax,4), %edx
 496      FEFFFF
 497 04c2 8B85C8FD 		movl	-568(%rbp), %eax
 497      FFFF
 498 04c8 4898     		cltq
 499 04ca 899485F0 		movl	%edx, -528(%rbp,%rax,4)
 499      FDFFFF
 132:main.c        **** 		arr1[i] = key[4*i+1];
 500              		.loc 1 132 0 discriminator 3
 501 04d1 8B85C8FD 		movl	-568(%rbp), %eax
 501      FFFF
 502 04d7 C1E002   		sall	$2, %eax
 503 04da 83C001   		addl	$1, %eax
 504 04dd 4898     		cltq
 505 04df 8B948570 		movl	-400(%rbp,%rax,4), %edx
 505      FEFFFF
 506 04e6 8B85C8FD 		movl	-568(%rbp), %eax
 506      FFFF
 507 04ec 4898     		cltq
 508 04ee 89948510 		movl	%edx, -496(%rbp,%rax,4)
 508      FEFFFF
 133:main.c        **** 		arr2[i] = key[4*i+2];
 509              		.loc 1 133 0 discriminator 3
 510 04f5 8B85C8FD 		movl	-568(%rbp), %eax
 510      FFFF
 511 04fb C1E002   		sall	$2, %eax
 512 04fe 83C002   		addl	$2, %eax
 513 0501 4898     		cltq
 514 0503 8B948570 		movl	-400(%rbp,%rax,4), %edx
 514      FEFFFF
 515 050a 8B85C8FD 		movl	-568(%rbp), %eax
 515      FFFF
 516 0510 4898     		cltq
 517 0512 89948530 		movl	%edx, -464(%rbp,%rax,4)
 517      FEFFFF
 134:main.c        **** 		arr3[i] = key[4*i+3];
 518              		.loc 1 134 0 discriminator 3
 519 0519 8B85C8FD 		movl	-568(%rbp), %eax
 519      FFFF
 520 051f C1E002   		sall	$2, %eax
 521 0522 83C003   		addl	$3, %eax
 522 0525 4898     		cltq
 523 0527 8B948570 		movl	-400(%rbp,%rax,4), %edx
 523      FEFFFF
 524 052e 8B85C8FD 		movl	-568(%rbp), %eax
 524      FFFF
 525 0534 4898     		cltq
 526 0536 89948550 		movl	%edx, -432(%rbp,%rax,4)
 526      FEFFFF
 129:main.c        **** 	{
 527              		.loc 1 129 0 discriminator 3
 528 053d 8385C8FD 		addl	$1, -568(%rbp)
 528      FFFF01
 529              	.L29:
 129:main.c        **** 	{
 530              		.loc 1 129 0 is_stmt 0 discriminator 1
 531 0544 83BDC8FD 		cmpl	$7, -568(%rbp)
 531      FFFF07
 532 054b 0F8E5FFF 		jle	.L30
 532      FFFF
 533              	.LBE8:
 135:main.c        **** 	}
 136:main.c        **** 
 137:main.c        **** 	T[0] = myxor(arr0);
 534              		.loc 1 137 0 is_stmt 1
 535 0551 488D85F0 		leaq	-528(%rbp), %rax
 535      FDFFFF
 536 0558 4889C7   		movq	%rax, %rdi
 537 055b E8000000 		call	myxor
 537      00
 538 0560 8985E0FD 		movl	%eax, -544(%rbp)
 538      FFFF
 138:main.c        **** 	T[1] = myxor(arr1);
 539              		.loc 1 138 0
 540 0566 488D8510 		leaq	-496(%rbp), %rax
 540      FEFFFF
 541 056d 4889C7   		movq	%rax, %rdi
 542 0570 E8000000 		call	myxor
 542      00
 543 0575 8985E4FD 		movl	%eax, -540(%rbp)
 543      FFFF
 139:main.c        **** 	T[2] = myxor(arr2);
 544              		.loc 1 139 0
 545 057b 488D8530 		leaq	-464(%rbp), %rax
 545      FEFFFF
 546 0582 4889C7   		movq	%rax, %rdi
 547 0585 E8000000 		call	myxor
 547      00
 548 058a 8985E8FD 		movl	%eax, -536(%rbp)
 548      FFFF
 140:main.c        **** 	T[3] = myxor(arr3);
 549              		.loc 1 140 0
 550 0590 488D8550 		leaq	-432(%rbp), %rax
 550      FEFFFF
 551 0597 4889C7   		movq	%rax, %rdi
 552 059a E8000000 		call	myxor
 552      00
 553 059f 8985ECFD 		movl	%eax, -532(%rbp)
 553      FFFF
 141:main.c        **** 
 142:main.c        **** 	int T32[32];
 143:main.c        **** 	int dec = bitArrayToInt(T, 4);
 554              		.loc 1 143 0
 555 05a5 488D85E0 		leaq	-544(%rbp), %rax
 555      FDFFFF
 556 05ac BE040000 		movl	$4, %esi
 556      00
 557 05b1 4889C7   		movq	%rax, %rdi
 558 05b4 E8000000 		call	bitArrayToInt
 558      00
 559 05b9 8985CCFD 		movl	%eax, -564(%rbp)
 559      FFFF
 560              	.LBB9:
 144:main.c        **** 
 145:main.c        **** 	for (int i = 0; i < count1; ++i)
 561              		.loc 1 145 0
 562 05bf C785D0FD 		movl	$0, -560(%rbp)
 562      FFFF0000 
 562      0000
 563 05c9 E90D0100 		jmp	.L31
 563      00
 564              	.L37:
 565              	.LBB10:
 146:main.c        **** 	{ 
 147:main.c        **** 		for (int j = 0; j < 8; j++)
 566              		.loc 1 147 0
 567 05ce C785D4FD 		movl	$0, -556(%rbp)
 567      FFFF0000 
 567      0000
 568 05d8 EB70     		jmp	.L32
 569              	.L33:
 148:main.c        **** 		{
 149:main.c        **** 			T32[4*j] = T[0];
 570              		.loc 1 149 0 discriminator 3
 571 05da 8B85D4FD 		movl	-556(%rbp), %eax
 571      FFFF
 572 05e0 C1E002   		sall	$2, %eax
 573 05e3 8B95E0FD 		movl	-544(%rbp), %edx
 573      FFFF
 574 05e9 4898     		cltq
 575 05eb 89948570 		movl	%edx, -144(%rbp,%rax,4)
 575      FFFFFF
 150:main.c        **** 			T32[4*j+1] = T[1];
 576              		.loc 1 150 0 discriminator 3
 577 05f2 8B85D4FD 		movl	-556(%rbp), %eax
 577      FFFF
 578 05f8 C1E002   		sall	$2, %eax
 579 05fb 83C001   		addl	$1, %eax
 580 05fe 8B95E4FD 		movl	-540(%rbp), %edx
 580      FFFF
 581 0604 4898     		cltq
 582 0606 89948570 		movl	%edx, -144(%rbp,%rax,4)
 582      FFFFFF
 151:main.c        **** 			T32[4*j+2] = T[2];
 583              		.loc 1 151 0 discriminator 3
 584 060d 8B85D4FD 		movl	-556(%rbp), %eax
 584      FFFF
 585 0613 C1E002   		sall	$2, %eax
 586 0616 83C002   		addl	$2, %eax
 587 0619 8B95E8FD 		movl	-536(%rbp), %edx
 587      FFFF
 588 061f 4898     		cltq
 589 0621 89948570 		movl	%edx, -144(%rbp,%rax,4)
 589      FFFFFF
 152:main.c        **** 			T32[4*j+3] = T[3];
 590              		.loc 1 152 0 discriminator 3
 591 0628 8B85D4FD 		movl	-556(%rbp), %eax
 591      FFFF
 592 062e C1E002   		sall	$2, %eax
 593 0631 83C003   		addl	$3, %eax
 594 0634 8B95ECFD 		movl	-532(%rbp), %edx
 594      FFFF
 595 063a 4898     		cltq
 596 063c 89948570 		movl	%edx, -144(%rbp,%rax,4)
 596      FFFFFF
 147:main.c        **** 		{
 597              		.loc 1 147 0 discriminator 3
 598 0643 8385D4FD 		addl	$1, -556(%rbp)
 598      FFFF01
 599              	.L32:
 147:main.c        **** 		{
 600              		.loc 1 147 0 is_stmt 0 discriminator 1
 601 064a 83BDD4FD 		cmpl	$7, -556(%rbp)
 601      FFFF07
 602 0651 7E87     		jle	.L33
 603              	.LBE10:
 604              	.LBB11:
 153:main.c        **** 		}
 154:main.c        **** 
 155:main.c        **** 		for (int j = 0; j < 32; ++j)
 605              		.loc 1 155 0 is_stmt 1
 606 0653 C785D8FD 		movl	$0, -552(%rbp)
 606      FFFF0000 
 606      0000
 607 065d EB36     		jmp	.L34
 608              	.L35:
 156:main.c        **** 			cipher_text[j] = cipher_text[j] ^ T32[j];
 609              		.loc 1 156 0 discriminator 3
 610 065f 8B85D8FD 		movl	-552(%rbp), %eax
 610      FFFF
 611 0665 4898     		cltq
 612 0667 8B9485F0 		movl	-272(%rbp,%rax,4), %edx
 612      FEFFFF
 613 066e 8B85D8FD 		movl	-552(%rbp), %eax
 613      FFFF
 614 0674 4898     		cltq
 615 0676 8B848570 		movl	-144(%rbp,%rax,4), %eax
 615      FFFFFF
 616 067d 31C2     		xorl	%eax, %edx
 617 067f 8B85D8FD 		movl	-552(%rbp), %eax
 617      FFFF
 618 0685 4898     		cltq
 619 0687 899485F0 		movl	%edx, -272(%rbp,%rax,4)
 619      FEFFFF
 155:main.c        **** 			cipher_text[j] = cipher_text[j] ^ T32[j];
 620              		.loc 1 155 0 discriminator 3
 621 068e 8385D8FD 		addl	$1, -552(%rbp)
 621      FFFF01
 622              	.L34:
 155:main.c        **** 			cipher_text[j] = cipher_text[j] ^ T32[j];
 623              		.loc 1 155 0 is_stmt 0 discriminator 1
 624 0695 83BDD8FD 		cmpl	$31, -552(%rbp)
 624      FFFF1F
 625 069c 7EC1     		jle	.L35
 626              	.LBE11:
 157:main.c        **** 
 158:main.c        ****     // for (int j = 0; j < 32; ++j)
 159:main.c        ****     //  printf("%d", cipher_text[j]);
 160:main.c        ****     // printf("\n");
 161:main.c        **** 
 162:main.c        **** 		dec++;
 627              		.loc 1 162 0 is_stmt 1
 628 069e 8385CCFD 		addl	$1, -564(%rbp)
 628      FFFF01
 163:main.c        **** 		if(dec==16) dec = 0;
 629              		.loc 1 163 0
 630 06a5 83BDCCFD 		cmpl	$16, -564(%rbp)
 630      FFFF10
 631 06ac 750A     		jne	.L36
 632              		.loc 1 163 0 is_stmt 0 discriminator 1
 633 06ae C785CCFD 		movl	$0, -564(%rbp)
 633      FFFF0000 
 633      0000
 634              	.L36:
 164:main.c        **** 		decToBinary(dec, T, 4);
 635              		.loc 1 164 0 is_stmt 1 discriminator 2
 636 06b8 488D8DE0 		leaq	-544(%rbp), %rcx
 636      FDFFFF
 637 06bf 8B85CCFD 		movl	-564(%rbp), %eax
 637      FFFF
 638 06c5 BA040000 		movl	$4, %edx
 638      00
 639 06ca 4889CE   		movq	%rcx, %rsi
 640 06cd 89C7     		movl	%eax, %edi
 641 06cf E8000000 		call	decToBinary
 641      00
 145:main.c        **** 	{ 
 642              		.loc 1 145 0 discriminator 2
 643 06d4 8385D0FD 		addl	$1, -560(%rbp)
 643      FFFF01
 644              	.L31:
 145:main.c        **** 	{ 
 645              		.loc 1 145 0 is_stmt 0 discriminator 1
 646 06db 8B85D0FD 		movl	-560(%rbp), %eax
 646      FFFF
 647 06e1 3B85C0FD 		cmpl	-576(%rbp), %eax
 647      FFFF
 648 06e7 0F8CE1FE 		jl	.L37
 648      FFFF
 649              	.LBE9:
 650              	.LBB12:
 165:main.c        **** 	}
 166:main.c        **** 
 167:main.c        **** 	for (int i = 0; i < 32; ++i)
 651              		.loc 1 167 0 is_stmt 1
 652 06ed C785DCFD 		movl	$0, -548(%rbp)
 652      FFFF0000 
 652      0000
 653 06f7 EB32     		jmp	.L38
 654              	.L39:
 168:main.c        **** 		bin[i] = cipher_text[i];
 655              		.loc 1 168 0 discriminator 3
 656 06f9 8B85DCFD 		movl	-548(%rbp), %eax
 656      FFFF
 657 06ff 4898     		cltq
 658 0701 488D1485 		leaq	0(,%rax,4), %rdx
 658      00000000 
 659 0709 488B85A8 		movq	-600(%rbp), %rax
 659      FDFFFF
 660 0710 4801C2   		addq	%rax, %rdx
 661 0713 8B85DCFD 		movl	-548(%rbp), %eax
 661      FFFF
 662 0719 4898     		cltq
 663 071b 8B8485F0 		movl	-272(%rbp,%rax,4), %eax
 663      FEFFFF
 664 0722 8902     		movl	%eax, (%rdx)
 167:main.c        **** 		bin[i] = cipher_text[i];
 665              		.loc 1 167 0 discriminator 3
 666 0724 8385DCFD 		addl	$1, -548(%rbp)
 666      FFFF01
 667              	.L38:
 167:main.c        **** 		bin[i] = cipher_text[i];
 668              		.loc 1 167 0 is_stmt 0 discriminator 1
 669 072b 83BDDCFD 		cmpl	$31, -548(%rbp)
 669      FFFF1F
 670 0732 7EC5     		jle	.L39
 671              	.LBE12:
 169:main.c        **** }
 672              		.loc 1 169 0 is_stmt 1
 673 0734 90       		nop
 674 0735 488B45F8 		movq	-8(%rbp), %rax
 675 0739 64483304 		xorq	%fs:40, %rax
 675      25280000 
 675      00
 676 0742 7405     		je	.L40
 677 0744 E8000000 		call	__stack_chk_fail
 677      00
 678              	.L40:
 679 0749 C9       		leave
 680              		.cfi_def_cfa 7, 8
 681 074a C3       		ret
 682              		.cfi_endproc
 683              	.LFE9:
 685              		.globl	decrypter
 687              	decrypter:
 688              	.LFB10:
 170:main.c        **** 
 171:main.c        **** void decrypter(int P[], int K[], int bin[])
 172:main.c        **** {
 689              		.loc 1 172 0
 690              		.cfi_startproc
 691 074b 55       		pushq	%rbp
 692              		.cfi_def_cfa_offset 16
 693              		.cfi_offset 6, -16
 694 074c 4889E5   		movq	%rsp, %rbp
 695              		.cfi_def_cfa_register 6
 696 074f 4881EC60 		subq	$608, %rsp
 696      020000
 697 0756 4889BDB8 		movq	%rdi, -584(%rbp)
 697      FDFFFF
 698 075d 4889B5B0 		movq	%rsi, -592(%rbp)
 698      FDFFFF
 699 0764 488995A8 		movq	%rdx, -600(%rbp)
 699      FDFFFF
 700              		.loc 1 172 0
 701 076b 64488B04 		movq	%fs:40, %rax
 701      25280000 
 701      00
 702 0774 488945F8 		movq	%rax, -8(%rbp)
 703 0778 31C0     		xorl	%eax, %eax
 173:main.c        ****   //int plain_text[32];
 174:main.c        **** 	int key[32];
 175:main.c        **** 	int cipher_text[32];
 176:main.c        **** 	int T[4];
 177:main.c        **** 	int count1=0;
 704              		.loc 1 177 0
 705 077a C785C0FD 		movl	$0, -576(%rbp)
 705      FFFF0000 
 705      0000
 706              	.LBB13:
 178:main.c        **** 
 179:main.c        **** 	for (int i = 0; i < 32; ++i)
 707              		.loc 1 179 0
 708 0784 C785C4FD 		movl	$0, -572(%rbp)
 708      FFFF0000 
 708      0000
 709 078e E9840000 		jmp	.L42
 709      00
 710              	.L44:
 180:main.c        **** 	{
 181:main.c        **** 		cipher_text[i] = P[i];
 711              		.loc 1 181 0
 712 0793 8B85C4FD 		movl	-572(%rbp), %eax
 712      FFFF
 713 0799 4898     		cltq
 714 079b 488D1485 		leaq	0(,%rax,4), %rdx
 714      00000000 
 715 07a3 488B85B8 		movq	-584(%rbp), %rax
 715      FDFFFF
 716 07aa 4801D0   		addq	%rdx, %rax
 717 07ad 8B10     		movl	(%rax), %edx
 718 07af 8B85C4FD 		movl	-572(%rbp), %eax
 718      FFFF
 719 07b5 4898     		cltq
 720 07b7 899485F0 		movl	%edx, -272(%rbp,%rax,4)
 720      FEFFFF
 182:main.c        **** 		key[i] = K[i];
 721              		.loc 1 182 0
 722 07be 8B85C4FD 		movl	-572(%rbp), %eax
 722      FFFF
 723 07c4 4898     		cltq
 724 07c6 488D1485 		leaq	0(,%rax,4), %rdx
 724      00000000 
 725 07ce 488B85B0 		movq	-592(%rbp), %rax
 725      FDFFFF
 726 07d5 4801D0   		addq	%rdx, %rax
 727 07d8 8B10     		movl	(%rax), %edx
 728 07da 8B85C4FD 		movl	-572(%rbp), %eax
 728      FFFF
 729 07e0 4898     		cltq
 730 07e2 89948570 		movl	%edx, -400(%rbp,%rax,4)
 730      FEFFFF
 183:main.c        **** 		if(K[i] == 0) 
 731              		.loc 1 183 0
 732 07e9 8B85C4FD 		movl	-572(%rbp), %eax
 732      FFFF
 733 07ef 4898     		cltq
 734 07f1 488D1485 		leaq	0(,%rax,4), %rdx
 734      00000000 
 735 07f9 488B85B0 		movq	-592(%rbp), %rax
 735      FDFFFF
 736 0800 4801D0   		addq	%rdx, %rax
 737 0803 8B00     		movl	(%rax), %eax
 738 0805 85C0     		testl	%eax, %eax
 739 0807 7507     		jne	.L43
 184:main.c        **** 			count1++;
 740              		.loc 1 184 0
 741 0809 8385C0FD 		addl	$1, -576(%rbp)
 741      FFFF01
 742              	.L43:
 179:main.c        **** 	{
 743              		.loc 1 179 0 discriminator 2
 744 0810 8385C4FD 		addl	$1, -572(%rbp)
 744      FFFF01
 745              	.L42:
 179:main.c        **** 	{
 746              		.loc 1 179 0 is_stmt 0 discriminator 1
 747 0817 83BDC4FD 		cmpl	$31, -572(%rbp)
 747      FFFF1F
 748 081e 0F8E6FFF 		jle	.L44
 748      FFFF
 749              	.LBE13:
 750              	.LBB14:
 185:main.c        **** 	}
 186:main.c        **** 
 187:main.c        **** 	int arr0[8];
 188:main.c        **** 	int arr1[8];
 189:main.c        **** 	int arr2[8];
 190:main.c        **** 	int arr3[8];
 191:main.c        **** 
 192:main.c        **** 	for(int i=0; i<8; i++)
 751              		.loc 1 192 0 is_stmt 1
 752 0824 C785C8FD 		movl	$0, -568(%rbp)
 752      FFFF0000 
 752      0000
 753 082e E9940000 		jmp	.L45
 753      00
 754              	.L46:
 193:main.c        **** 	{
 194:main.c        **** 		arr0[i] = key[4*i];
 755              		.loc 1 194 0 discriminator 3
 756 0833 8B85C8FD 		movl	-568(%rbp), %eax
 756      FFFF
 757 0839 C1E002   		sall	$2, %eax
 758 083c 4898     		cltq
 759 083e 8B948570 		movl	-400(%rbp,%rax,4), %edx
 759      FEFFFF
 760 0845 8B85C8FD 		movl	-568(%rbp), %eax
 760      FFFF
 761 084b 4898     		cltq
 762 084d 899485F0 		movl	%edx, -528(%rbp,%rax,4)
 762      FDFFFF
 195:main.c        **** 		arr1[i] = key[4*i+1];
 763              		.loc 1 195 0 discriminator 3
 764 0854 8B85C8FD 		movl	-568(%rbp), %eax
 764      FFFF
 765 085a C1E002   		sall	$2, %eax
 766 085d 83C001   		addl	$1, %eax
 767 0860 4898     		cltq
 768 0862 8B948570 		movl	-400(%rbp,%rax,4), %edx
 768      FEFFFF
 769 0869 8B85C8FD 		movl	-568(%rbp), %eax
 769      FFFF
 770 086f 4898     		cltq
 771 0871 89948510 		movl	%edx, -496(%rbp,%rax,4)
 771      FEFFFF
 196:main.c        **** 		arr2[i] = key[4*i+2];
 772              		.loc 1 196 0 discriminator 3
 773 0878 8B85C8FD 		movl	-568(%rbp), %eax
 773      FFFF
 774 087e C1E002   		sall	$2, %eax
 775 0881 83C002   		addl	$2, %eax
 776 0884 4898     		cltq
 777 0886 8B948570 		movl	-400(%rbp,%rax,4), %edx
 777      FEFFFF
 778 088d 8B85C8FD 		movl	-568(%rbp), %eax
 778      FFFF
 779 0893 4898     		cltq
 780 0895 89948530 		movl	%edx, -464(%rbp,%rax,4)
 780      FEFFFF
 197:main.c        **** 		arr3[i] = key[4*i+3];
 781              		.loc 1 197 0 discriminator 3
 782 089c 8B85C8FD 		movl	-568(%rbp), %eax
 782      FFFF
 783 08a2 C1E002   		sall	$2, %eax
 784 08a5 83C003   		addl	$3, %eax
 785 08a8 4898     		cltq
 786 08aa 8B948570 		movl	-400(%rbp,%rax,4), %edx
 786      FEFFFF
 787 08b1 8B85C8FD 		movl	-568(%rbp), %eax
 787      FFFF
 788 08b7 4898     		cltq
 789 08b9 89948550 		movl	%edx, -432(%rbp,%rax,4)
 789      FEFFFF
 192:main.c        **** 	{
 790              		.loc 1 192 0 discriminator 3
 791 08c0 8385C8FD 		addl	$1, -568(%rbp)
 791      FFFF01
 792              	.L45:
 192:main.c        **** 	{
 793              		.loc 1 192 0 is_stmt 0 discriminator 1
 794 08c7 83BDC8FD 		cmpl	$7, -568(%rbp)
 794      FFFF07
 795 08ce 0F8E5FFF 		jle	.L46
 795      FFFF
 796              	.LBE14:
 198:main.c        **** 	}
 199:main.c        **** 
 200:main.c        **** 	T[0] = myxor(arr0);
 797              		.loc 1 200 0 is_stmt 1
 798 08d4 488D85F0 		leaq	-528(%rbp), %rax
 798      FDFFFF
 799 08db 4889C7   		movq	%rax, %rdi
 800 08de E8000000 		call	myxor
 800      00
 801 08e3 8985E0FD 		movl	%eax, -544(%rbp)
 801      FFFF
 201:main.c        **** 	T[1] = myxor(arr1);
 802              		.loc 1 201 0
 803 08e9 488D8510 		leaq	-496(%rbp), %rax
 803      FEFFFF
 804 08f0 4889C7   		movq	%rax, %rdi
 805 08f3 E8000000 		call	myxor
 805      00
 806 08f8 8985E4FD 		movl	%eax, -540(%rbp)
 806      FFFF
 202:main.c        **** 	T[2] = myxor(arr2);
 807              		.loc 1 202 0
 808 08fe 488D8530 		leaq	-464(%rbp), %rax
 808      FEFFFF
 809 0905 4889C7   		movq	%rax, %rdi
 810 0908 E8000000 		call	myxor
 810      00
 811 090d 8985E8FD 		movl	%eax, -536(%rbp)
 811      FFFF
 203:main.c        **** 	T[3] = myxor(arr3);
 812              		.loc 1 203 0
 813 0913 488D8550 		leaq	-432(%rbp), %rax
 813      FEFFFF
 814 091a 4889C7   		movq	%rax, %rdi
 815 091d E8000000 		call	myxor
 815      00
 816 0922 8985ECFD 		movl	%eax, -532(%rbp)
 816      FFFF
 204:main.c        **** 
 205:main.c        **** 	int T32[32];
 206:main.c        **** 	int dec = bitArrayToInt(T, 4);
 817              		.loc 1 206 0
 818 0928 488D85E0 		leaq	-544(%rbp), %rax
 818      FDFFFF
 819 092f BE040000 		movl	$4, %esi
 819      00
 820 0934 4889C7   		movq	%rax, %rdi
 821 0937 E8000000 		call	bitArrayToInt
 821      00
 822 093c 8985CCFD 		movl	%eax, -564(%rbp)
 822      FFFF
 207:main.c        **** 	dec = (dec+15)%16;
 823              		.loc 1 207 0
 824 0942 8B85CCFD 		movl	-564(%rbp), %eax
 824      FFFF
 825 0948 8D500F   		leal	15(%rax), %edx
 826 094b 89D0     		movl	%edx, %eax
 827 094d C1F81F   		sarl	$31, %eax
 828 0950 C1E81C   		shrl	$28, %eax
 829 0953 01C2     		addl	%eax, %edx
 830 0955 83E20F   		andl	$15, %edx
 831 0958 29C2     		subl	%eax, %edx
 832 095a 89D0     		movl	%edx, %eax
 833 095c 8985CCFD 		movl	%eax, -564(%rbp)
 833      FFFF
 208:main.c        **** 	decToBinary(dec, T, 4);
 834              		.loc 1 208 0
 835 0962 488D8DE0 		leaq	-544(%rbp), %rcx
 835      FDFFFF
 836 0969 8B85CCFD 		movl	-564(%rbp), %eax
 836      FFFF
 837 096f BA040000 		movl	$4, %edx
 837      00
 838 0974 4889CE   		movq	%rcx, %rsi
 839 0977 89C7     		movl	%eax, %edi
 840 0979 E8000000 		call	decToBinary
 840      00
 841              	.LBB15:
 209:main.c        **** 
 210:main.c        **** 	for (int i = 0; i < count1; ++i)
 842              		.loc 1 210 0
 843 097e C785D0FD 		movl	$0, -560(%rbp)
 843      FFFF0000 
 843      0000
 844 0988 E9130100 		jmp	.L47
 844      00
 845              	.L52:
 846              	.LBB16:
 211:main.c        **** 	{ 
 212:main.c        **** 		for (int j = 0; j < 8; j++)
 847              		.loc 1 212 0
 848 098d C785D4FD 		movl	$0, -556(%rbp)
 848      FFFF0000 
 848      0000
 849 0997 EB70     		jmp	.L48
 850              	.L49:
 213:main.c        **** 		{
 214:main.c        **** 			T32[4*j] = T[0];
 851              		.loc 1 214 0 discriminator 3
 852 0999 8B85D4FD 		movl	-556(%rbp), %eax
 852      FFFF
 853 099f C1E002   		sall	$2, %eax
 854 09a2 8B95E0FD 		movl	-544(%rbp), %edx
 854      FFFF
 855 09a8 4898     		cltq
 856 09aa 89948570 		movl	%edx, -144(%rbp,%rax,4)
 856      FFFFFF
 215:main.c        **** 			T32[4*j+1] = T[1];
 857              		.loc 1 215 0 discriminator 3
 858 09b1 8B85D4FD 		movl	-556(%rbp), %eax
 858      FFFF
 859 09b7 C1E002   		sall	$2, %eax
 860 09ba 83C001   		addl	$1, %eax
 861 09bd 8B95E4FD 		movl	-540(%rbp), %edx
 861      FFFF
 862 09c3 4898     		cltq
 863 09c5 89948570 		movl	%edx, -144(%rbp,%rax,4)
 863      FFFFFF
 216:main.c        **** 			T32[4*j+2] = T[2];
 864              		.loc 1 216 0 discriminator 3
 865 09cc 8B85D4FD 		movl	-556(%rbp), %eax
 865      FFFF
 866 09d2 C1E002   		sall	$2, %eax
 867 09d5 83C002   		addl	$2, %eax
 868 09d8 8B95E8FD 		movl	-536(%rbp), %edx
 868      FFFF
 869 09de 4898     		cltq
 870 09e0 89948570 		movl	%edx, -144(%rbp,%rax,4)
 870      FFFFFF
 217:main.c        **** 			T32[4*j+3] = T[3];
 871              		.loc 1 217 0 discriminator 3
 872 09e7 8B85D4FD 		movl	-556(%rbp), %eax
 872      FFFF
 873 09ed C1E002   		sall	$2, %eax
 874 09f0 83C003   		addl	$3, %eax
 875 09f3 8B95ECFD 		movl	-532(%rbp), %edx
 875      FFFF
 876 09f9 4898     		cltq
 877 09fb 89948570 		movl	%edx, -144(%rbp,%rax,4)
 877      FFFFFF
 212:main.c        **** 		{
 878              		.loc 1 212 0 discriminator 3
 879 0a02 8385D4FD 		addl	$1, -556(%rbp)
 879      FFFF01
 880              	.L48:
 212:main.c        **** 		{
 881              		.loc 1 212 0 is_stmt 0 discriminator 1
 882 0a09 83BDD4FD 		cmpl	$7, -556(%rbp)
 882      FFFF07
 883 0a10 7E87     		jle	.L49
 884              	.LBE16:
 885              	.LBB17:
 218:main.c        **** 		}
 219:main.c        **** 
 220:main.c        **** 		for (int j = 0; j < 32; ++j)
 886              		.loc 1 220 0 is_stmt 1
 887 0a12 C785D8FD 		movl	$0, -552(%rbp)
 887      FFFF0000 
 887      0000
 888 0a1c EB36     		jmp	.L50
 889              	.L51:
 221:main.c        **** 			cipher_text[j] = cipher_text[j] ^ T32[j];
 890              		.loc 1 221 0 discriminator 3
 891 0a1e 8B85D8FD 		movl	-552(%rbp), %eax
 891      FFFF
 892 0a24 4898     		cltq
 893 0a26 8B9485F0 		movl	-272(%rbp,%rax,4), %edx
 893      FEFFFF
 894 0a2d 8B85D8FD 		movl	-552(%rbp), %eax
 894      FFFF
 895 0a33 4898     		cltq
 896 0a35 8B848570 		movl	-144(%rbp,%rax,4), %eax
 896      FFFFFF
 897 0a3c 31C2     		xorl	%eax, %edx
 898 0a3e 8B85D8FD 		movl	-552(%rbp), %eax
 898      FFFF
 899 0a44 4898     		cltq
 900 0a46 899485F0 		movl	%edx, -272(%rbp,%rax,4)
 900      FEFFFF
 220:main.c        **** 			cipher_text[j] = cipher_text[j] ^ T32[j];
 901              		.loc 1 220 0 discriminator 3
 902 0a4d 8385D8FD 		addl	$1, -552(%rbp)
 902      FFFF01
 903              	.L50:
 220:main.c        **** 			cipher_text[j] = cipher_text[j] ^ T32[j];
 904              		.loc 1 220 0 is_stmt 0 discriminator 1
 905 0a54 83BDD8FD 		cmpl	$31, -552(%rbp)
 905      FFFF1F
 906 0a5b 7EC1     		jle	.L51
 907              	.LBE17:
 222:main.c        **** 
 223:main.c        **** 		dec=(dec+15)%16;
 908              		.loc 1 223 0 is_stmt 1 discriminator 2
 909 0a5d 8B85CCFD 		movl	-564(%rbp), %eax
 909      FFFF
 910 0a63 8D500F   		leal	15(%rax), %edx
 911 0a66 89D0     		movl	%edx, %eax
 912 0a68 C1F81F   		sarl	$31, %eax
 913 0a6b C1E81C   		shrl	$28, %eax
 914 0a6e 01C2     		addl	%eax, %edx
 915 0a70 83E20F   		andl	$15, %edx
 916 0a73 29C2     		subl	%eax, %edx
 917 0a75 89D0     		movl	%edx, %eax
 918 0a77 8985CCFD 		movl	%eax, -564(%rbp)
 918      FFFF
 224:main.c        **** 		decToBinary(dec, T, 4);
 919              		.loc 1 224 0 discriminator 2
 920 0a7d 488D8DE0 		leaq	-544(%rbp), %rcx
 920      FDFFFF
 921 0a84 8B85CCFD 		movl	-564(%rbp), %eax
 921      FFFF
 922 0a8a BA040000 		movl	$4, %edx
 922      00
 923 0a8f 4889CE   		movq	%rcx, %rsi
 924 0a92 89C7     		movl	%eax, %edi
 925 0a94 E8000000 		call	decToBinary
 925      00
 210:main.c        **** 	{ 
 926              		.loc 1 210 0 discriminator 2
 927 0a99 8385D0FD 		addl	$1, -560(%rbp)
 927      FFFF01
 928              	.L47:
 210:main.c        **** 	{ 
 929              		.loc 1 210 0 is_stmt 0 discriminator 1
 930 0aa0 8B85D0FD 		movl	-560(%rbp), %eax
 930      FFFF
 931 0aa6 3B85C0FD 		cmpl	-576(%rbp), %eax
 931      FFFF
 932 0aac 0F8CDBFE 		jl	.L52
 932      FFFF
 933              	.LBE15:
 934              	.LBB18:
 225:main.c        **** 	}
 226:main.c        **** 
 227:main.c        **** 	for (int i = 0; i < 32; ++i)
 935              		.loc 1 227 0 is_stmt 1
 936 0ab2 C785DCFD 		movl	$0, -548(%rbp)
 936      FFFF0000 
 936      0000
 937 0abc EB32     		jmp	.L53
 938              	.L54:
 228:main.c        **** 		bin[i] = cipher_text[i];
 939              		.loc 1 228 0 discriminator 3
 940 0abe 8B85DCFD 		movl	-548(%rbp), %eax
 940      FFFF
 941 0ac4 4898     		cltq
 942 0ac6 488D1485 		leaq	0(,%rax,4), %rdx
 942      00000000 
 943 0ace 488B85A8 		movq	-600(%rbp), %rax
 943      FDFFFF
 944 0ad5 4801C2   		addq	%rax, %rdx
 945 0ad8 8B85DCFD 		movl	-548(%rbp), %eax
 945      FFFF
 946 0ade 4898     		cltq
 947 0ae0 8B8485F0 		movl	-272(%rbp,%rax,4), %eax
 947      FEFFFF
 948 0ae7 8902     		movl	%eax, (%rdx)
 227:main.c        **** 		bin[i] = cipher_text[i];
 949              		.loc 1 227 0 discriminator 3
 950 0ae9 8385DCFD 		addl	$1, -548(%rbp)
 950      FFFF01
 951              	.L53:
 227:main.c        **** 		bin[i] = cipher_text[i];
 952              		.loc 1 227 0 is_stmt 0 discriminator 1
 953 0af0 83BDDCFD 		cmpl	$31, -548(%rbp)
 953      FFFF1F
 954 0af7 7EC5     		jle	.L54
 955              	.LBE18:
 229:main.c        **** }
 956              		.loc 1 229 0 is_stmt 1
 957 0af9 90       		nop
 958 0afa 488B45F8 		movq	-8(%rbp), %rax
 959 0afe 64483304 		xorq	%fs:40, %rax
 959      25280000 
 959      00
 960 0b07 7405     		je	.L55
 961 0b09 E8000000 		call	__stack_chk_fail
 961      00
 962              	.L55:
 963 0b0e C9       		leave
 964              		.cfi_def_cfa 7, 8
 965 0b0f C3       		ret
 966              		.cfi_endproc
 967              	.LFE10:
 969              		.globl	convert_to_binary
 971              	convert_to_binary:
 972              	.LFB11:
 230:main.c        **** 
 231:main.c        **** 
 232:main.c        **** void convert_to_binary(int co_ordinates[8], unsigned int* buff)
 233:main.c        **** {  
 973              		.loc 1 233 0
 974              		.cfi_startproc
 975 0b10 55       		pushq	%rbp
 976              		.cfi_def_cfa_offset 16
 977              		.cfi_offset 6, -16
 978 0b11 4889E5   		movq	%rsp, %rbp
 979              		.cfi_def_cfa_register 6
 980 0b14 48897DE8 		movq	%rdi, -24(%rbp)
 981 0b18 488975E0 		movq	%rsi, -32(%rbp)
 234:main.c        **** 	int arb = 0;
 982              		.loc 1 234 0
 983 0b1c C745FC00 		movl	$0, -4(%rbp)
 983      000000
 235:main.c        **** 	int i = 7;
 984              		.loc 1 235 0
 985 0b23 C745F807 		movl	$7, -8(%rbp)
 985      000000
 236:main.c        **** 	while(buff[0]!=0)
 986              		.loc 1 236 0
 987 0b2a EB39     		jmp	.L57
 988              	.L58:
 237:main.c        **** 	{  //printf("%s\n", "Running");
 238:main.c        **** arb = buff[0] % 2;
 989              		.loc 1 238 0
 990 0b2c 488B45E0 		movq	-32(%rbp), %rax
 991 0b30 8B00     		movl	(%rax), %eax
 992 0b32 83E001   		andl	$1, %eax
 993 0b35 8945FC   		movl	%eax, -4(%rbp)
 239:main.c        **** buff[0] = buff[0]/2;
 994              		.loc 1 239 0
 995 0b38 488B45E0 		movq	-32(%rbp), %rax
 996 0b3c 8B00     		movl	(%rax), %eax
 997 0b3e D1E8     		shrl	%eax
 998 0b40 89C2     		movl	%eax, %edx
 999 0b42 488B45E0 		movq	-32(%rbp), %rax
 1000 0b46 8910     		movl	%edx, (%rax)
 240:main.c        **** co_ordinates[i] = arb;
 1001              		.loc 1 240 0
 1002 0b48 8B45F8   		movl	-8(%rbp), %eax
 1003 0b4b 4898     		cltq
 1004 0b4d 488D1485 		leaq	0(,%rax,4), %rdx
 1004      00000000 
 1005 0b55 488B45E8 		movq	-24(%rbp), %rax
 1006 0b59 4801C2   		addq	%rax, %rdx
 1007 0b5c 8B45FC   		movl	-4(%rbp), %eax
 1008 0b5f 8902     		movl	%eax, (%rdx)
 241:main.c        **** i--;	
 1009              		.loc 1 241 0
 1010 0b61 836DF801 		subl	$1, -8(%rbp)
 1011              	.L57:
 236:main.c        **** 	{  //printf("%s\n", "Running");
 1012              		.loc 1 236 0
 1013 0b65 488B45E0 		movq	-32(%rbp), %rax
 1014 0b69 8B00     		movl	(%rax), %eax
 1015 0b6b 85C0     		testl	%eax, %eax
 1016 0b6d 75BD     		jne	.L58
 242:main.c        **** }
 243:main.c        **** }
 1017              		.loc 1 243 0
 1018 0b6f 90       		nop
 1019 0b70 5D       		popq	%rbp
 1020              		.cfi_def_cfa 7, 8
 1021 0b71 C3       		ret
 1022              		.cfi_endproc
 1023              	.LFE11:
 1025              		.section	.rodata
 1026              	.LC1:
 1027 0000 4572726F 		.string	"Error, not Running"
 1027      722C206E 
 1027      6F742052 
 1027      756E6E69 
 1027      6E6700
 1028              	.LC2:
 1029 0013 54686520 		.string	"The x and y"
 1029      7820616E 
 1029      64207900 
 1030              	.LC3:
 1031 001f 2025642C 		.string	" %d,%d,%d,%d,%d"
 1031      25642C25 
 1031      642C2564 
 1031      2C256400 
 1032 002f 00       		.align 16
 1033              	.LC0:
 1034 0030 303030   		.ascii	"000"
 1035 0033 303031   		.ascii	"001"
 1036 0036 303130   		.ascii	"010"
 1037 0039 303131   		.ascii	"011"
 1038 003c 313030   		.ascii	"100"
 1039 003f 313031   		.ascii	"101"
 1040 0042 313130   		.ascii	"110"
 1041 0045 313131   		.ascii	"111"
 1042              		.text
 1043              		.globl	print
 1045              	print:
 1046              	.LFB12:
 244:main.c        **** 
 245:main.c        **** void print(int x_cord, int y_cord, int final_arr[8][8], FILE * fp)
 246:main.c        **** {
 1047              		.loc 1 246 0
 1048              		.cfi_startproc
 1049 0b72 55       		pushq	%rbp
 1050              		.cfi_def_cfa_offset 16
 1051              		.cfi_offset 6, -16
 1052 0b73 4889E5   		movq	%rsp, %rbp
 1053              		.cfi_def_cfa_register 6
 1054 0b76 4881EC20 		subq	$288, %rsp
 1054      010000
 1055 0b7d 89BDFCFE 		movl	%edi, -260(%rbp)
 1055      FFFF
 1056 0b83 89B5F8FE 		movl	%esi, -264(%rbp)
 1056      FFFF
 1057 0b89 488995F0 		movq	%rdx, -272(%rbp)
 1057      FEFFFF
 1058 0b90 48898DE8 		movq	%rcx, -280(%rbp)
 1058      FEFFFF
 1059              		.loc 1 246 0
 1060 0b97 64488B04 		movq	%fs:40, %rax
 1060      25280000 
 1060      00
 1061 0ba0 488945F8 		movq	%rax, -8(%rbp)
 1062 0ba4 31C0     		xorl	%eax, %eax
 247:main.c        **** 
 248:main.c        **** 	int arr[8][5];
 249:main.c        **** 	int count = 0;
 1063              		.loc 1 249 0
 1064 0ba6 C78514FF 		movl	$0, -236(%rbp)
 1064      FFFF0000 
 1064      0000
 250:main.c        **** 	//printf("%s\n", "The x and y ");
 251:main.c        **** 
 252:main.c        **** 	char conversion[8][3] = {"000","001","010","011","100","101","110","111"};
 1065              		.loc 1 252 0
 1066 0bb0 488B0500 		movq	.LC0(%rip), %rax
 1066      000000
 1067 0bb7 48898530 		movq	%rax, -208(%rbp)
 1067      FFFFFF
 1068 0bbe 488B0500 		movq	.LC0+8(%rip), %rax
 1068      000000
 1069 0bc5 48898538 		movq	%rax, -200(%rbp)
 1069      FFFFFF
 1070 0bcc 488B0500 		movq	.LC0+16(%rip), %rax
 1070      000000
 1071 0bd3 48898540 		movq	%rax, -192(%rbp)
 1071      FFFFFF
 1072              	.LBB19:
 253:main.c        **** 
 254:main.c        **** 	for (int i = 0; i < 8; i++)
 1073              		.loc 1 254 0
 1074 0bda C78518FF 		movl	$0, -232(%rbp)
 1074      FFFF0000 
 1074      0000
 1075 0be4 E9E50000 		jmp	.L60
 1075      00
 1076              	.L61:
 255:main.c        **** 	{
 256:main.c        **** 		arr[i][0] = -1;
 1077              		.loc 1 256 0 discriminator 3
 1078 0be9 8B8518FF 		movl	-232(%rbp), %eax
 1078      FFFF
 1079 0bef 4863D0   		movslq	%eax, %rdx
 1080 0bf2 4889D0   		movq	%rdx, %rax
 1081 0bf5 48C1E002 		salq	$2, %rax
 1082 0bf9 4801D0   		addq	%rdx, %rax
 1083 0bfc 48C1E002 		salq	$2, %rax
 1084 0c00 4801E8   		addq	%rbp, %rax
 1085 0c03 482DB000 		subq	$176, %rax
 1085      0000
 1086 0c09 C700FFFF 		movl	$-1, (%rax)
 1086      FFFF
 257:main.c        **** 		arr[i][1] = -1;
 1087              		.loc 1 257 0 discriminator 3
 1088 0c0f 8B8518FF 		movl	-232(%rbp), %eax
 1088      FFFF
 1089 0c15 4863D0   		movslq	%eax, %rdx
 1090 0c18 4889D0   		movq	%rdx, %rax
 1091 0c1b 48C1E002 		salq	$2, %rax
 1092 0c1f 4801D0   		addq	%rdx, %rax
 1093 0c22 48C1E002 		salq	$2, %rax
 1094 0c26 4801E8   		addq	%rbp, %rax
 1095 0c29 482DAC00 		subq	$172, %rax
 1095      0000
 1096 0c2f C700FFFF 		movl	$-1, (%rax)
 1096      FFFF
 258:main.c        **** 		arr[i][2] = -1;
 1097              		.loc 1 258 0 discriminator 3
 1098 0c35 8B8518FF 		movl	-232(%rbp), %eax
 1098      FFFF
 1099 0c3b 4863D0   		movslq	%eax, %rdx
 1100 0c3e 4889D0   		movq	%rdx, %rax
 1101 0c41 48C1E002 		salq	$2, %rax
 1102 0c45 4801D0   		addq	%rdx, %rax
 1103 0c48 48C1E002 		salq	$2, %rax
 1104 0c4c 4801E8   		addq	%rbp, %rax
 1105 0c4f 482DA800 		subq	$168, %rax
 1105      0000
 1106 0c55 C700FFFF 		movl	$-1, (%rax)
 1106      FFFF
 259:main.c        **** 		arr[i][3] = -1;
 1107              		.loc 1 259 0 discriminator 3
 1108 0c5b 8B8518FF 		movl	-232(%rbp), %eax
 1108      FFFF
 1109 0c61 4863D0   		movslq	%eax, %rdx
 1110 0c64 4889D0   		movq	%rdx, %rax
 1111 0c67 48C1E002 		salq	$2, %rax
 1112 0c6b 4801D0   		addq	%rdx, %rax
 1113 0c6e 48C1E002 		salq	$2, %rax
 1114 0c72 4801E8   		addq	%rbp, %rax
 1115 0c75 482DA400 		subq	$164, %rax
 1115      0000
 1116 0c7b C700FFFF 		movl	$-1, (%rax)
 1116      FFFF
 260:main.c        **** 		arr[i][4] = -1;
 1117              		.loc 1 260 0 discriminator 3
 1118 0c81 8B8518FF 		movl	-232(%rbp), %eax
 1118      FFFF
 1119 0c87 4863D0   		movslq	%eax, %rdx
 1120 0c8a 4889D0   		movq	%rdx, %rax
 1121 0c8d 48C1E002 		salq	$2, %rax
 1122 0c91 4801D0   		addq	%rdx, %rax
 1123 0c94 48C1E002 		salq	$2, %rax
 1124 0c98 4801E8   		addq	%rbp, %rax
 1125 0c9b 482DA000 		subq	$160, %rax
 1125      0000
 1126 0ca1 C700FFFF 		movl	$-1, (%rax)
 1126      FFFF
 261:main.c        **** 		final_arr[i][7] = -1;
 1127              		.loc 1 261 0 discriminator 3
 1128 0ca7 8B8518FF 		movl	-232(%rbp), %eax
 1128      FFFF
 1129 0cad 4898     		cltq
 1130 0caf 48C1E005 		salq	$5, %rax
 1131 0cb3 4889C2   		movq	%rax, %rdx
 1132 0cb6 488B85F0 		movq	-272(%rbp), %rax
 1132      FEFFFF
 1133 0cbd 4801D0   		addq	%rdx, %rax
 1134 0cc0 C7401CFF 		movl	$-1, 28(%rax)
 1134      FFFFFF
 254:main.c        **** 	{
 1135              		.loc 1 254 0 discriminator 3
 1136 0cc7 838518FF 		addl	$1, -232(%rbp)
 1136      FFFF01
 1137              	.L60:
 254:main.c        **** 	{
 1138              		.loc 1 254 0 is_stmt 0 discriminator 1
 1139 0cce 83BD18FF 		cmpl	$7, -232(%rbp)
 1139      FFFF07
 1140 0cd5 0F8E0EFF 		jle	.L61
 1140      FFFF
 1141              	.LBE19:
 262:main.c        **** 	}
 263:main.c        **** 
 264:main.c        **** 	if(fp == NULL)
 1142              		.loc 1 264 0 is_stmt 1
 1143 0cdb 4883BDE8 		cmpq	$0, -280(%rbp)
 1143      FEFFFF00 
 1144 0ce3 751E     		jne	.L62
 265:main.c        **** 	{
 266:main.c        **** 		fprintf(stderr, "Error, not Running" );
 1145              		.loc 1 266 0
 1146 0ce5 488B0500 		movq	stderr(%rip), %rax
 1146      000000
 1147 0cec 4889C1   		movq	%rax, %rcx
 1148 0cef BA120000 		movl	$18, %edx
 1148      00
 1149 0cf4 BE010000 		movl	$1, %esi
 1149      00
 1150 0cf9 BF000000 		movl	$.LC1, %edi
 1150      00
 1151 0cfe E8000000 		call	fwrite
 1151      00
 1152              	.L62:
 267:main.c        **** 	}
 268:main.c        **** 	int a,b,c,d,e;
 269:main.c        **** 	printf("%s\n", "The x and y");
 1153              		.loc 1 269 0
 1154 0d03 BF000000 		movl	$.LC2, %edi
 1154      00
 1155 0d08 E8000000 		call	puts
 1155      00
 270:main.c        **** 	while (fscanf(fp, " %d,%d,%d,%d,%d", &a, &b,&c,&d,&e) == 5) {
 1156              		.loc 1 270 0
 1157 0d0d E9F50000 		jmp	.L63
 1157      00
 1158              	.L64:
 271:main.c        **** 
 272:main.c        **** 		if(a==x_cord && b==y_cord)
 1159              		.loc 1 272 0
 1160 0d12 8B8500FF 		movl	-256(%rbp), %eax
 1160      FFFF
 1161 0d18 3B85FCFE 		cmpl	-260(%rbp), %eax
 1161      FFFF
 1162 0d1e 0F85E300 		jne	.L63
 1162      0000
 1163              		.loc 1 272 0 is_stmt 0 discriminator 1
 1164 0d24 8B8504FF 		movl	-252(%rbp), %eax
 1164      FFFF
 1165 0d2a 3B85F8FE 		cmpl	-264(%rbp), %eax
 1165      FFFF
 1166 0d30 0F85D100 		jne	.L63
 1166      0000
 273:main.c        **** 		{
 274:main.c        **** 			arr[c][0] = x_cord;
 1167              		.loc 1 274 0 is_stmt 1
 1168 0d36 8B8508FF 		movl	-248(%rbp), %eax
 1168      FFFF
 1169 0d3c 4863D0   		movslq	%eax, %rdx
 1170 0d3f 4889D0   		movq	%rdx, %rax
 1171 0d42 48C1E002 		salq	$2, %rax
 1172 0d46 4801D0   		addq	%rdx, %rax
 1173 0d49 48C1E002 		salq	$2, %rax
 1174 0d4d 4801E8   		addq	%rbp, %rax
 1175 0d50 488D9050 		leaq	-176(%rax), %rdx
 1175      FFFFFF
 1176 0d57 8B85FCFE 		movl	-260(%rbp), %eax
 1176      FFFF
 1177 0d5d 8902     		movl	%eax, (%rdx)
 275:main.c        **** 			arr[c][1] = y_cord;
 1178              		.loc 1 275 0
 1179 0d5f 8B8508FF 		movl	-248(%rbp), %eax
 1179      FFFF
 1180 0d65 4863D0   		movslq	%eax, %rdx
 1181 0d68 4889D0   		movq	%rdx, %rax
 1182 0d6b 48C1E002 		salq	$2, %rax
 1183 0d6f 4801D0   		addq	%rdx, %rax
 1184 0d72 48C1E002 		salq	$2, %rax
 1185 0d76 4801E8   		addq	%rbp, %rax
 1186 0d79 488D9054 		leaq	-172(%rax), %rdx
 1186      FFFFFF
 1187 0d80 8B85F8FE 		movl	-264(%rbp), %eax
 1187      FFFF
 1188 0d86 8902     		movl	%eax, (%rdx)
 276:main.c        **** 			arr[c][2] = c;
 1189              		.loc 1 276 0
 1190 0d88 8B8508FF 		movl	-248(%rbp), %eax
 1190      FFFF
 1191 0d8e 8B8D08FF 		movl	-248(%rbp), %ecx
 1191      FFFF
 1192 0d94 4863D0   		movslq	%eax, %rdx
 1193 0d97 4889D0   		movq	%rdx, %rax
 1194 0d9a 48C1E002 		salq	$2, %rax
 1195 0d9e 4801D0   		addq	%rdx, %rax
 1196 0da1 48C1E002 		salq	$2, %rax
 1197 0da5 4801E8   		addq	%rbp, %rax
 1198 0da8 482DA800 		subq	$168, %rax
 1198      0000
 1199 0dae 8908     		movl	%ecx, (%rax)
 277:main.c        **** 			arr[c][3] = d;
 1200              		.loc 1 277 0
 1201 0db0 8B8508FF 		movl	-248(%rbp), %eax
 1201      FFFF
 1202 0db6 8B8D0CFF 		movl	-244(%rbp), %ecx
 1202      FFFF
 1203 0dbc 4863D0   		movslq	%eax, %rdx
 1204 0dbf 4889D0   		movq	%rdx, %rax
 1205 0dc2 48C1E002 		salq	$2, %rax
 1206 0dc6 4801D0   		addq	%rdx, %rax
 1207 0dc9 48C1E002 		salq	$2, %rax
 1208 0dcd 4801E8   		addq	%rbp, %rax
 1209 0dd0 482DA400 		subq	$164, %rax
 1209      0000
 1210 0dd6 8908     		movl	%ecx, (%rax)
 278:main.c        **** 			arr[c][4] = e;
 1211              		.loc 1 278 0
 1212 0dd8 8B8508FF 		movl	-248(%rbp), %eax
 1212      FFFF
 1213 0dde 8B8D10FF 		movl	-240(%rbp), %ecx
 1213      FFFF
 1214 0de4 4863D0   		movslq	%eax, %rdx
 1215 0de7 4889D0   		movq	%rdx, %rax
 1216 0dea 48C1E002 		salq	$2, %rax
 1217 0dee 4801D0   		addq	%rdx, %rax
 1218 0df1 48C1E002 		salq	$2, %rax
 1219 0df5 4801E8   		addq	%rbp, %rax
 1220 0df8 482DA000 		subq	$160, %rax
 1220      0000
 1221 0dfe 8908     		movl	%ecx, (%rax)
 279:main.c        **** 			count++;
 1222              		.loc 1 279 0
 1223 0e00 838514FF 		addl	$1, -236(%rbp)
 1223      FFFF01
 1224              	.L63:
 270:main.c        **** 
 1225              		.loc 1 270 0
 1226 0e07 4C8D850C 		leaq	-244(%rbp), %r8
 1226      FFFFFF
 1227 0e0e 488DBD08 		leaq	-248(%rbp), %rdi
 1227      FFFFFF
 1228 0e15 488D8D04 		leaq	-252(%rbp), %rcx
 1228      FFFFFF
 1229 0e1c 488D9500 		leaq	-256(%rbp), %rdx
 1229      FFFFFF
 1230 0e23 488B85E8 		movq	-280(%rbp), %rax
 1230      FEFFFF
 1231 0e2a 4883EC08 		subq	$8, %rsp
 1232 0e2e 488DB510 		leaq	-240(%rbp), %rsi
 1232      FFFFFF
 1233 0e35 56       		pushq	%rsi
 1234 0e36 4D89C1   		movq	%r8, %r9
 1235 0e39 4989F8   		movq	%rdi, %r8
 1236 0e3c BE000000 		movl	$.LC3, %esi
 1236      00
 1237 0e41 4889C7   		movq	%rax, %rdi
 1238 0e44 B8000000 		movl	$0, %eax
 1238      00
 1239 0e49 E8000000 		call	__isoc99_fscanf
 1239      00
 1240 0e4e 4883C410 		addq	$16, %rsp
 1241 0e52 83F805   		cmpl	$5, %eax
 1242 0e55 0F84B7FE 		je	.L64
 1242      FFFF
 1243              	.LBB20:
 280:main.c        **** 
 281:main.c        **** 		}
 282:main.c        **** 
 283:main.c        **** 	}
 284:main.c        **** 
 285:main.c        **** 	for (int i = 0; i < 8; i++)
 1244              		.loc 1 285 0
 1245 0e5b C7851CFF 		movl	$0, -228(%rbp)
 1245      FFFF0000 
 1245      0000
 1246 0e65 E9C50100 		jmp	.L65
 1246      00
 1247              	.L67:
 286:main.c        **** 	{
 287:main.c        **** 		if(arr[i][0] == -1 && arr[i][1] == -1 && arr[i][2] == -1 && arr[i][3] == -1 && arr[i][4] == -1)
 1248              		.loc 1 287 0
 1249 0e6a 8B851CFF 		movl	-228(%rbp), %eax
 1249      FFFF
 1250 0e70 4863D0   		movslq	%eax, %rdx
 1251 0e73 4889D0   		movq	%rdx, %rax
 1252 0e76 48C1E002 		salq	$2, %rax
 1253 0e7a 4801D0   		addq	%rdx, %rax
 1254 0e7d 48C1E002 		salq	$2, %rax
 1255 0e81 4801E8   		addq	%rbp, %rax
 1256 0e84 482DB000 		subq	$176, %rax
 1256      0000
 1257 0e8a 8B00     		movl	(%rax), %eax
 1258 0e8c 83F8FF   		cmpl	$-1, %eax
 1259 0e8f 0F859301 		jne	.L66
 1259      0000
 1260              		.loc 1 287 0 is_stmt 0 discriminator 1
 1261 0e95 8B851CFF 		movl	-228(%rbp), %eax
 1261      FFFF
 1262 0e9b 4863D0   		movslq	%eax, %rdx
 1263 0e9e 4889D0   		movq	%rdx, %rax
 1264 0ea1 48C1E002 		salq	$2, %rax
 1265 0ea5 4801D0   		addq	%rdx, %rax
 1266 0ea8 48C1E002 		salq	$2, %rax
 1267 0eac 4801E8   		addq	%rbp, %rax
 1268 0eaf 482DAC00 		subq	$172, %rax
 1268      0000
 1269 0eb5 8B00     		movl	(%rax), %eax
 1270 0eb7 83F8FF   		cmpl	$-1, %eax
 1271 0eba 0F856801 		jne	.L66
 1271      0000
 1272              		.loc 1 287 0 discriminator 2
 1273 0ec0 8B851CFF 		movl	-228(%rbp), %eax
 1273      FFFF
 1274 0ec6 4863D0   		movslq	%eax, %rdx
 1275 0ec9 4889D0   		movq	%rdx, %rax
 1276 0ecc 48C1E002 		salq	$2, %rax
 1277 0ed0 4801D0   		addq	%rdx, %rax
 1278 0ed3 48C1E002 		salq	$2, %rax
 1279 0ed7 4801E8   		addq	%rbp, %rax
 1280 0eda 482DA800 		subq	$168, %rax
 1280      0000
 1281 0ee0 8B00     		movl	(%rax), %eax
 1282 0ee2 83F8FF   		cmpl	$-1, %eax
 1283 0ee5 0F853D01 		jne	.L66
 1283      0000
 1284              		.loc 1 287 0 discriminator 3
 1285 0eeb 8B851CFF 		movl	-228(%rbp), %eax
 1285      FFFF
 1286 0ef1 4863D0   		movslq	%eax, %rdx
 1287 0ef4 4889D0   		movq	%rdx, %rax
 1288 0ef7 48C1E002 		salq	$2, %rax
 1289 0efb 4801D0   		addq	%rdx, %rax
 1290 0efe 48C1E002 		salq	$2, %rax
 1291 0f02 4801E8   		addq	%rbp, %rax
 1292 0f05 482DA400 		subq	$164, %rax
 1292      0000
 1293 0f0b 8B00     		movl	(%rax), %eax
 1294 0f0d 83F8FF   		cmpl	$-1, %eax
 1295 0f10 0F851201 		jne	.L66
 1295      0000
 1296              		.loc 1 287 0 discriminator 4
 1297 0f16 8B851CFF 		movl	-228(%rbp), %eax
 1297      FFFF
 1298 0f1c 4863D0   		movslq	%eax, %rdx
 1299 0f1f 4889D0   		movq	%rdx, %rax
 1300 0f22 48C1E002 		salq	$2, %rax
 1301 0f26 4801D0   		addq	%rdx, %rax
 1302 0f29 48C1E002 		salq	$2, %rax
 1303 0f2d 4801E8   		addq	%rbp, %rax
 1304 0f30 482DA000 		subq	$160, %rax
 1304      0000
 1305 0f36 8B00     		movl	(%rax), %eax
 1306 0f38 83F8FF   		cmpl	$-1, %eax
 1307 0f3b 0F85E700 		jne	.L66
 1307      0000
 288:main.c        **** 		{
 289:main.c        **** 			arr[i][0] = x_cord;
 1308              		.loc 1 289 0 is_stmt 1
 1309 0f41 8B851CFF 		movl	-228(%rbp), %eax
 1309      FFFF
 1310 0f47 4863D0   		movslq	%eax, %rdx
 1311 0f4a 4889D0   		movq	%rdx, %rax
 1312 0f4d 48C1E002 		salq	$2, %rax
 1313 0f51 4801D0   		addq	%rdx, %rax
 1314 0f54 48C1E002 		salq	$2, %rax
 1315 0f58 4801E8   		addq	%rbp, %rax
 1316 0f5b 488D9050 		leaq	-176(%rax), %rdx
 1316      FFFFFF
 1317 0f62 8B85FCFE 		movl	-260(%rbp), %eax
 1317      FFFF
 1318 0f68 8902     		movl	%eax, (%rdx)
 290:main.c        **** 			arr[i][1] = y_cord;
 1319              		.loc 1 290 0
 1320 0f6a 8B851CFF 		movl	-228(%rbp), %eax
 1320      FFFF
 1321 0f70 4863D0   		movslq	%eax, %rdx
 1322 0f73 4889D0   		movq	%rdx, %rax
 1323 0f76 48C1E002 		salq	$2, %rax
 1324 0f7a 4801D0   		addq	%rdx, %rax
 1325 0f7d 48C1E002 		salq	$2, %rax
 1326 0f81 4801E8   		addq	%rbp, %rax
 1327 0f84 488D9054 		leaq	-172(%rax), %rdx
 1327      FFFFFF
 1328 0f8b 8B85F8FE 		movl	-264(%rbp), %eax
 1328      FFFF
 1329 0f91 8902     		movl	%eax, (%rdx)
 291:main.c        **** 			arr[i][2] = i;
 1330              		.loc 1 291 0
 1331 0f93 8B851CFF 		movl	-228(%rbp), %eax
 1331      FFFF
 1332 0f99 4863D0   		movslq	%eax, %rdx
 1333 0f9c 4889D0   		movq	%rdx, %rax
 1334 0f9f 48C1E002 		salq	$2, %rax
 1335 0fa3 4801D0   		addq	%rdx, %rax
 1336 0fa6 48C1E002 		salq	$2, %rax
 1337 0faa 4801E8   		addq	%rbp, %rax
 1338 0fad 488D9058 		leaq	-168(%rax), %rdx
 1338      FFFFFF
 1339 0fb4 8B851CFF 		movl	-228(%rbp), %eax
 1339      FFFF
 1340 0fba 8902     		movl	%eax, (%rdx)
 292:main.c        **** 			arr[i][3] = 0;
 1341              		.loc 1 292 0
 1342 0fbc 8B851CFF 		movl	-228(%rbp), %eax
 1342      FFFF
 1343 0fc2 4863D0   		movslq	%eax, %rdx
 1344 0fc5 4889D0   		movq	%rdx, %rax
 1345 0fc8 48C1E002 		salq	$2, %rax
 1346 0fcc 4801D0   		addq	%rdx, %rax
 1347 0fcf 48C1E002 		salq	$2, %rax
 1348 0fd3 4801E8   		addq	%rbp, %rax
 1349 0fd6 482DA400 		subq	$164, %rax
 1349      0000
 1350 0fdc C7000000 		movl	$0, (%rax)
 1350      0000
 293:main.c        **** 			arr[i][4] = 0;
 1351              		.loc 1 293 0
 1352 0fe2 8B851CFF 		movl	-228(%rbp), %eax
 1352      FFFF
 1353 0fe8 4863D0   		movslq	%eax, %rdx
 1354 0feb 4889D0   		movq	%rdx, %rax
 1355 0fee 48C1E002 		salq	$2, %rax
 1356 0ff2 4801D0   		addq	%rdx, %rax
 1357 0ff5 48C1E002 		salq	$2, %rax
 1358 0ff9 4801E8   		addq	%rbp, %rax
 1359 0ffc 482DA000 		subq	$160, %rax
 1359      0000
 1360 1002 C7000000 		movl	$0, (%rax)
 1360      0000
 294:main.c        **** 			final_arr[i][7] = 0;
 1361              		.loc 1 294 0
 1362 1008 8B851CFF 		movl	-228(%rbp), %eax
 1362      FFFF
 1363 100e 4898     		cltq
 1364 1010 48C1E005 		salq	$5, %rax
 1365 1014 4889C2   		movq	%rax, %rdx
 1366 1017 488B85F0 		movq	-272(%rbp), %rax
 1366      FEFFFF
 1367 101e 4801D0   		addq	%rdx, %rax
 1368 1021 C7401C00 		movl	$0, 28(%rax)
 1368      000000
 1369              	.L66:
 285:main.c        **** 	{
 1370              		.loc 1 285 0 discriminator 2
 1371 1028 83851CFF 		addl	$1, -228(%rbp)
 1371      FFFF01
 1372              	.L65:
 285:main.c        **** 	{
 1373              		.loc 1 285 0 is_stmt 0 discriminator 1
 1374 102f 83BD1CFF 		cmpl	$7, -228(%rbp)
 1374      FFFF07
 1375 1036 0F8E2EFE 		jle	.L67
 1375      FFFF
 1376              	.LBE20:
 1377              	.LBB21:
 295:main.c        **** 		}
 296:main.c        **** 	}
 297:main.c        **** 
 298:main.c        **** 	for (int i = 0; i < 8; i++)
 1378              		.loc 1 298 0 is_stmt 1
 1379 103c C78520FF 		movl	$0, -224(%rbp)
 1379      FFFF0000 
 1379      0000
 1380 1046 E9870200 		jmp	.L68
 1380      00
 1381              	.L71:
 1382              	.LBB22:
 299:main.c        **** 	{
 300:main.c        **** 		int next_signal = arr[i][4];
 1383              		.loc 1 300 0
 1384 104b 8B8520FF 		movl	-224(%rbp), %eax
 1384      FFFF
 1385 1051 4863D0   		movslq	%eax, %rdx
 1386 1054 4889D0   		movq	%rdx, %rax
 1387 1057 48C1E002 		salq	$2, %rax
 1388 105b 4801D0   		addq	%rdx, %rax
 1389 105e 48C1E002 		salq	$2, %rax
 1390 1062 4801E8   		addq	%rbp, %rax
 1391 1065 482DA000 		subq	$160, %rax
 1391      0000
 1392 106b 8B00     		movl	(%rax), %eax
 1393 106d 898524FF 		movl	%eax, -220(%rbp)
 1393      FFFF
 301:main.c        **** 		int track_ok = arr[i][3];
 1394              		.loc 1 301 0
 1395 1073 8B8520FF 		movl	-224(%rbp), %eax
 1395      FFFF
 1396 1079 4863D0   		movslq	%eax, %rdx
 1397 107c 4889D0   		movq	%rdx, %rax
 1398 107f 48C1E002 		salq	$2, %rax
 1399 1083 4801D0   		addq	%rdx, %rax
 1400 1086 48C1E002 		salq	$2, %rax
 1401 108a 4801E8   		addq	%rbp, %rax
 1402 108d 482DA400 		subq	$164, %rax
 1402      0000
 1403 1093 8B00     		movl	(%rax), %eax
 1404 1095 898528FF 		movl	%eax, -216(%rbp)
 1404      FFFF
 302:main.c        **** 		int direction = arr[i][2];
 1405              		.loc 1 302 0
 1406 109b 8B8520FF 		movl	-224(%rbp), %eax
 1406      FFFF
 1407 10a1 4863D0   		movslq	%eax, %rdx
 1408 10a4 4889D0   		movq	%rdx, %rax
 1409 10a7 48C1E002 		salq	$2, %rax
 1410 10ab 4801D0   		addq	%rdx, %rax
 1411 10ae 48C1E002 		salq	$2, %rax
 1412 10b2 4801E8   		addq	%rbp, %rax
 1413 10b5 482DA800 		subq	$168, %rax
 1413      0000
 1414 10bb 8B00     		movl	(%rax), %eax
 1415 10bd 89852CFF 		movl	%eax, -212(%rbp)
 1415      FFFF
 303:main.c        **** 
 304:main.c        **** 		final_arr[i][0] = conversion[next_signal][2] -48;
 1416              		.loc 1 304 0
 1417 10c3 8B8520FF 		movl	-224(%rbp), %eax
 1417      FFFF
 1418 10c9 4898     		cltq
 1419 10cb 48C1E005 		salq	$5, %rax
 1420 10cf 4889C2   		movq	%rax, %rdx
 1421 10d2 488B85F0 		movq	-272(%rbp), %rax
 1421      FEFFFF
 1422 10d9 488D0C02 		leaq	(%rdx,%rax), %rcx
 1423 10dd 8B8524FF 		movl	-220(%rbp), %eax
 1423      FFFF
 1424 10e3 4863D0   		movslq	%eax, %rdx
 1425 10e6 4889D0   		movq	%rdx, %rax
 1426 10e9 4801C0   		addq	%rax, %rax
 1427 10ec 4801D0   		addq	%rdx, %rax
 1428 10ef 4801E8   		addq	%rbp, %rax
 1429 10f2 482DCE00 		subq	$206, %rax
 1429      0000
 1430 10f8 0FB600   		movzbl	(%rax), %eax
 1431 10fb 0FBEC0   		movsbl	%al, %eax
 1432 10fe 83E830   		subl	$48, %eax
 1433 1101 8901     		movl	%eax, (%rcx)
 305:main.c        **** 		final_arr[i][1] = conversion[next_signal][1] -48;
 1434              		.loc 1 305 0
 1435 1103 8B8520FF 		movl	-224(%rbp), %eax
 1435      FFFF
 1436 1109 4898     		cltq
 1437 110b 48C1E005 		salq	$5, %rax
 1438 110f 4889C2   		movq	%rax, %rdx
 1439 1112 488B85F0 		movq	-272(%rbp), %rax
 1439      FEFFFF
 1440 1119 488D0C02 		leaq	(%rdx,%rax), %rcx
 1441 111d 8B8524FF 		movl	-220(%rbp), %eax
 1441      FFFF
 1442 1123 4863D0   		movslq	%eax, %rdx
 1443 1126 4889D0   		movq	%rdx, %rax
 1444 1129 4801C0   		addq	%rax, %rax
 1445 112c 4801D0   		addq	%rdx, %rax
 1446 112f 4801E8   		addq	%rbp, %rax
 1447 1132 482DCF00 		subq	$207, %rax
 1447      0000
 1448 1138 0FB600   		movzbl	(%rax), %eax
 1449 113b 0FBEC0   		movsbl	%al, %eax
 1450 113e 83E830   		subl	$48, %eax
 1451 1141 894104   		movl	%eax, 4(%rcx)
 306:main.c        **** 		final_arr[i][2] = conversion[next_signal][0] -48;
 1452              		.loc 1 306 0
 1453 1144 8B8520FF 		movl	-224(%rbp), %eax
 1453      FFFF
 1454 114a 4898     		cltq
 1455 114c 48C1E005 		salq	$5, %rax
 1456 1150 4889C2   		movq	%rax, %rdx
 1457 1153 488B85F0 		movq	-272(%rbp), %rax
 1457      FEFFFF
 1458 115a 488D0C02 		leaq	(%rdx,%rax), %rcx
 1459 115e 8B8524FF 		movl	-220(%rbp), %eax
 1459      FFFF
 1460 1164 4863D0   		movslq	%eax, %rdx
 1461 1167 4889D0   		movq	%rdx, %rax
 1462 116a 4801C0   		addq	%rax, %rax
 1463 116d 4801D0   		addq	%rdx, %rax
 1464 1170 4801E8   		addq	%rbp, %rax
 1465 1173 482DD000 		subq	$208, %rax
 1465      0000
 1466 1179 0FB600   		movzbl	(%rax), %eax
 1467 117c 0FBEC0   		movsbl	%al, %eax
 1468 117f 83E830   		subl	$48, %eax
 1469 1182 894108   		movl	%eax, 8(%rcx)
 307:main.c        **** 
 308:main.c        **** 		final_arr[i][3] = conversion[direction][2] -48;
 1470              		.loc 1 308 0
 1471 1185 8B8520FF 		movl	-224(%rbp), %eax
 1471      FFFF
 1472 118b 4898     		cltq
 1473 118d 48C1E005 		salq	$5, %rax
 1474 1191 4889C2   		movq	%rax, %rdx
 1475 1194 488B85F0 		movq	-272(%rbp), %rax
 1475      FEFFFF
 1476 119b 488D0C02 		leaq	(%rdx,%rax), %rcx
 1477 119f 8B852CFF 		movl	-212(%rbp), %eax
 1477      FFFF
 1478 11a5 4863D0   		movslq	%eax, %rdx
 1479 11a8 4889D0   		movq	%rdx, %rax
 1480 11ab 4801C0   		addq	%rax, %rax
 1481 11ae 4801D0   		addq	%rdx, %rax
 1482 11b1 4801E8   		addq	%rbp, %rax
 1483 11b4 482DCE00 		subq	$206, %rax
 1483      0000
 1484 11ba 0FB600   		movzbl	(%rax), %eax
 1485 11bd 0FBEC0   		movsbl	%al, %eax
 1486 11c0 83E830   		subl	$48, %eax
 1487 11c3 89410C   		movl	%eax, 12(%rcx)
 309:main.c        **** 		final_arr[i][4] = conversion[direction][1] -48;
 1488              		.loc 1 309 0
 1489 11c6 8B8520FF 		movl	-224(%rbp), %eax
 1489      FFFF
 1490 11cc 4898     		cltq
 1491 11ce 48C1E005 		salq	$5, %rax
 1492 11d2 4889C2   		movq	%rax, %rdx
 1493 11d5 488B85F0 		movq	-272(%rbp), %rax
 1493      FEFFFF
 1494 11dc 488D0C02 		leaq	(%rdx,%rax), %rcx
 1495 11e0 8B852CFF 		movl	-212(%rbp), %eax
 1495      FFFF
 1496 11e6 4863D0   		movslq	%eax, %rdx
 1497 11e9 4889D0   		movq	%rdx, %rax
 1498 11ec 4801C0   		addq	%rax, %rax
 1499 11ef 4801D0   		addq	%rdx, %rax
 1500 11f2 4801E8   		addq	%rbp, %rax
 1501 11f5 482DCF00 		subq	$207, %rax
 1501      0000
 1502 11fb 0FB600   		movzbl	(%rax), %eax
 1503 11fe 0FBEC0   		movsbl	%al, %eax
 1504 1201 83E830   		subl	$48, %eax
 1505 1204 894110   		movl	%eax, 16(%rcx)
 310:main.c        **** 		final_arr[i][5] = conversion[direction][0] -48;
 1506              		.loc 1 310 0
 1507 1207 8B8520FF 		movl	-224(%rbp), %eax
 1507      FFFF
 1508 120d 4898     		cltq
 1509 120f 48C1E005 		salq	$5, %rax
 1510 1213 4889C2   		movq	%rax, %rdx
 1511 1216 488B85F0 		movq	-272(%rbp), %rax
 1511      FEFFFF
 1512 121d 488D0C02 		leaq	(%rdx,%rax), %rcx
 1513 1221 8B852CFF 		movl	-212(%rbp), %eax
 1513      FFFF
 1514 1227 4863D0   		movslq	%eax, %rdx
 1515 122a 4889D0   		movq	%rdx, %rax
 1516 122d 4801C0   		addq	%rax, %rax
 1517 1230 4801D0   		addq	%rdx, %rax
 1518 1233 4801E8   		addq	%rbp, %rax
 1519 1236 482DD000 		subq	$208, %rax
 1519      0000
 1520 123c 0FB600   		movzbl	(%rax), %eax
 1521 123f 0FBEC0   		movsbl	%al, %eax
 1522 1242 83E830   		subl	$48, %eax
 1523 1245 894114   		movl	%eax, 20(%rcx)
 311:main.c        **** 
 312:main.c        **** 		final_arr[i][6] = track_ok;
 1524              		.loc 1 312 0
 1525 1248 8B8520FF 		movl	-224(%rbp), %eax
 1525      FFFF
 1526 124e 4898     		cltq
 1527 1250 48C1E005 		salq	$5, %rax
 1528 1254 4889C2   		movq	%rax, %rdx
 1529 1257 488B85F0 		movq	-272(%rbp), %rax
 1529      FEFFFF
 1530 125e 4801C2   		addq	%rax, %rdx
 1531 1261 8B8528FF 		movl	-216(%rbp), %eax
 1531      FFFF
 1532 1267 894218   		movl	%eax, 24(%rdx)
 313:main.c        **** 
 314:main.c        **** 		if(final_arr[i][7] != 0 || final_arr[i][7] == -1)
 1533              		.loc 1 314 0
 1534 126a 8B8520FF 		movl	-224(%rbp), %eax
 1534      FFFF
 1535 1270 4898     		cltq
 1536 1272 48C1E005 		salq	$5, %rax
 1537 1276 4889C2   		movq	%rax, %rdx
 1538 1279 488B85F0 		movq	-272(%rbp), %rax
 1538      FEFFFF
 1539 1280 4801D0   		addq	%rdx, %rax
 1540 1283 8B401C   		movl	28(%rax), %eax
 1541 1286 85C0     		testl	%eax, %eax
 1542 1288 7521     		jne	.L69
 1543              		.loc 1 314 0 is_stmt 0 discriminator 1
 1544 128a 8B8520FF 		movl	-224(%rbp), %eax
 1544      FFFF
 1545 1290 4898     		cltq
 1546 1292 48C1E005 		salq	$5, %rax
 1547 1296 4889C2   		movq	%rax, %rdx
 1548 1299 488B85F0 		movq	-272(%rbp), %rax
 1548      FEFFFF
 1549 12a0 4801D0   		addq	%rdx, %rax
 1550 12a3 8B401C   		movl	28(%rax), %eax
 1551 12a6 83F8FF   		cmpl	$-1, %eax
 1552 12a9 7520     		jne	.L70
 1553              	.L69:
 315:main.c        **** 		{
 316:main.c        **** 			final_arr[i][7] = 1;
 1554              		.loc 1 316 0 is_stmt 1
 1555 12ab 8B8520FF 		movl	-224(%rbp), %eax
 1555      FFFF
 1556 12b1 4898     		cltq
 1557 12b3 48C1E005 		salq	$5, %rax
 1558 12b7 4889C2   		movq	%rax, %rdx
 1559 12ba 488B85F0 		movq	-272(%rbp), %rax
 1559      FEFFFF
 1560 12c1 4801D0   		addq	%rdx, %rax
 1561 12c4 C7401C01 		movl	$1, 28(%rax)
 1561      000000
 1562              	.L70:
 1563              	.LBE22:
 298:main.c        **** 	{
 1564              		.loc 1 298 0 discriminator 2
 1565 12cb 838520FF 		addl	$1, -224(%rbp)
 1565      FFFF01
 1566              	.L68:
 298:main.c        **** 	{
 1567              		.loc 1 298 0 is_stmt 0 discriminator 1
 1568 12d2 83BD20FF 		cmpl	$7, -224(%rbp)
 1568      FFFF07
 1569 12d9 0F8E6CFD 		jle	.L71
 1569      FFFF
 1570              	.LBE21:
 317:main.c        **** 		}
 318:main.c        **** 	}
 319:main.c        **** 
 320:main.c        **** }
 1571              		.loc 1 320 0 is_stmt 1
 1572 12df 90       		nop
 1573 12e0 488B45F8 		movq	-8(%rbp), %rax
 1574 12e4 64483304 		xorq	%fs:40, %rax
 1574      25280000 
 1574      00
 1575 12ed 7405     		je	.L72
 1576 12ef E8000000 		call	__stack_chk_fail
 1576      00
 1577              	.L72:
 1578 12f4 C9       		leave
 1579              		.cfi_def_cfa 7, 8
 1580 12f5 C3       		ret
 1581              		.cfi_endproc
 1582              	.LFE12:
 1584              		.section	.rodata
 1585              	.LC4:
 1586 0048 75696E74 		.string	"uint8"
 1586      3800
 1587              	.LC5:
 1588 004e 25730A20 		.string	"%s\n "
 1588      00
 1589              		.text
 1590              		.globl	uint8ToBin
 1592              	uint8ToBin:
 1593              	.LFB13:
 321:main.c        **** 
 322:main.c        **** void uint8ToBin(uint8 arr[], int rec[])
 323:main.c        **** {
 1594              		.loc 1 323 0
 1595              		.cfi_startproc
 1596 12f6 55       		pushq	%rbp
 1597              		.cfi_def_cfa_offset 16
 1598              		.cfi_offset 6, -16
 1599 12f7 4889E5   		movq	%rsp, %rbp
 1600              		.cfi_def_cfa_register 6
 1601 12fa 4883EC20 		subq	$32, %rsp
 1602 12fe 48897DE8 		movq	%rdi, -24(%rbp)
 1603 1302 488975E0 		movq	%rsi, -32(%rbp)
 324:main.c        **** 	printf("%s\n ", "uint8");
 1604              		.loc 1 324 0
 1605 1306 BE000000 		movl	$.LC4, %esi
 1605      00
 1606 130b BF000000 		movl	$.LC5, %edi
 1606      00
 1607 1310 B8000000 		movl	$0, %eax
 1607      00
 1608 1315 E8000000 		call	printf
 1608      00
 1609              	.LBB23:
 325:main.c        **** 
 326:main.c        **** 	for (int i = 0; i < 4; ++i)
 1610              		.loc 1 326 0
 1611 131a C745F800 		movl	$0, -8(%rbp)
 1611      000000
 1612 1321 EB5C     		jmp	.L74
 1613              	.L77:
 1614              	.LBB24:
 327:main.c        **** 	{
 328:main.c        **** 		uint8 tempssss= arr[i];
 1615              		.loc 1 328 0
 1616 1323 8B45F8   		movl	-8(%rbp), %eax
 1617 1326 4863D0   		movslq	%eax, %rdx
 1618 1329 488B45E8 		movq	-24(%rbp), %rax
 1619 132d 4801D0   		addq	%rdx, %rax
 1620 1330 0FB600   		movzbl	(%rax), %eax
 1621 1333 8845F7   		movb	%al, -9(%rbp)
 1622              	.LBB25:
 329:main.c        **** 		for(int k=0;k<8;k++)
 1623              		.loc 1 329 0
 1624 1336 C745FC00 		movl	$0, -4(%rbp)
 1624      000000
 1625 133d EB36     		jmp	.L75
 1626              	.L76:
 330:main.c        **** 		{
 331:main.c        **** 			rec[8*i+k] =(int) (tempssss % 2);
 1627              		.loc 1 331 0 discriminator 3
 1628 133f 8B45F8   		movl	-8(%rbp), %eax
 1629 1342 8D14C500 		leal	0(,%rax,8), %edx
 1629      000000
 1630 1349 8B45FC   		movl	-4(%rbp), %eax
 1631 134c 01D0     		addl	%edx, %eax
 1632 134e 4898     		cltq
 1633 1350 488D1485 		leaq	0(,%rax,4), %rdx
 1633      00000000 
 1634 1358 488B45E0 		movq	-32(%rbp), %rax
 1635 135c 4801D0   		addq	%rdx, %rax
 1636 135f 0FB655F7 		movzbl	-9(%rbp), %edx
 1637 1363 83E201   		andl	$1, %edx
 1638 1366 8910     		movl	%edx, (%rax)
 332:main.c        **** 			tempssss = tempssss/2;
 1639              		.loc 1 332 0 discriminator 3
 1640 1368 0FB645F7 		movzbl	-9(%rbp), %eax
 1641 136c D0E8     		shrb	%al
 1642 136e 8845F7   		movb	%al, -9(%rbp)
 329:main.c        **** 		for(int k=0;k<8;k++)
 1643              		.loc 1 329 0 discriminator 3
 1644 1371 8345FC01 		addl	$1, -4(%rbp)
 1645              	.L75:
 329:main.c        **** 		for(int k=0;k<8;k++)
 1646              		.loc 1 329 0 is_stmt 0 discriminator 1
 1647 1375 837DFC07 		cmpl	$7, -4(%rbp)
 1648 1379 7EC4     		jle	.L76
 1649              	.LBE25:
 1650              	.LBE24:
 326:main.c        **** 	{
 1651              		.loc 1 326 0 is_stmt 1 discriminator 2
 1652 137b 8345F801 		addl	$1, -8(%rbp)
 1653              	.L74:
 326:main.c        **** 	{
 1654              		.loc 1 326 0 is_stmt 0 discriminator 1
 1655 137f 837DF803 		cmpl	$3, -8(%rbp)
 1656 1383 7E9E     		jle	.L77
 1657              	.LBE23:
 333:main.c        **** 		}
 334:main.c        **** 	}
 335:main.c        **** }
 1658              		.loc 1 335 0 is_stmt 1
 1659 1385 90       		nop
 1660 1386 C9       		leave
 1661              		.cfi_def_cfa 7, 8
 1662 1387 C3       		ret
 1663              		.cfi_endproc
 1664              	.LFE13:
 1666              		.section	.rodata
 1667              	.LC6:
 1668 0053 7200     		.string	"r"
 1669 0055 000000   		.align 8
 1670              	.LC7:
 1671 0058 2F686F6D 		.string	"/home/shubham/Desktop/track_data.csv"
 1671      652F7368 
 1671      75626861 
 1671      6D2F4465 
 1671      736B746F 
 1672              	.LC8:
 1673 007d 25642C25 		.string	"%d,%d,%d,%d,%d"
 1673      642C2564 
 1673      2C25642C 
 1673      256400
 1674              	.LC9:
 1675 008c 45786973 		.string	"Existing track_data"
 1675      74696E67 
 1675      20747261 
 1675      636B5F64 
 1675      61746100 
 1676              	.LC10:
 1677 00a0 25642000 		.string	"%d "
 1678              	.LC11:
 1679 00a4 7700     		.string	"w"
 1680              	.LC12:
 1681 00a6 25642C25 		.string	"%d,%d,%d,%d,%d\n"
 1681      642C2564 
 1681      2C25642C 
 1681      25640A00 
 1682              	.LC13:
 1683 00b6 55706461 		.string	"Updated track_data"
 1683      74656420 
 1683      74726163 
 1683      6B5F6461 
 1683      746100
 1684              		.text
 1685              		.globl	writecsv
 1687              	writecsv:
 1688              	.LFB14:
 336:main.c        **** 
 337:main.c        **** void writecsv(int x_cord, int y_cord, int ok, int direction, int next)
 338:main.c        **** {
 1689              		.loc 1 338 0
 1690              		.cfi_startproc
 1691 1388 55       		pushq	%rbp
 1692              		.cfi_def_cfa_offset 16
 1693              		.cfi_offset 6, -16
 1694 1389 4889E5   		movq	%rsp, %rbp
 1695              		.cfi_def_cfa_register 6
 1696 138c 4881EC50 		subq	$2128, %rsp
 1696      080000
 1697 1393 89BDCCF7 		movl	%edi, -2100(%rbp)
 1697      FFFF
 1698 1399 89B5C8F7 		movl	%esi, -2104(%rbp)
 1698      FFFF
 1699 139f 8995C4F7 		movl	%edx, -2108(%rbp)
 1699      FFFF
 1700 13a5 898DC0F7 		movl	%ecx, -2112(%rbp)
 1700      FFFF
 1701 13ab 448985BC 		movl	%r8d, -2116(%rbp)
 1701      F7FFFF
 1702              		.loc 1 338 0
 1703 13b2 64488B04 		movq	%fs:40, %rax
 1703      25280000 
 1703      00
 1704 13bb 488945F8 		movq	%rax, -8(%rbp)
 1705 13bf 31C0     		xorl	%eax, %eax
 339:main.c        **** 	FILE *fp1 = fopen("/home/shubham/Desktop/track_data.csv", "r");
 1706              		.loc 1 339 0
 1707 13c1 BE000000 		movl	$.LC6, %esi
 1707      00
 1708 13c6 BF000000 		movl	$.LC7, %edi
 1708      00
 1709 13cb E8000000 		call	fopen
 1709      00
 1710 13d0 48898510 		movq	%rax, -2032(%rbp)
 1710      F8FFFF
 340:main.c        **** 	int mat[100][5];
 341:main.c        **** 	//int temp;
 342:main.c        **** 	int i =0;
 1711              		.loc 1 342 0
 1712 13d7 C785ECF7 		movl	$0, -2068(%rbp)
 1712      FFFF0000 
 1712      0000
 343:main.c        **** 	int a,b,c,d,e;
 344:main.c        **** 	while (fscanf(fp1, "%d,%d,%d,%d,%d", &a, &b,&c,&d,&e) == 5)
 1713              		.loc 1 344 0
 1714 13e1 E9CF0000 		jmp	.L79
 1714      00
 1715              	.L80:
 345:main.c        **** 	{
 346:main.c        **** 
 347:main.c        **** 		mat[i][4] = a;
 1716              		.loc 1 347 0
 1717 13e6 8B8DD8F7 		movl	-2088(%rbp), %ecx
 1717      FFFF
 1718 13ec 8B85ECF7 		movl	-2068(%rbp), %eax
 1718      FFFF
 1719 13f2 4863D0   		movslq	%eax, %rdx
 1720 13f5 4889D0   		movq	%rdx, %rax
 1721 13f8 48C1E002 		salq	$2, %rax
 1722 13fc 4801D0   		addq	%rdx, %rax
 1723 13ff 48C1E002 		salq	$2, %rax
 1724 1403 4801E8   		addq	%rbp, %rax
 1725 1406 482DD007 		subq	$2000, %rax
 1725      0000
 1726 140c 8908     		movl	%ecx, (%rax)
 348:main.c        **** 		mat[i][3] = b;
 1727              		.loc 1 348 0
 1728 140e 8B8DDCF7 		movl	-2084(%rbp), %ecx
 1728      FFFF
 1729 1414 8B85ECF7 		movl	-2068(%rbp), %eax
 1729      FFFF
 1730 141a 4863D0   		movslq	%eax, %rdx
 1731 141d 4889D0   		movq	%rdx, %rax
 1732 1420 48C1E002 		salq	$2, %rax
 1733 1424 4801D0   		addq	%rdx, %rax
 1734 1427 48C1E002 		salq	$2, %rax
 1735 142b 4801E8   		addq	%rbp, %rax
 1736 142e 482DD407 		subq	$2004, %rax
 1736      0000
 1737 1434 8908     		movl	%ecx, (%rax)
 349:main.c        **** 		mat[i][2] = c;
 1738              		.loc 1 349 0
 1739 1436 8B8DE0F7 		movl	-2080(%rbp), %ecx
 1739      FFFF
 1740 143c 8B85ECF7 		movl	-2068(%rbp), %eax
 1740      FFFF
 1741 1442 4863D0   		movslq	%eax, %rdx
 1742 1445 4889D0   		movq	%rdx, %rax
 1743 1448 48C1E002 		salq	$2, %rax
 1744 144c 4801D0   		addq	%rdx, %rax
 1745 144f 48C1E002 		salq	$2, %rax
 1746 1453 4801E8   		addq	%rbp, %rax
 1747 1456 482DD807 		subq	$2008, %rax
 1747      0000
 1748 145c 8908     		movl	%ecx, (%rax)
 350:main.c        **** 		mat[i][1] = d;
 1749              		.loc 1 350 0
 1750 145e 8B8DE4F7 		movl	-2076(%rbp), %ecx
 1750      FFFF
 1751 1464 8B85ECF7 		movl	-2068(%rbp), %eax
 1751      FFFF
 1752 146a 4863D0   		movslq	%eax, %rdx
 1753 146d 4889D0   		movq	%rdx, %rax
 1754 1470 48C1E002 		salq	$2, %rax
 1755 1474 4801D0   		addq	%rdx, %rax
 1756 1477 48C1E002 		salq	$2, %rax
 1757 147b 4801E8   		addq	%rbp, %rax
 1758 147e 482DDC07 		subq	$2012, %rax
 1758      0000
 1759 1484 8908     		movl	%ecx, (%rax)
 351:main.c        **** 		mat[i][0] = e;
 1760              		.loc 1 351 0
 1761 1486 8B8DE8F7 		movl	-2072(%rbp), %ecx
 1761      FFFF
 1762 148c 8B85ECF7 		movl	-2068(%rbp), %eax
 1762      FFFF
 1763 1492 4863D0   		movslq	%eax, %rdx
 1764 1495 4889D0   		movq	%rdx, %rax
 1765 1498 48C1E002 		salq	$2, %rax
 1766 149c 4801D0   		addq	%rdx, %rax
 1767 149f 48C1E002 		salq	$2, %rax
 1768 14a3 4801E8   		addq	%rbp, %rax
 1769 14a6 482DE007 		subq	$2016, %rax
 1769      0000
 1770 14ac 8908     		movl	%ecx, (%rax)
 352:main.c        **** 		i++; 
 1771              		.loc 1 352 0
 1772 14ae 8385ECF7 		addl	$1, -2068(%rbp)
 1772      FFFF01
 1773              	.L79:
 344:main.c        **** 	{
 1774              		.loc 1 344 0
 1775 14b5 4C8D85E4 		leaq	-2076(%rbp), %r8
 1775      F7FFFF
 1776 14bc 488DBDE0 		leaq	-2080(%rbp), %rdi
 1776      F7FFFF
 1777 14c3 488D8DDC 		leaq	-2084(%rbp), %rcx
 1777      F7FFFF
 1778 14ca 488D95D8 		leaq	-2088(%rbp), %rdx
 1778      F7FFFF
 1779 14d1 488B8510 		movq	-2032(%rbp), %rax
 1779      F8FFFF
 1780 14d8 4883EC08 		subq	$8, %rsp
 1781 14dc 488DB5E8 		leaq	-2072(%rbp), %rsi
 1781      F7FFFF
 1782 14e3 56       		pushq	%rsi
 1783 14e4 4D89C1   		movq	%r8, %r9
 1784 14e7 4989F8   		movq	%rdi, %r8
 1785 14ea BE000000 		movl	$.LC8, %esi
 1785      00
 1786 14ef 4889C7   		movq	%rax, %rdi
 1787 14f2 B8000000 		movl	$0, %eax
 1787      00
 1788 14f7 E8000000 		call	__isoc99_fscanf
 1788      00
 1789 14fc 4883C410 		addq	$16, %rsp
 1790 1500 83F805   		cmpl	$5, %eax
 1791 1503 0F84DDFE 		je	.L80
 1791      FFFF
 353:main.c        **** 	}
 354:main.c        **** 
 355:main.c        **** 	int len = i;
 1792              		.loc 1 355 0
 1793 1509 8B85ECF7 		movl	-2068(%rbp), %eax
 1793      FFFF
 1794 150f 8985F0F7 		movl	%eax, -2064(%rbp)
 1794      FFFF
 356:main.c        **** 
 357:main.c        **** 	printf("%s\n", "Existing track_data");
 1795              		.loc 1 357 0
 1796 1515 BF000000 		movl	$.LC9, %edi
 1796      00
 1797 151a E8000000 		call	puts
 1797      00
 1798              	.LBB26:
 358:main.c        **** 	for(int i=0;i<len;i++)
 1799              		.loc 1 358 0
 1800 151f C785F4F7 		movl	$0, -2060(%rbp)
 1800      FFFF0000 
 1800      0000
 1801 1529 EB69     		jmp	.L81
 1802              	.L84:
 1803              	.LBB27:
 359:main.c        **** 	{
 360:main.c        **** 		for(int j=0;j<5;j++)
 1804              		.loc 1 360 0
 1805 152b C785F8F7 		movl	$0, -2056(%rbp)
 1805      FFFF0000 
 1805      0000
 1806 1535 EB43     		jmp	.L82
 1807              	.L83:
 361:main.c        **** 		{
 362:main.c        **** 			printf("%d ", mat[i][4-j]);
 1808              		.loc 1 362 0 discriminator 3
 1809 1537 B8040000 		movl	$4, %eax
 1809      00
 1810 153c 2B85F8F7 		subl	-2056(%rbp), %eax
 1810      FFFF
 1811 1542 4863C8   		movslq	%eax, %rcx
 1812 1545 8B85F4F7 		movl	-2060(%rbp), %eax
 1812      FFFF
 1813 154b 4863D0   		movslq	%eax, %rdx
 1814 154e 4889D0   		movq	%rdx, %rax
 1815 1551 48C1E002 		salq	$2, %rax
 1816 1555 4801D0   		addq	%rdx, %rax
 1817 1558 4801C8   		addq	%rcx, %rax
 1818 155b 8B848520 		movl	-2016(%rbp,%rax,4), %eax
 1818      F8FFFF
 1819 1562 89C6     		movl	%eax, %esi
 1820 1564 BF000000 		movl	$.LC10, %edi
 1820      00
 1821 1569 B8000000 		movl	$0, %eax
 1821      00
 1822 156e E8000000 		call	printf
 1822      00
 360:main.c        **** 		{
 1823              		.loc 1 360 0 discriminator 3
 1824 1573 8385F8F7 		addl	$1, -2056(%rbp)
 1824      FFFF01
 1825              	.L82:
 360:main.c        **** 		{
 1826              		.loc 1 360 0 is_stmt 0 discriminator 1
 1827 157a 83BDF8F7 		cmpl	$4, -2056(%rbp)
 1827      FFFF04
 1828 1581 7EB4     		jle	.L83
 1829              	.LBE27:
 363:main.c        **** 		}
 364:main.c        **** 		printf("\n");
 1830              		.loc 1 364 0 is_stmt 1 discriminator 2
 1831 1583 BF0A0000 		movl	$10, %edi
 1831      00
 1832 1588 E8000000 		call	putchar
 1832      00
 358:main.c        **** 	{
 1833              		.loc 1 358 0 discriminator 2
 1834 158d 8385F4F7 		addl	$1, -2060(%rbp)
 1834      FFFF01
 1835              	.L81:
 358:main.c        **** 	{
 1836              		.loc 1 358 0 is_stmt 0 discriminator 1
 1837 1594 8B85F4F7 		movl	-2060(%rbp), %eax
 1837      FFFF
 1838 159a 3B85F0F7 		cmpl	-2064(%rbp), %eax
 1838      FFFF
 1839 15a0 7C89     		jl	.L84
 1840              	.LBE26:
 365:main.c        **** 	}
 366:main.c        **** 
 367:main.c        **** 	printf("\n");
 1841              		.loc 1 367 0 is_stmt 1
 1842 15a2 BF0A0000 		movl	$10, %edi
 1842      00
 1843 15a7 E8000000 		call	putchar
 1843      00
 368:main.c        **** 	FILE *fp2 = fopen("/home/shubham/Desktop/track_data.csv", "w");
 1844              		.loc 1 368 0
 1845 15ac BE000000 		movl	$.LC11, %esi
 1845      00
 1846 15b1 BF000000 		movl	$.LC7, %edi
 1846      00
 1847 15b6 E8000000 		call	fopen
 1847      00
 1848 15bb 48898518 		movq	%rax, -2024(%rbp)
 1848      F8FFFF
 369:main.c        **** 	
 370:main.c        **** 	int counter = 0;
 1849              		.loc 1 370 0
 1850 15c2 C785FCF7 		movl	$0, -2052(%rbp)
 1850      FFFF0000 
 1850      0000
 1851              	.LBB28:
 371:main.c        **** 	for (int i = 0; i < len; ++i)
 1852              		.loc 1 371 0
 1853 15cc C78500F8 		movl	$0, -2048(%rbp)
 1853      FFFF0000 
 1853      0000
 1854 15d6 E9E60000 		jmp	.L85
 1854      00
 1855              	.L87:
 372:main.c        **** 	{
 373:main.c        **** 		if(mat[i][4] == x_cord && mat[i][3] == y_cord && mat[i][2] == direction)
 1856              		.loc 1 373 0
 1857 15db 8B8500F8 		movl	-2048(%rbp), %eax
 1857      FFFF
 1858 15e1 4863D0   		movslq	%eax, %rdx
 1859 15e4 4889D0   		movq	%rdx, %rax
 1860 15e7 48C1E002 		salq	$2, %rax
 1861 15eb 4801D0   		addq	%rdx, %rax
 1862 15ee 48C1E002 		salq	$2, %rax
 1863 15f2 4801E8   		addq	%rbp, %rax
 1864 15f5 482DD007 		subq	$2000, %rax
 1864      0000
 1865 15fb 8B00     		movl	(%rax), %eax
 1866 15fd 3B85CCF7 		cmpl	-2100(%rbp), %eax
 1866      FFFF
 1867 1603 0F85B100 		jne	.L86
 1867      0000
 1868              		.loc 1 373 0 is_stmt 0 discriminator 1
 1869 1609 8B8500F8 		movl	-2048(%rbp), %eax
 1869      FFFF
 1870 160f 4863D0   		movslq	%eax, %rdx
 1871 1612 4889D0   		movq	%rdx, %rax
 1872 1615 48C1E002 		salq	$2, %rax
 1873 1619 4801D0   		addq	%rdx, %rax
 1874 161c 48C1E002 		salq	$2, %rax
 1875 1620 4801E8   		addq	%rbp, %rax
 1876 1623 482DD407 		subq	$2004, %rax
 1876      0000
 1877 1629 8B00     		movl	(%rax), %eax
 1878 162b 3B85C8F7 		cmpl	-2104(%rbp), %eax
 1878      FFFF
 1879 1631 0F858300 		jne	.L86
 1879      0000
 1880              		.loc 1 373 0 discriminator 2
 1881 1637 8B8500F8 		movl	-2048(%rbp), %eax
 1881      FFFF
 1882 163d 4863D0   		movslq	%eax, %rdx
 1883 1640 4889D0   		movq	%rdx, %rax
 1884 1643 48C1E002 		salq	$2, %rax
 1885 1647 4801D0   		addq	%rdx, %rax
 1886 164a 48C1E002 		salq	$2, %rax
 1887 164e 4801E8   		addq	%rbp, %rax
 1888 1651 482DD807 		subq	$2008, %rax
 1888      0000
 1889 1657 8B00     		movl	(%rax), %eax
 1890 1659 3B85C0F7 		cmpl	-2112(%rbp), %eax
 1890      FFFF
 1891 165f 7559     		jne	.L86
 374:main.c        **** 		{
 375:main.c        **** 			mat[i][1] = ok;
 1892              		.loc 1 375 0 is_stmt 1
 1893 1661 8B8500F8 		movl	-2048(%rbp), %eax
 1893      FFFF
 1894 1667 4863D0   		movslq	%eax, %rdx
 1895 166a 4889D0   		movq	%rdx, %rax
 1896 166d 48C1E002 		salq	$2, %rax
 1897 1671 4801D0   		addq	%rdx, %rax
 1898 1674 48C1E002 		salq	$2, %rax
 1899 1678 4801E8   		addq	%rbp, %rax
 1900 167b 488D9024 		leaq	-2012(%rax), %rdx
 1900      F8FFFF
 1901 1682 8B85C4F7 		movl	-2108(%rbp), %eax
 1901      FFFF
 1902 1688 8902     		movl	%eax, (%rdx)
 376:main.c        **** 			mat[i][0] = next;
 1903              		.loc 1 376 0
 1904 168a 8B8500F8 		movl	-2048(%rbp), %eax
 1904      FFFF
 1905 1690 4863D0   		movslq	%eax, %rdx
 1906 1693 4889D0   		movq	%rdx, %rax
 1907 1696 48C1E002 		salq	$2, %rax
 1908 169a 4801D0   		addq	%rdx, %rax
 1909 169d 48C1E002 		salq	$2, %rax
 1910 16a1 4801E8   		addq	%rbp, %rax
 1911 16a4 488D9020 		leaq	-2016(%rax), %rdx
 1911      F8FFFF
 1912 16ab 8B85BCF7 		movl	-2116(%rbp), %eax
 1912      FFFF
 1913 16b1 8902     		movl	%eax, (%rdx)
 377:main.c        **** 			counter++;
 1914              		.loc 1 377 0
 1915 16b3 8385FCF7 		addl	$1, -2052(%rbp)
 1915      FFFF01
 1916              	.L86:
 371:main.c        **** 	{
 1917              		.loc 1 371 0 discriminator 2
 1918 16ba 838500F8 		addl	$1, -2048(%rbp)
 1918      FFFF01
 1919              	.L85:
 371:main.c        **** 	{
 1920              		.loc 1 371 0 is_stmt 0 discriminator 1
 1921 16c1 8B8500F8 		movl	-2048(%rbp), %eax
 1921      FFFF
 1922 16c7 3B85F0F7 		cmpl	-2064(%rbp), %eax
 1922      FFFF
 1923 16cd 0F8C08FF 		jl	.L87
 1923      FFFF
 1924              	.LBE28:
 378:main.c        **** 		}
 379:main.c        **** 	}
 380:main.c        **** 
 381:main.c        **** 	if(counter == 0)
 1925              		.loc 1 381 0 is_stmt 1
 1926 16d3 83BDFCF7 		cmpl	$0, -2052(%rbp)
 1926      FFFF00
 1927 16da 0F85D400 		jne	.L88
 1927      0000
 382:main.c        **** 	{
 383:main.c        **** 		mat[len][4] = x_cord;
 1928              		.loc 1 383 0
 1929 16e0 8B85F0F7 		movl	-2064(%rbp), %eax
 1929      FFFF
 1930 16e6 4863D0   		movslq	%eax, %rdx
 1931 16e9 4889D0   		movq	%rdx, %rax
 1932 16ec 48C1E002 		salq	$2, %rax
 1933 16f0 4801D0   		addq	%rdx, %rax
 1934 16f3 48C1E002 		salq	$2, %rax
 1935 16f7 4801E8   		addq	%rbp, %rax
 1936 16fa 488D9030 		leaq	-2000(%rax), %rdx
 1936      F8FFFF
 1937 1701 8B85CCF7 		movl	-2100(%rbp), %eax
 1937      FFFF
 1938 1707 8902     		movl	%eax, (%rdx)
 384:main.c        **** 		mat[len][3] = y_cord;
 1939              		.loc 1 384 0
 1940 1709 8B85F0F7 		movl	-2064(%rbp), %eax
 1940      FFFF
 1941 170f 4863D0   		movslq	%eax, %rdx
 1942 1712 4889D0   		movq	%rdx, %rax
 1943 1715 48C1E002 		salq	$2, %rax
 1944 1719 4801D0   		addq	%rdx, %rax
 1945 171c 48C1E002 		salq	$2, %rax
 1946 1720 4801E8   		addq	%rbp, %rax
 1947 1723 488D902C 		leaq	-2004(%rax), %rdx
 1947      F8FFFF
 1948 172a 8B85C8F7 		movl	-2104(%rbp), %eax
 1948      FFFF
 1949 1730 8902     		movl	%eax, (%rdx)
 385:main.c        **** 		mat[len][2] = direction;
 1950              		.loc 1 385 0
 1951 1732 8B85F0F7 		movl	-2064(%rbp), %eax
 1951      FFFF
 1952 1738 4863D0   		movslq	%eax, %rdx
 1953 173b 4889D0   		movq	%rdx, %rax
 1954 173e 48C1E002 		salq	$2, %rax
 1955 1742 4801D0   		addq	%rdx, %rax
 1956 1745 48C1E002 		salq	$2, %rax
 1957 1749 4801E8   		addq	%rbp, %rax
 1958 174c 488D9028 		leaq	-2008(%rax), %rdx
 1958      F8FFFF
 1959 1753 8B85C0F7 		movl	-2112(%rbp), %eax
 1959      FFFF
 1960 1759 8902     		movl	%eax, (%rdx)
 386:main.c        **** 		mat[len][1] = ok;
 1961              		.loc 1 386 0
 1962 175b 8B85F0F7 		movl	-2064(%rbp), %eax
 1962      FFFF
 1963 1761 4863D0   		movslq	%eax, %rdx
 1964 1764 4889D0   		movq	%rdx, %rax
 1965 1767 48C1E002 		salq	$2, %rax
 1966 176b 4801D0   		addq	%rdx, %rax
 1967 176e 48C1E002 		salq	$2, %rax
 1968 1772 4801E8   		addq	%rbp, %rax
 1969 1775 488D9024 		leaq	-2012(%rax), %rdx
 1969      F8FFFF
 1970 177c 8B85C4F7 		movl	-2108(%rbp), %eax
 1970      FFFF
 1971 1782 8902     		movl	%eax, (%rdx)
 387:main.c        **** 		mat[len][0] = next;
 1972              		.loc 1 387 0
 1973 1784 8B85F0F7 		movl	-2064(%rbp), %eax
 1973      FFFF
 1974 178a 4863D0   		movslq	%eax, %rdx
 1975 178d 4889D0   		movq	%rdx, %rax
 1976 1790 48C1E002 		salq	$2, %rax
 1977 1794 4801D0   		addq	%rdx, %rax
 1978 1797 48C1E002 		salq	$2, %rax
 1979 179b 4801E8   		addq	%rbp, %rax
 1980 179e 488D9020 		leaq	-2016(%rax), %rdx
 1980      F8FFFF
 1981 17a5 8B85BCF7 		movl	-2116(%rbp), %eax
 1981      FFFF
 1982 17ab 8902     		movl	%eax, (%rdx)
 388:main.c        **** 		len++;
 1983              		.loc 1 388 0
 1984 17ad 8385F0F7 		addl	$1, -2064(%rbp)
 1984      FFFF01
 1985              	.L88:
 1986              	.LBB29:
 389:main.c        **** 	}
 390:main.c        **** 
 391:main.c        **** 	for (int i = 0; i < len; ++i)
 1987              		.loc 1 391 0
 1988 17b4 C78504F8 		movl	$0, -2044(%rbp)
 1988      FFFF0000 
 1988      0000
 1989 17be E9DA0000 		jmp	.L89
 1989      00
 1990              	.L90:
 392:main.c        **** 	{
 393:main.c        **** 		fprintf(fp2, "%d,%d,%d,%d,%d\n", mat[i][4], mat[i][3], mat[i][2], mat[i][1], mat[i][0]);
 1991              		.loc 1 393 0 discriminator 3
 1992 17c3 8B8504F8 		movl	-2044(%rbp), %eax
 1992      FFFF
 1993 17c9 4863D0   		movslq	%eax, %rdx
 1994 17cc 4889D0   		movq	%rdx, %rax
 1995 17cf 48C1E002 		salq	$2, %rax
 1996 17d3 4801D0   		addq	%rdx, %rax
 1997 17d6 48C1E002 		salq	$2, %rax
 1998 17da 4801E8   		addq	%rbp, %rax
 1999 17dd 482DE007 		subq	$2016, %rax
 1999      0000
 2000 17e3 8B30     		movl	(%rax), %esi
 2001 17e5 8B8504F8 		movl	-2044(%rbp), %eax
 2001      FFFF
 2002 17eb 4863D0   		movslq	%eax, %rdx
 2003 17ee 4889D0   		movq	%rdx, %rax
 2004 17f1 48C1E002 		salq	$2, %rax
 2005 17f5 4801D0   		addq	%rdx, %rax
 2006 17f8 48C1E002 		salq	$2, %rax
 2007 17fc 4801E8   		addq	%rbp, %rax
 2008 17ff 482DDC07 		subq	$2012, %rax
 2008      0000
 2009 1805 448B00   		movl	(%rax), %r8d
 2010 1808 8B8504F8 		movl	-2044(%rbp), %eax
 2010      FFFF
 2011 180e 4863D0   		movslq	%eax, %rdx
 2012 1811 4889D0   		movq	%rdx, %rax
 2013 1814 48C1E002 		salq	$2, %rax
 2014 1818 4801D0   		addq	%rdx, %rax
 2015 181b 48C1E002 		salq	$2, %rax
 2016 181f 4801E8   		addq	%rbp, %rax
 2017 1822 482DD807 		subq	$2008, %rax
 2017      0000
 2018 1828 8B38     		movl	(%rax), %edi
 2019 182a 8B8504F8 		movl	-2044(%rbp), %eax
 2019      FFFF
 2020 1830 4863D0   		movslq	%eax, %rdx
 2021 1833 4889D0   		movq	%rdx, %rax
 2022 1836 48C1E002 		salq	$2, %rax
 2023 183a 4801D0   		addq	%rdx, %rax
 2024 183d 48C1E002 		salq	$2, %rax
 2025 1841 4801E8   		addq	%rbp, %rax
 2026 1844 482DD407 		subq	$2004, %rax
 2026      0000
 2027 184a 8B08     		movl	(%rax), %ecx
 2028 184c 8B8504F8 		movl	-2044(%rbp), %eax
 2028      FFFF
 2029 1852 4863D0   		movslq	%eax, %rdx
 2030 1855 4889D0   		movq	%rdx, %rax
 2031 1858 48C1E002 		salq	$2, %rax
 2032 185c 4801D0   		addq	%rdx, %rax
 2033 185f 48C1E002 		salq	$2, %rax
 2034 1863 4801E8   		addq	%rbp, %rax
 2035 1866 482DD007 		subq	$2000, %rax
 2035      0000
 2036 186c 8B10     		movl	(%rax), %edx
 2037 186e 488B8518 		movq	-2024(%rbp), %rax
 2037      F8FFFF
 2038 1875 4883EC08 		subq	$8, %rsp
 2039 1879 56       		pushq	%rsi
 2040 187a 4589C1   		movl	%r8d, %r9d
 2041 187d 4189F8   		movl	%edi, %r8d
 2042 1880 BE000000 		movl	$.LC12, %esi
 2042      00
 2043 1885 4889C7   		movq	%rax, %rdi
 2044 1888 B8000000 		movl	$0, %eax
 2044      00
 2045 188d E8000000 		call	fprintf
 2045      00
 2046 1892 4883C410 		addq	$16, %rsp
 391:main.c        **** 	{
 2047              		.loc 1 391 0 discriminator 3
 2048 1896 838504F8 		addl	$1, -2044(%rbp)
 2048      FFFF01
 2049              	.L89:
 391:main.c        **** 	{
 2050              		.loc 1 391 0 is_stmt 0 discriminator 1
 2051 189d 8B8504F8 		movl	-2044(%rbp), %eax
 2051      FFFF
 2052 18a3 3B85F0F7 		cmpl	-2064(%rbp), %eax
 2052      FFFF
 2053 18a9 0F8C14FF 		jl	.L90
 2053      FFFF
 2054              	.LBE29:
 394:main.c        **** 	}
 395:main.c        **** 
 396:main.c        **** 	printf("%s\n", "Updated track_data");
 2055              		.loc 1 396 0 is_stmt 1
 2056 18af BF000000 		movl	$.LC13, %edi
 2056      00
 2057 18b4 E8000000 		call	puts
 2057      00
 2058              	.LBB30:
 397:main.c        **** 	for(int i=0;i<len;i++)
 2059              		.loc 1 397 0
 2060 18b9 C78508F8 		movl	$0, -2040(%rbp)
 2060      FFFF0000 
 2060      0000
 2061 18c3 EB69     		jmp	.L91
 2062              	.L94:
 2063              	.LBB31:
 398:main.c        **** 	{
 399:main.c        **** 		for(int j=0;j<5;j++)
 2064              		.loc 1 399 0
 2065 18c5 C7850CF8 		movl	$0, -2036(%rbp)
 2065      FFFF0000 
 2065      0000
 2066 18cf EB43     		jmp	.L92
 2067              	.L93:
 400:main.c        **** 		{
 401:main.c        **** 			printf("%d ", mat[i][4-j]);
 2068              		.loc 1 401 0 discriminator 3
 2069 18d1 B8040000 		movl	$4, %eax
 2069      00
 2070 18d6 2B850CF8 		subl	-2036(%rbp), %eax
 2070      FFFF
 2071 18dc 4863C8   		movslq	%eax, %rcx
 2072 18df 8B8508F8 		movl	-2040(%rbp), %eax
 2072      FFFF
 2073 18e5 4863D0   		movslq	%eax, %rdx
 2074 18e8 4889D0   		movq	%rdx, %rax
 2075 18eb 48C1E002 		salq	$2, %rax
 2076 18ef 4801D0   		addq	%rdx, %rax
 2077 18f2 4801C8   		addq	%rcx, %rax
 2078 18f5 8B848520 		movl	-2016(%rbp,%rax,4), %eax
 2078      F8FFFF
 2079 18fc 89C6     		movl	%eax, %esi
 2080 18fe BF000000 		movl	$.LC10, %edi
 2080      00
 2081 1903 B8000000 		movl	$0, %eax
 2081      00
 2082 1908 E8000000 		call	printf
 2082      00
 399:main.c        **** 		{
 2083              		.loc 1 399 0 discriminator 3
 2084 190d 83850CF8 		addl	$1, -2036(%rbp)
 2084      FFFF01
 2085              	.L92:
 399:main.c        **** 		{
 2086              		.loc 1 399 0 is_stmt 0 discriminator 1
 2087 1914 83BD0CF8 		cmpl	$4, -2036(%rbp)
 2087      FFFF04
 2088 191b 7EB4     		jle	.L93
 2089              	.LBE31:
 402:main.c        **** 		}
 403:main.c        **** 		printf("\n");
 2090              		.loc 1 403 0 is_stmt 1 discriminator 2
 2091 191d BF0A0000 		movl	$10, %edi
 2091      00
 2092 1922 E8000000 		call	putchar
 2092      00
 397:main.c        **** 	{
 2093              		.loc 1 397 0 discriminator 2
 2094 1927 838508F8 		addl	$1, -2040(%rbp)
 2094      FFFF01
 2095              	.L91:
 397:main.c        **** 	{
 2096              		.loc 1 397 0 is_stmt 0 discriminator 1
 2097 192e 8B8508F8 		movl	-2040(%rbp), %eax
 2097      FFFF
 2098 1934 3B85F0F7 		cmpl	-2064(%rbp), %eax
 2098      FFFF
 2099 193a 7C89     		jl	.L94
 2100              	.LBE30:
 404:main.c        **** 	}
 405:main.c        **** 	fclose(fp1);
 2101              		.loc 1 405 0 is_stmt 1
 2102 193c 488B8510 		movq	-2032(%rbp), %rax
 2102      F8FFFF
 2103 1943 4889C7   		movq	%rax, %rdi
 2104 1946 E8000000 		call	fclose
 2104      00
 406:main.c        **** 	fclose(fp2);
 2105              		.loc 1 406 0
 2106 194b 488B8518 		movq	-2024(%rbp), %rax
 2106      F8FFFF
 2107 1952 4889C7   		movq	%rax, %rdi
 2108 1955 E8000000 		call	fclose
 2108      00
 407:main.c        **** }
 2109              		.loc 1 407 0
 2110 195a 90       		nop
 2111 195b 488B45F8 		movq	-8(%rbp), %rax
 2112 195f 64483304 		xorq	%fs:40, %rax
 2112      25280000 
 2112      00
 2113 1968 7405     		je	.L95
 2114 196a E8000000 		call	__stack_chk_fail
 2114      00
 2115              	.L95:
 2116 196f C9       		leave
 2117              		.cfi_def_cfa 7, 8
 2118 1970 C3       		ret
 2119              		.cfi_endproc
 2120              	.LFE14:
 2123              	isHexDigit:
 2124              	.LFB15:
 408:main.c        **** 
 409:main.c        **** 
 410:main.c        **** ///////////////////////////////////////////////////////////////////////////////////////////////////
 411:main.c        **** ///////////////////////////////////////////////////////////////////////////////////////////////////
 412:main.c        **** 
 413:main.c        **** 
 414:main.c        **** static bool isHexDigit(char ch) {
 2125              		.loc 1 414 0
 2126              		.cfi_startproc
 2127 1971 55       		pushq	%rbp
 2128              		.cfi_def_cfa_offset 16
 2129              		.cfi_offset 6, -16
 2130 1972 4889E5   		movq	%rsp, %rbp
 2131              		.cfi_def_cfa_register 6
 2132 1975 89F8     		movl	%edi, %eax
 2133 1977 8845FC   		movb	%al, -4(%rbp)
 415:main.c        **** 	return
 416:main.c        **** 	(ch >= '0' && ch <= '9') ||
 417:main.c        **** 	(ch >= 'a' && ch <= 'f') ||
 2134              		.loc 1 417 0
 2135 197a 807DFC2F 		cmpb	$47, -4(%rbp)
 2136 197e 7E06     		jle	.L97
 416:main.c        **** 	(ch >= 'a' && ch <= 'f') ||
 2137              		.loc 1 416 0
 2138 1980 807DFC39 		cmpb	$57, -4(%rbp)
 2139 1984 7E18     		jle	.L98
 2140              	.L97:
 416:main.c        **** 	(ch >= 'a' && ch <= 'f') ||
 2141              		.loc 1 416 0 is_stmt 0 discriminator 1
 2142 1986 807DFC60 		cmpb	$96, -4(%rbp)
 2143 198a 7E06     		jle	.L99
 2144              		.loc 1 417 0 is_stmt 1
 2145 198c 807DFC66 		cmpb	$102, -4(%rbp)
 2146 1990 7E0C     		jle	.L98
 2147              	.L99:
 2148              		.loc 1 417 0 is_stmt 0 discriminator 2
 2149 1992 807DFC40 		cmpb	$64, -4(%rbp)
 2150 1996 7E0D     		jle	.L100
 418:main.c        **** 	(ch >= 'A' && ch <= 'F');
 2151              		.loc 1 418 0 is_stmt 1
 2152 1998 807DFC46 		cmpb	$70, -4(%rbp)
 2153 199c 7F07     		jg	.L100
 2154              	.L98:
 417:main.c        **** 	(ch >= 'A' && ch <= 'F');
 2155              		.loc 1 417 0 discriminator 1
 2156 199e B8010000 		movl	$1, %eax
 2156      00
 2157 19a3 EB05     		jmp	.L101
 2158              	.L100:
 417:main.c        **** 	(ch >= 'A' && ch <= 'F');
 2159              		.loc 1 417 0 is_stmt 0 discriminator 3
 2160 19a5 B8000000 		movl	$0, %eax
 2160      00
 2161              	.L101:
 416:main.c        **** 	(ch >= 'a' && ch <= 'f') ||
 2162              		.loc 1 416 0 is_stmt 1
 2163 19aa 83E001   		andl	$1, %eax
 419:main.c        **** }
 2164              		.loc 1 419 0
 2165 19ad 5D       		popq	%rbp
 2166              		.cfi_def_cfa 7, 8
 2167 19ae C3       		ret
 2168              		.cfi_endproc
 2169              	.LFE15:
 2172              	calcChecksum:
 2173              	.LFB16:
 420:main.c        **** 
 421:main.c        **** static uint16 calcChecksum(const uint8 *data, size_t length) {
 2174              		.loc 1 421 0
 2175              		.cfi_startproc
 2176 19af 55       		pushq	%rbp
 2177              		.cfi_def_cfa_offset 16
 2178              		.cfi_offset 6, -16
 2179 19b0 4889E5   		movq	%rsp, %rbp
 2180              		.cfi_def_cfa_register 6
 2181 19b3 48897DE8 		movq	%rdi, -24(%rbp)
 2182 19b7 488975E0 		movq	%rsi, -32(%rbp)
 422:main.c        **** 	uint16 cksum = 0x0000;
 2183              		.loc 1 422 0
 2184 19bb 66C745FE 		movw	$0, -2(%rbp)
 2184      0000
 423:main.c        **** 	while ( length-- ) {
 2185              		.loc 1 423 0
 2186 19c1 EB16     		jmp	.L104
 2187              	.L105:
 424:main.c        **** 		cksum = (uint16)(cksum + *data++);
 2188              		.loc 1 424 0
 2189 19c3 488B45E8 		movq	-24(%rbp), %rax
 2190 19c7 488D5001 		leaq	1(%rax), %rdx
 2191 19cb 488955E8 		movq	%rdx, -24(%rbp)
 2192 19cf 0FB600   		movzbl	(%rax), %eax
 2193 19d2 0FB6C0   		movzbl	%al, %eax
 2194 19d5 660145FE 		addw	%ax, -2(%rbp)
 2195              	.L104:
 423:main.c        **** 	while ( length-- ) {
 2196              		.loc 1 423 0
 2197 19d9 488B45E0 		movq	-32(%rbp), %rax
 2198 19dd 488D50FF 		leaq	-1(%rax), %rdx
 2199 19e1 488955E0 		movq	%rdx, -32(%rbp)
 2200 19e5 4885C0   		testq	%rax, %rax
 2201 19e8 75D9     		jne	.L105
 425:main.c        **** 	}
 426:main.c        **** 	return cksum;
 2202              		.loc 1 426 0
 2203 19ea 0FB745FE 		movzwl	-2(%rbp), %eax
 427:main.c        **** }
 2204              		.loc 1 427 0
 2205 19ee 5D       		popq	%rbp
 2206              		.cfi_def_cfa 7, 8
 2207 19ef C3       		ret
 2208              		.cfi_endproc
 2209              	.LFE16:
 2212              	getHexNibble:
 2213              	.LFB17:
 428:main.c        **** 
 429:main.c        **** static bool getHexNibble(char hexDigit, uint8 *nibble) {
 2214              		.loc 1 429 0
 2215              		.cfi_startproc
 2216 19f0 55       		pushq	%rbp
 2217              		.cfi_def_cfa_offset 16
 2218              		.cfi_offset 6, -16
 2219 19f1 4889E5   		movq	%rsp, %rbp
 2220              		.cfi_def_cfa_register 6
 2221 19f4 89F8     		movl	%edi, %eax
 2222 19f6 488975F0 		movq	%rsi, -16(%rbp)
 2223 19fa 8845FC   		movb	%al, -4(%rbp)
 430:main.c        **** 	if ( hexDigit >= '0' && hexDigit <= '9' ) {
 2224              		.loc 1 430 0
 2225 19fd 807DFC2F 		cmpb	$47, -4(%rbp)
 2226 1a01 7E1A     		jle	.L108
 2227              		.loc 1 430 0 is_stmt 0 discriminator 1
 2228 1a03 807DFC39 		cmpb	$57, -4(%rbp)
 2229 1a07 7F14     		jg	.L108
 431:main.c        **** 		*nibble = (uint8)(hexDigit - '0');
 2230              		.loc 1 431 0 is_stmt 1
 2231 1a09 0FB645FC 		movzbl	-4(%rbp), %eax
 2232 1a0d 8D50D0   		leal	-48(%rax), %edx
 2233 1a10 488B45F0 		movq	-16(%rbp), %rax
 2234 1a14 8810     		movb	%dl, (%rax)
 432:main.c        **** 		return false;
 2235              		.loc 1 432 0
 2236 1a16 B8000000 		movl	$0, %eax
 2236      00
 2237 1a1b EB45     		jmp	.L109
 2238              	.L108:
 433:main.c        **** 	} else if ( hexDigit >= 'a' && hexDigit <= 'f' ) {
 2239              		.loc 1 433 0
 2240 1a1d 807DFC60 		cmpb	$96, -4(%rbp)
 2241 1a21 7E1A     		jle	.L110
 2242              		.loc 1 433 0 is_stmt 0 discriminator 1
 2243 1a23 807DFC66 		cmpb	$102, -4(%rbp)
 2244 1a27 7F14     		jg	.L110
 434:main.c        **** 		*nibble = (uint8)(hexDigit - 'a' + 10);
 2245              		.loc 1 434 0 is_stmt 1
 2246 1a29 0FB645FC 		movzbl	-4(%rbp), %eax
 2247 1a2d 8D50A9   		leal	-87(%rax), %edx
 2248 1a30 488B45F0 		movq	-16(%rbp), %rax
 2249 1a34 8810     		movb	%dl, (%rax)
 435:main.c        **** 		return false;
 2250              		.loc 1 435 0
 2251 1a36 B8000000 		movl	$0, %eax
 2251      00
 2252 1a3b EB25     		jmp	.L109
 2253              	.L110:
 436:main.c        **** 	} else if ( hexDigit >= 'A' && hexDigit <= 'F' ) {
 2254              		.loc 1 436 0
 2255 1a3d 807DFC40 		cmpb	$64, -4(%rbp)
 2256 1a41 7E1A     		jle	.L111
 2257              		.loc 1 436 0 is_stmt 0 discriminator 1
 2258 1a43 807DFC46 		cmpb	$70, -4(%rbp)
 2259 1a47 7F14     		jg	.L111
 437:main.c        **** 		*nibble = (uint8)(hexDigit - 'A' + 10);
 2260              		.loc 1 437 0 is_stmt 1
 2261 1a49 0FB645FC 		movzbl	-4(%rbp), %eax
 2262 1a4d 8D50C9   		leal	-55(%rax), %edx
 2263 1a50 488B45F0 		movq	-16(%rbp), %rax
 2264 1a54 8810     		movb	%dl, (%rax)
 438:main.c        **** 		return false;
 2265              		.loc 1 438 0
 2266 1a56 B8000000 		movl	$0, %eax
 2266      00
 2267 1a5b EB05     		jmp	.L109
 2268              	.L111:
 439:main.c        **** 	} else {
 440:main.c        **** 		return true;
 2269              		.loc 1 440 0
 2270 1a5d B8010000 		movl	$1, %eax
 2270      00
 2271              	.L109:
 441:main.c        **** 	}
 442:main.c        **** }
 2272              		.loc 1 442 0
 2273 1a62 5D       		popq	%rbp
 2274              		.cfi_def_cfa 7, 8
 2275 1a63 C3       		ret
 2276              		.cfi_endproc
 2277              	.LFE17:
 2280              	getHexByte:
 2281              	.LFB18:
 443:main.c        **** 
 444:main.c        **** static int getHexByte(uint8 *byte) {
 2282              		.loc 1 444 0
 2283              		.cfi_startproc
 2284 1a64 55       		pushq	%rbp
 2285              		.cfi_def_cfa_offset 16
 2286              		.cfi_offset 6, -16
 2287 1a65 4889E5   		movq	%rsp, %rbp
 2288              		.cfi_def_cfa_register 6
 2289 1a68 4883EC20 		subq	$32, %rsp
 2290 1a6c 48897DE8 		movq	%rdi, -24(%rbp)
 2291              		.loc 1 444 0
 2292 1a70 64488B04 		movq	%fs:40, %rax
 2292      25280000 
 2292      00
 2293 1a79 488945F8 		movq	%rax, -8(%rbp)
 2294 1a7d 31C0     		xorl	%eax, %eax
 445:main.c        **** 	uint8 upperNibble;
 446:main.c        **** 	uint8 lowerNibble;
 447:main.c        **** 	if ( !getHexNibble(ptr[0], &upperNibble) && !getHexNibble(ptr[1], &lowerNibble) ) {
 2295              		.loc 1 447 0
 2296 1a7f 488B0500 		movq	ptr(%rip), %rax
 2296      000000
 2297 1a86 0FB600   		movzbl	(%rax), %eax
 2298 1a89 0FBEC0   		movsbl	%al, %eax
 2299 1a8c 488D55F6 		leaq	-10(%rbp), %rdx
 2300 1a90 4889D6   		movq	%rdx, %rsi
 2301 1a93 89C7     		movl	%eax, %edi
 2302 1a95 E856FFFF 		call	getHexNibble
 2302      FF
 2303 1a9a 83F001   		xorl	$1, %eax
 2304 1a9d 84C0     		testb	%al, %al
 2305 1a9f 744C     		je	.L113
 2306              		.loc 1 447 0 is_stmt 0 discriminator 1
 2307 1aa1 488B0500 		movq	ptr(%rip), %rax
 2307      000000
 2308 1aa8 4883C001 		addq	$1, %rax
 2309 1aac 0FB600   		movzbl	(%rax), %eax
 2310 1aaf 0FBEC0   		movsbl	%al, %eax
 2311 1ab2 488D55F7 		leaq	-9(%rbp), %rdx
 2312 1ab6 4889D6   		movq	%rdx, %rsi
 2313 1ab9 89C7     		movl	%eax, %edi
 2314 1abb E830FFFF 		call	getHexNibble
 2314      FF
 2315 1ac0 83F001   		xorl	$1, %eax
 2316 1ac3 84C0     		testb	%al, %al
 2317 1ac5 7426     		je	.L113
 448:main.c        **** 		*byte = (uint8)((upperNibble << 4) | lowerNibble);
 2318              		.loc 1 448 0 is_stmt 1
 2319 1ac7 0FB645F6 		movzbl	-10(%rbp), %eax
 2320 1acb 0FB6C0   		movzbl	%al, %eax
 2321 1ace C1E004   		sall	$4, %eax
 2322 1ad1 89C2     		movl	%eax, %edx
 2323 1ad3 0FB645F7 		movzbl	-9(%rbp), %eax
 2324 1ad7 09D0     		orl	%edx, %eax
 2325 1ad9 89C2     		movl	%eax, %edx
 2326 1adb 488B45E8 		movq	-24(%rbp), %rax
 2327 1adf 8810     		movb	%dl, (%rax)
 449:main.c        **** 		byte += 2;
 2328              		.loc 1 449 0
 2329 1ae1 488345E8 		addq	$2, -24(%rbp)
 2329      02
 450:main.c        **** 		return 0;
 2330              		.loc 1 450 0
 2331 1ae6 B8000000 		movl	$0, %eax
 2331      00
 2332 1aeb EB05     		jmp	.L115
 2333              	.L113:
 451:main.c        **** 	} else {
 452:main.c        **** 		return 1;
 2334              		.loc 1 452 0
 2335 1aed B8010000 		movl	$1, %eax
 2335      00
 2336              	.L115:
 453:main.c        **** 	}
 454:main.c        **** }
 2337              		.loc 1 454 0 discriminator 1
 2338 1af2 488B4DF8 		movq	-8(%rbp), %rcx
 2339 1af6 6448330C 		xorq	%fs:40, %rcx
 2339      25280000 
 2339      00
 2340 1aff 7405     		je	.L116
 2341              		.loc 1 454 0 is_stmt 0
 2342 1b01 E8000000 		call	__stack_chk_fail
 2342      00
 2343              	.L116:
 2344 1b06 C9       		leave
 2345              		.cfi_def_cfa 7, 8
 2346 1b07 C3       		ret
 2347              		.cfi_endproc
 2348              	.LFE18:
 2350              		.section	.rodata
 2351              	.LC14:
 2352 00c9 556E7061 		.string	"Unparseable hex number"
 2352      72736561 
 2352      626C6520 
 2352      68657820 
 2352      6E756D62 
 2353              	.LC15:
 2354 00e0 4368616E 		.string	"Channel out of range"
 2354      6E656C20 
 2354      6F757420 
 2354      6F662072 
 2354      616E6765 
 2355              	.LC16:
 2356 00f5 436F6E64 		.string	"Conduit out of range"
 2356      75697420 
 2356      6F757420 
 2356      6F662072 
 2356      616E6765 
 2357              	.LC17:
 2358 010a 496C6C65 		.string	"Illegal character"
 2358      67616C20 
 2358      63686172 
 2358      61637465 
 2358      7200
 2359              	.LC18:
 2360 011c 556E7465 		.string	"Unterminated string"
 2360      726D696E 
 2360      61746564 
 2360      20737472 
 2360      696E6700 
 2361              	.LC19:
 2362 0130 4E6F206D 		.string	"No memory"
 2362      656D6F72 
 2362      7900
 2363              	.LC20:
 2364 013a 456D7074 		.string	"Empty string"
 2364      79207374 
 2364      72696E67 
 2364      00
 2365              	.LC21:
 2366 0147 4F646420 		.string	"Odd number of digits"
 2366      6E756D62 
 2366      6572206F 
 2366      66206469 
 2366      67697473 
 2367              	.LC22:
 2368 015c 43616E6E 		.string	"Cannot load file"
 2368      6F74206C 
 2368      6F616420 
 2368      66696C65 
 2368      00
 2369              	.LC23:
 2370 016d 43616E6E 		.string	"Cannot save file"
 2370      6F742073 
 2370      61766520 
 2370      66696C65 
 2370      00
 2371              	.LC24:
 2372 017e 42616420 		.string	"Bad arguments"
 2372      61726775 
 2372      6D656E74 
 2372      7300
 2373 018c 00000000 		.align 32
 2373      00000000 
 2373      00000000 
 2373      00000000 
 2373      00000000 
 2376              	errMessages:
 2377 01a0 00000000 		.quad	0
 2377      00000000 
 2378 01a8 00000000 		.quad	0
 2378      00000000 
 2379 01b0 00000000 		.quad	.LC14
 2379      00000000 
 2380 01b8 00000000 		.quad	.LC15
 2380      00000000 
 2381 01c0 00000000 		.quad	.LC16
 2381      00000000 
 2382 01c8 00000000 		.quad	.LC17
 2382      00000000 
 2383 01d0 00000000 		.quad	.LC18
 2383      00000000 
 2384 01d8 00000000 		.quad	.LC19
 2384      00000000 
 2385 01e0 00000000 		.quad	.LC20
 2385      00000000 
 2386 01e8 00000000 		.quad	.LC21
 2386      00000000 
 2387 01f0 00000000 		.quad	.LC22
 2387      00000000 
 2388 01f8 00000000 		.quad	.LC23
 2388      00000000 
 2389 0200 00000000 		.quad	.LC24
 2389      00000000 
 2390              	.LC25:
 2391 0208 646F5265 		.string	"doRead()"
 2391      61642829 
 2391      00
 2392              	.LC26:
 2393 0211 4261666F 		.string	"Bafoon"
 2393      6F6E00
 2394              		.text
 2396              	doRead:
 2397              	.LFB19:
 455:main.c        **** 
 456:main.c        **** static const char *const errMessages[] = {
 457:main.c        **** 	NULL,
 458:main.c        **** 	NULL,
 459:main.c        **** 	"Unparseable hex number",
 460:main.c        **** 	"Channel out of range",
 461:main.c        **** 	"Conduit out of range",
 462:main.c        **** 	"Illegal character",
 463:main.c        **** 	"Unterminated string",
 464:main.c        **** 	"No memory",
 465:main.c        **** 	"Empty string",
 466:main.c        **** 	"Odd number of digits",
 467:main.c        **** 	"Cannot load file",
 468:main.c        **** 	"Cannot save file",
 469:main.c        **** 	"Bad arguments"
 470:main.c        **** };
 471:main.c        **** 
 472:main.c        **** typedef enum {
 473:main.c        **** 	FLP_SUCCESS,
 474:main.c        **** 	FLP_LIBERR,
 475:main.c        **** 	FLP_BAD_HEX,
 476:main.c        **** 	FLP_CHAN_RANGE,
 477:main.c        **** 	FLP_CONDUIT_RANGE,
 478:main.c        **** 	FLP_ILL_CHAR,
 479:main.c        **** 	FLP_UNTERM_STRING,
 480:main.c        **** 	FLP_NO_MEMORY,
 481:main.c        **** 	FLP_EMPTY_STRING,
 482:main.c        **** 	FLP_ODD_DIGITS,
 483:main.c        **** 	FLP_CANNOT_LOAD,
 484:main.c        **** 	FLP_CANNOT_SAVE,
 485:main.c        **** 	FLP_ARGS
 486:main.c        **** } ReturnCode;
 487:main.c        **** 
 488:main.c        **** static ReturnCode doRead(
 489:main.c        **** 	struct FLContext *handle, uint8 chan, uint32 length, FILE *destFile, uint16 *checksum,
 490:main.c        **** 	const char **error)
 491:main.c        **** {
 2398              		.loc 1 491 0 is_stmt 1
 2399              		.cfi_startproc
 2400 1b08 55       		pushq	%rbp
 2401              		.cfi_def_cfa_offset 16
 2402              		.cfi_offset 6, -16
 2403 1b09 4889E5   		movq	%rsp, %rbp
 2404              		.cfi_def_cfa_register 6
 2405 1b0c 4883EC60 		subq	$96, %rsp
 2406 1b10 48897DC8 		movq	%rdi, -56(%rbp)
 2407 1b14 89F0     		movl	%esi, %eax
 2408 1b16 8955C0   		movl	%edx, -64(%rbp)
 2409 1b19 48894DB8 		movq	%rcx, -72(%rbp)
 2410 1b1d 4C8945B0 		movq	%r8, -80(%rbp)
 2411 1b21 4C894DA8 		movq	%r9, -88(%rbp)
 2412 1b25 8845C4   		movb	%al, -60(%rbp)
 2413              		.loc 1 491 0
 2414 1b28 64488B04 		movq	%fs:40, %rax
 2414      25280000 
 2414      00
 2415 1b31 488945F8 		movq	%rax, -8(%rbp)
 2416 1b35 31C0     		xorl	%eax, %eax
 492:main.c        **** 	ReturnCode retVal = FLP_SUCCESS;
 2417              		.loc 1 492 0
 2418 1b37 C745D800 		movl	$0, -40(%rbp)
 2418      000000
 493:main.c        **** 	uint32 bytesWritten;
 494:main.c        **** 	FLStatus fStatus;
 495:main.c        **** 	uint32 chunkSize;
 496:main.c        **** 	const uint8 *recvData;
 497:main.c        **** 	uint32 actualLength;
 498:main.c        **** 	const uint8 *ptr;
 499:main.c        **** 	uint16 csVal = 0x0000;
 2419              		.loc 1 499 0
 2420 1b3e 66C745D2 		movw	$0, -46(%rbp)
 2420      0000
 500:main.c        **** 	#define READ_MAX 65536
 501:main.c        **** 
 502:main.c        **** 	// Read first chunk
 503:main.c        **** 	chunkSize = length >= READ_MAX ? READ_MAX : length;
 2421              		.loc 1 503 0
 2422 1b44 B8000001 		movl	$65536, %eax
 2422      00
 2423 1b49 817DC000 		cmpl	$65536, -64(%rbp)
 2423      000100
 2424 1b50 0F4645C0 		cmovbe	-64(%rbp), %eax
 2425 1b54 8945DC   		movl	%eax, -36(%rbp)
 504:main.c        **** 	fStatus = flReadChannelAsyncSubmit(handle, chan, chunkSize, NULL, error);
 2426              		.loc 1 504 0
 2427 1b57 0FB675C4 		movzbl	-60(%rbp), %esi
 2428 1b5b 488B4DA8 		movq	-88(%rbp), %rcx
 2429 1b5f 8B55DC   		movl	-36(%rbp), %edx
 2430 1b62 488B45C8 		movq	-56(%rbp), %rax
 2431 1b66 4989C8   		movq	%rcx, %r8
 2432 1b69 B9000000 		movl	$0, %ecx
 2432      00
 2433 1b6e 4889C7   		movq	%rax, %rdi
 2434 1b71 E8000000 		call	flReadChannelAsyncSubmit
 2434      00
 2435 1b76 8945E0   		movl	%eax, -32(%rbp)
 505:main.c        **** 	CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doRead()");
 2436              		.loc 1 505 0
 2437 1b79 837DE000 		cmpl	$0, -32(%rbp)
 2438 1b7d 741D     		je	.L118
 2439              		.loc 1 505 0 is_stmt 0 discriminator 1
 2440 1b7f 488B45A8 		movq	-88(%rbp), %rax
 2441 1b83 BE000000 		movl	$.LC25, %esi
 2441      00
 2442 1b88 4889C7   		movq	%rax, %rdi
 2443 1b8b E8000000 		call	errPrefix
 2443      00
 2444 1b90 C745D801 		movl	$1, -40(%rbp)
 2444      000000
 2445 1b97 E9050200 		jmp	.L119
 2445      00
 2446              	.L118:
 506:main.c        **** 	length = length - chunkSize;
 2447              		.loc 1 506 0 is_stmt 1
 2448 1b9c 8B45DC   		movl	-36(%rbp), %eax
 2449 1b9f 2945C0   		subl	%eax, -64(%rbp)
 507:main.c        **** 
 508:main.c        **** 	while ( length ) {
 2450              		.loc 1 508 0
 2451 1ba2 E9280100 		jmp	.L120
 2451      00
 2452              	.L126:
 509:main.c        **** 		// Read chunk N
 510:main.c        **** 		chunkSize = length >= READ_MAX ? READ_MAX : length;
 2453              		.loc 1 510 0
 2454 1ba7 B8000001 		movl	$65536, %eax
 2454      00
 2455 1bac 817DC000 		cmpl	$65536, -64(%rbp)
 2455      000100
 2456 1bb3 0F4645C0 		cmovbe	-64(%rbp), %eax
 2457 1bb7 8945DC   		movl	%eax, -36(%rbp)
 511:main.c        **** 		fStatus = flReadChannelAsyncSubmit(handle, chan, chunkSize, NULL, error);
 2458              		.loc 1 511 0
 2459 1bba 0FB675C4 		movzbl	-60(%rbp), %esi
 2460 1bbe 488B4DA8 		movq	-88(%rbp), %rcx
 2461 1bc2 8B55DC   		movl	-36(%rbp), %edx
 2462 1bc5 488B45C8 		movq	-56(%rbp), %rax
 2463 1bc9 4989C8   		movq	%rcx, %r8
 2464 1bcc B9000000 		movl	$0, %ecx
 2464      00
 2465 1bd1 4889C7   		movq	%rax, %rdi
 2466 1bd4 E8000000 		call	flReadChannelAsyncSubmit
 2466      00
 2467 1bd9 8945E0   		movl	%eax, -32(%rbp)
 512:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doRead()");
 2468              		.loc 1 512 0
 2469 1bdc 837DE000 		cmpl	$0, -32(%rbp)
 2470 1be0 741D     		je	.L121
 2471              		.loc 1 512 0 is_stmt 0 discriminator 1
 2472 1be2 488B45A8 		movq	-88(%rbp), %rax
 2473 1be6 BE000000 		movl	$.LC25, %esi
 2473      00
 2474 1beb 4889C7   		movq	%rax, %rdi
 2475 1bee E8000000 		call	errPrefix
 2475      00
 2476 1bf3 C745D801 		movl	$1, -40(%rbp)
 2476      000000
 2477 1bfa E9A20100 		jmp	.L119
 2477      00
 2478              	.L121:
 513:main.c        **** 		length = length - chunkSize;
 2479              		.loc 1 513 0 is_stmt 1
 2480 1bff 8B45DC   		movl	-36(%rbp), %eax
 2481 1c02 2945C0   		subl	%eax, -64(%rbp)
 514:main.c        **** 		printf("Bafoon\n");
 2482              		.loc 1 514 0
 2483 1c05 BF000000 		movl	$.LC26, %edi
 2483      00
 2484 1c0a E8000000 		call	puts
 2484      00
 515:main.c        **** 		
 516:main.c        **** 		// Await chunk N-1
 517:main.c        **** 		fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, error);
 2485              		.loc 1 517 0
 2486 1c0f 488B7DA8 		movq	-88(%rbp), %rdi
 2487 1c13 488D4DD4 		leaq	-44(%rbp), %rcx
 2488 1c17 488D55D4 		leaq	-44(%rbp), %rdx
 2489 1c1b 488D75E8 		leaq	-24(%rbp), %rsi
 2490 1c1f 488B45C8 		movq	-56(%rbp), %rax
 2491 1c23 4989F8   		movq	%rdi, %r8
 2492 1c26 4889C7   		movq	%rax, %rdi
 2493 1c29 E8000000 		call	flReadChannelAsyncAwait
 2493      00
 2494 1c2e 8945E0   		movl	%eax, -32(%rbp)
 518:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doRead()");
 2495              		.loc 1 518 0
 2496 1c31 837DE000 		cmpl	$0, -32(%rbp)
 2497 1c35 741D     		je	.L122
 2498              		.loc 1 518 0 is_stmt 0 discriminator 1
 2499 1c37 488B45A8 		movq	-88(%rbp), %rax
 2500 1c3b BE000000 		movl	$.LC25, %esi
 2500      00
 2501 1c40 4889C7   		movq	%rax, %rdi
 2502 1c43 E8000000 		call	errPrefix
 2502      00
 2503 1c48 C745D801 		movl	$1, -40(%rbp)
 2503      000000
 2504 1c4f E94D0100 		jmp	.L119
 2504      00
 2505              	.L122:
 519:main.c        **** 
 520:main.c        **** 		// Write chunk N-1 to file
 521:main.c        **** 		bytesWritten = (uint32)fwrite(recvData, 1, actualLength, destFile);
 2506              		.loc 1 521 0 is_stmt 1
 2507 1c54 8B45D4   		movl	-44(%rbp), %eax
 2508 1c57 89C6     		movl	%eax, %esi
 2509 1c59 488B45E8 		movq	-24(%rbp), %rax
 2510 1c5d 488B55B8 		movq	-72(%rbp), %rdx
 2511 1c61 4889D1   		movq	%rdx, %rcx
 2512 1c64 4889F2   		movq	%rsi, %rdx
 2513 1c67 BE010000 		movl	$1, %esi
 2513      00
 2514 1c6c 4889C7   		movq	%rax, %rdi
 2515 1c6f E8000000 		call	fwrite
 2515      00
 2516 1c74 8945E4   		movl	%eax, -28(%rbp)
 522:main.c        **** 		CHECK_STATUS(bytesWritten != actualLength, FLP_CANNOT_SAVE, cleanup, "doRead()");
 2517              		.loc 1 522 0
 2518 1c77 8B45D4   		movl	-44(%rbp), %eax
 2519 1c7a 3945E4   		cmpl	%eax, -28(%rbp)
 2520 1c7d 741D     		je	.L123
 2521              		.loc 1 522 0 is_stmt 0 discriminator 1
 2522 1c7f 488B45A8 		movq	-88(%rbp), %rax
 2523 1c83 BE000000 		movl	$.LC25, %esi
 2523      00
 2524 1c88 4889C7   		movq	%rax, %rdi
 2525 1c8b E8000000 		call	errPrefix
 2525      00
 2526 1c90 C745D80B 		movl	$11, -40(%rbp)
 2526      000000
 2527 1c97 E9050100 		jmp	.L119
 2527      00
 2528              	.L123:
 523:main.c        **** 
 524:main.c        **** 		// Checksum chunk N-1
 525:main.c        **** 		chunkSize = actualLength;
 2529              		.loc 1 525 0 is_stmt 1
 2530 1c9c 8B45D4   		movl	-44(%rbp), %eax
 2531 1c9f 8945DC   		movl	%eax, -36(%rbp)
 526:main.c        **** 		ptr = recvData;
 2532              		.loc 1 526 0
 2533 1ca2 488B45E8 		movq	-24(%rbp), %rax
 2534 1ca6 488945F0 		movq	%rax, -16(%rbp)
 527:main.c        **** 		while ( chunkSize-- ) {
 2535              		.loc 1 527 0
 2536 1caa EB16     		jmp	.L124
 2537              	.L125:
 528:main.c        **** 			csVal = (uint16)(csVal + *ptr++);
 2538              		.loc 1 528 0
 2539 1cac 488B45F0 		movq	-16(%rbp), %rax
 2540 1cb0 488D5001 		leaq	1(%rax), %rdx
 2541 1cb4 488955F0 		movq	%rdx, -16(%rbp)
 2542 1cb8 0FB600   		movzbl	(%rax), %eax
 2543 1cbb 0FB6C0   		movzbl	%al, %eax
 2544 1cbe 660145D2 		addw	%ax, -46(%rbp)
 2545              	.L124:
 527:main.c        **** 		while ( chunkSize-- ) {
 2546              		.loc 1 527 0
 2547 1cc2 8B45DC   		movl	-36(%rbp), %eax
 2548 1cc5 8D50FF   		leal	-1(%rax), %edx
 2549 1cc8 8955DC   		movl	%edx, -36(%rbp)
 2550 1ccb 85C0     		testl	%eax, %eax
 2551 1ccd 75DD     		jne	.L125
 2552              	.L120:
 508:main.c        **** 		// Read chunk N
 2553              		.loc 1 508 0
 2554 1ccf 837DC000 		cmpl	$0, -64(%rbp)
 2555 1cd3 0F85CEFE 		jne	.L126
 2555      FFFF
 529:main.c        **** 		}
 530:main.c        **** 	}
 531:main.c        **** 
 532:main.c        **** 	// Await last chunk
 533:main.c        **** 	fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, error);
 2556              		.loc 1 533 0
 2557 1cd9 488B7DA8 		movq	-88(%rbp), %rdi
 2558 1cdd 488D4DD4 		leaq	-44(%rbp), %rcx
 2559 1ce1 488D55D4 		leaq	-44(%rbp), %rdx
 2560 1ce5 488D75E8 		leaq	-24(%rbp), %rsi
 2561 1ce9 488B45C8 		movq	-56(%rbp), %rax
 2562 1ced 4989F8   		movq	%rdi, %r8
 2563 1cf0 4889C7   		movq	%rax, %rdi
 2564 1cf3 E8000000 		call	flReadChannelAsyncAwait
 2564      00
 2565 1cf8 8945E0   		movl	%eax, -32(%rbp)
 534:main.c        **** 	CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doRead()");
 2566              		.loc 1 534 0
 2567 1cfb 837DE000 		cmpl	$0, -32(%rbp)
 2568 1cff 741D     		je	.L127
 2569              		.loc 1 534 0 is_stmt 0 discriminator 1
 2570 1d01 488B45A8 		movq	-88(%rbp), %rax
 2571 1d05 BE000000 		movl	$.LC25, %esi
 2571      00
 2572 1d0a 4889C7   		movq	%rax, %rdi
 2573 1d0d E8000000 		call	errPrefix
 2573      00
 2574 1d12 C745D801 		movl	$1, -40(%rbp)
 2574      000000
 2575 1d19 E9830000 		jmp	.L119
 2575      00
 2576              	.L127:
 535:main.c        **** 	
 536:main.c        **** 	// Write last chunk to file
 537:main.c        **** 	bytesWritten = (uint32)fwrite(recvData, 1, actualLength, destFile);
 2577              		.loc 1 537 0 is_stmt 1
 2578 1d1e 8B45D4   		movl	-44(%rbp), %eax
 2579 1d21 89C6     		movl	%eax, %esi
 2580 1d23 488B45E8 		movq	-24(%rbp), %rax
 2581 1d27 488B55B8 		movq	-72(%rbp), %rdx
 2582 1d2b 4889D1   		movq	%rdx, %rcx
 2583 1d2e 4889F2   		movq	%rsi, %rdx
 2584 1d31 BE010000 		movl	$1, %esi
 2584      00
 2585 1d36 4889C7   		movq	%rax, %rdi
 2586 1d39 E8000000 		call	fwrite
 2586      00
 2587 1d3e 8945E4   		movl	%eax, -28(%rbp)
 538:main.c        **** 	CHECK_STATUS(bytesWritten != actualLength, FLP_CANNOT_SAVE, cleanup, "doRead()");
 2588              		.loc 1 538 0
 2589 1d41 8B45D4   		movl	-44(%rbp), %eax
 2590 1d44 3945E4   		cmpl	%eax, -28(%rbp)
 2591 1d47 741A     		je	.L128
 2592              		.loc 1 538 0 is_stmt 0 discriminator 1
 2593 1d49 488B45A8 		movq	-88(%rbp), %rax
 2594 1d4d BE000000 		movl	$.LC25, %esi
 2594      00
 2595 1d52 4889C7   		movq	%rax, %rdi
 2596 1d55 E8000000 		call	errPrefix
 2596      00
 2597 1d5a C745D80B 		movl	$11, -40(%rbp)
 2597      000000
 2598 1d61 EB3E     		jmp	.L119
 2599              	.L128:
 539:main.c        **** 
 540:main.c        **** 	// Checksum last chunk
 541:main.c        **** 	chunkSize = actualLength;
 2600              		.loc 1 541 0 is_stmt 1
 2601 1d63 8B45D4   		movl	-44(%rbp), %eax
 2602 1d66 8945DC   		movl	%eax, -36(%rbp)
 542:main.c        **** 	ptr = recvData;
 2603              		.loc 1 542 0
 2604 1d69 488B45E8 		movq	-24(%rbp), %rax
 2605 1d6d 488945F0 		movq	%rax, -16(%rbp)
 543:main.c        **** 	while ( chunkSize-- ) {
 2606              		.loc 1 543 0
 2607 1d71 EB16     		jmp	.L129
 2608              	.L130:
 544:main.c        **** 		csVal = (uint16)(csVal + *ptr++);
 2609              		.loc 1 544 0
 2610 1d73 488B45F0 		movq	-16(%rbp), %rax
 2611 1d77 488D5001 		leaq	1(%rax), %rdx
 2612 1d7b 488955F0 		movq	%rdx, -16(%rbp)
 2613 1d7f 0FB600   		movzbl	(%rax), %eax
 2614 1d82 0FB6C0   		movzbl	%al, %eax
 2615 1d85 660145D2 		addw	%ax, -46(%rbp)
 2616              	.L129:
 543:main.c        **** 	while ( chunkSize-- ) {
 2617              		.loc 1 543 0
 2618 1d89 8B45DC   		movl	-36(%rbp), %eax
 2619 1d8c 8D50FF   		leal	-1(%rax), %edx
 2620 1d8f 8955DC   		movl	%edx, -36(%rbp)
 2621 1d92 85C0     		testl	%eax, %eax
 2622 1d94 75DD     		jne	.L130
 545:main.c        **** 	}
 546:main.c        **** 	
 547:main.c        **** 	// Return checksum to caller
 548:main.c        **** 	*checksum = csVal;
 2623              		.loc 1 548 0
 2624 1d96 488B45B0 		movq	-80(%rbp), %rax
 2625 1d9a 0FB755D2 		movzwl	-46(%rbp), %edx
 2626 1d9e 668910   		movw	%dx, (%rax)
 2627              	.L119:
 549:main.c        **** 	cleanup:
 550:main.c        **** 	return retVal;
 2628              		.loc 1 550 0
 2629 1da1 8B45D8   		movl	-40(%rbp), %eax
 551:main.c        **** }
 2630              		.loc 1 551 0
 2631 1da4 488B4DF8 		movq	-8(%rbp), %rcx
 2632 1da8 6448330C 		xorq	%fs:40, %rcx
 2632      25280000 
 2632      00
 2633 1db1 7405     		je	.L132
 2634 1db3 E8000000 		call	__stack_chk_fail
 2634      00
 2635              	.L132:
 2636 1db8 C9       		leave
 2637              		.cfi_def_cfa 7, 8
 2638 1db9 C3       		ret
 2639              		.cfi_endproc
 2640              	.LFE19:
 2642              		.section	.rodata
 2643              	.LC27:
 2644 0218 646F5772 		.string	"doWrite()"
 2644      69746528 
 2644      2900
 2645              		.text
 2647              	doWrite:
 2648              	.LFB20:
 552:main.c        **** 
 553:main.c        **** static ReturnCode doWrite(
 554:main.c        **** 	struct FLContext *handle, uint8 chan, FILE *srcFile, size_t *length, uint16 *checksum,
 555:main.c        **** 	const char **error)
 556:main.c        **** {
 2649              		.loc 1 556 0
 2650              		.cfi_startproc
 2651 1dba 55       		pushq	%rbp
 2652              		.cfi_def_cfa_offset 16
 2653              		.cfi_offset 6, -16
 2654 1dbb 4889E5   		movq	%rsp, %rbp
 2655              		.cfi_def_cfa_register 6
 2656 1dbe 4881EC70 		subq	$65648, %rsp
 2656      000100
 2657 1dc5 4889BDB8 		movq	%rdi, -65608(%rbp)
 2657      FFFEFF
 2658 1dcc 89F0     		movl	%esi, %eax
 2659 1dce 488995A8 		movq	%rdx, -65624(%rbp)
 2659      FFFEFF
 2660 1dd5 48898DA0 		movq	%rcx, -65632(%rbp)
 2660      FFFEFF
 2661 1ddc 4C898598 		movq	%r8, -65640(%rbp)
 2661      FFFEFF
 2662 1de3 4C898D90 		movq	%r9, -65648(%rbp)
 2662      FFFEFF
 2663 1dea 8885B4FF 		movb	%al, -65612(%rbp)
 2663      FEFF
 2664              		.loc 1 556 0
 2665 1df0 64488B04 		movq	%fs:40, %rax
 2665      25280000 
 2665      00
 2666 1df9 488945F8 		movq	%rax, -8(%rbp)
 2667 1dfd 31C0     		xorl	%eax, %eax
 557:main.c        **** 	ReturnCode retVal = FLP_SUCCESS;
 2668              		.loc 1 557 0
 2669 1dff C785C8FF 		movl	$0, -65592(%rbp)
 2669      FEFF0000 
 2669      0000
 558:main.c        **** 	size_t bytesRead, i;
 559:main.c        **** 	FLStatus fStatus;
 560:main.c        **** 	const uint8 *ptr;
 561:main.c        **** 	uint16 csVal = 0x0000;
 2670              		.loc 1 561 0
 2671 1e09 66C785C6 		movw	$0, -65594(%rbp)
 2671      FFFEFF00 
 2671      00
 562:main.c        **** 	size_t lenVal = 0;
 2672              		.loc 1 562 0
 2673 1e12 48C785E0 		movq	$0, -65568(%rbp)
 2673      FFFEFF00 
 2673      000000
 2674              	.L139:
 563:main.c        **** 	#define WRITE_MAX (65536 - 5)
 564:main.c        **** 	uint8 buffer[WRITE_MAX];
 565:main.c        **** 
 566:main.c        **** 	do {
 567:main.c        **** 		// Read Nth chunk
 568:main.c        **** 		bytesRead = fread(buffer, 1, WRITE_MAX, srcFile);
 2675              		.loc 1 568 0
 2676 1e1d 488B95A8 		movq	-65624(%rbp), %rdx
 2676      FFFEFF
 2677 1e24 488D85F0 		leaq	-65552(%rbp), %rax
 2677      FFFEFF
 2678 1e2b 4889D1   		movq	%rdx, %rcx
 2679 1e2e BAFBFF00 		movl	$65531, %edx
 2679      00
 2680 1e33 BE010000 		movl	$1, %esi
 2680      00
 2681 1e38 4889C7   		movq	%rax, %rdi
 2682 1e3b E8000000 		call	fread
 2682      00
 2683 1e40 488985E8 		movq	%rax, -65560(%rbp)
 2683      FFFEFF
 569:main.c        **** 		if ( bytesRead ) {
 2684              		.loc 1 569 0
 2685 1e47 4883BDE8 		cmpq	$0, -65560(%rbp)
 2685      FFFEFF00 
 2686 1e4f 0F84C200 		je	.L134
 2686      0000
 570:main.c        **** 			// Update running total
 571:main.c        **** 			lenVal = lenVal + bytesRead;
 2687              		.loc 1 571 0
 2688 1e55 488B85E8 		movq	-65560(%rbp), %rax
 2688      FFFEFF
 2689 1e5c 480185E0 		addq	%rax, -65568(%rbp)
 2689      FFFEFF
 572:main.c        **** 
 573:main.c        **** 			// Submit Nth chunk
 574:main.c        **** 			fStatus = flWriteChannelAsync(handle, chan, bytesRead, buffer, error);
 2690              		.loc 1 574 0
 2691 1e63 0FB6B5B4 		movzbl	-65612(%rbp), %esi
 2691      FFFEFF
 2692 1e6a 488BBD90 		movq	-65648(%rbp), %rdi
 2692      FFFEFF
 2693 1e71 488D8DF0 		leaq	-65552(%rbp), %rcx
 2693      FFFEFF
 2694 1e78 488B95E8 		movq	-65560(%rbp), %rdx
 2694      FFFEFF
 2695 1e7f 488B85B8 		movq	-65608(%rbp), %rax
 2695      FFFEFF
 2696 1e86 4989F8   		movq	%rdi, %r8
 2697 1e89 4889C7   		movq	%rax, %rdi
 2698 1e8c E8000000 		call	flWriteChannelAsync
 2698      00
 2699 1e91 8985CCFF 		movl	%eax, -65588(%rbp)
 2699      FEFF
 575:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doWrite()");
 2700              		.loc 1 575 0
 2701 1e97 83BDCCFF 		cmpl	$0, -65588(%rbp)
 2701      FEFF00
 2702 1e9e 7423     		je	.L135
 2703              		.loc 1 575 0 is_stmt 0 discriminator 1
 2704 1ea0 488B8590 		movq	-65648(%rbp), %rax
 2704      FFFEFF
 2705 1ea7 BE000000 		movl	$.LC27, %esi
 2705      00
 2706 1eac 4889C7   		movq	%rax, %rdi
 2707 1eaf E8000000 		call	errPrefix
 2707      00
 2708 1eb4 C785C8FF 		movl	$1, -65592(%rbp)
 2708      FEFF0100 
 2708      0000
 2709 1ebe E9CF0000 		jmp	.L136
 2709      00
 2710              	.L135:
 576:main.c        **** 
 577:main.c        **** 			// Checksum Nth chunk
 578:main.c        **** 			i = bytesRead;
 2711              		.loc 1 578 0 is_stmt 1
 2712 1ec3 488B85E8 		movq	-65560(%rbp), %rax
 2712      FFFEFF
 2713 1eca 488985D0 		movq	%rax, -65584(%rbp)
 2713      FFFEFF
 579:main.c        **** 			ptr = buffer;
 2714              		.loc 1 579 0
 2715 1ed1 488D85F0 		leaq	-65552(%rbp), %rax
 2715      FFFEFF
 2716 1ed8 488985D8 		movq	%rax, -65576(%rbp)
 2716      FFFEFF
 580:main.c        **** 			while ( i-- ) {
 2717              		.loc 1 580 0
 2718 1edf EB1F     		jmp	.L137
 2719              	.L138:
 581:main.c        **** 				csVal = (uint16)(csVal + *ptr++);
 2720              		.loc 1 581 0
 2721 1ee1 488B85D8 		movq	-65576(%rbp), %rax
 2721      FFFEFF
 2722 1ee8 488D5001 		leaq	1(%rax), %rdx
 2723 1eec 488995D8 		movq	%rdx, -65576(%rbp)
 2723      FFFEFF
 2724 1ef3 0FB600   		movzbl	(%rax), %eax
 2725 1ef6 0FB6C0   		movzbl	%al, %eax
 2726 1ef9 660185C6 		addw	%ax, -65594(%rbp)
 2726      FFFEFF
 2727              	.L137:
 580:main.c        **** 			while ( i-- ) {
 2728              		.loc 1 580 0
 2729 1f00 488B85D0 		movq	-65584(%rbp), %rax
 2729      FFFEFF
 2730 1f07 488D50FF 		leaq	-1(%rax), %rdx
 2731 1f0b 488995D0 		movq	%rdx, -65584(%rbp)
 2731      FFFEFF
 2732 1f12 4885C0   		testq	%rax, %rax
 2733 1f15 75CA     		jne	.L138
 2734              	.L134:
 582:main.c        **** 			}
 583:main.c        **** 		}
 584:main.c        **** 	} while ( bytesRead == WRITE_MAX );
 2735              		.loc 1 584 0
 2736 1f17 4881BDE8 		cmpq	$65531, -65560(%rbp)
 2736      FFFEFFFB 
 2736      FF0000
 2737 1f22 0F84F5FE 		je	.L139
 2737      FFFF
 585:main.c        **** 
 586:main.c        **** 	// Wait for writes to be received. This is optional, but it's only fair if we're benchmarking to
 587:main.c        **** 	// actually wait for the work to be completed.
 588:main.c        **** 	fStatus = flAwaitAsyncWrites(handle, error);
 2738              		.loc 1 588 0
 2739 1f28 488B9590 		movq	-65648(%rbp), %rdx
 2739      FFFEFF
 2740 1f2f 488B85B8 		movq	-65608(%rbp), %rax
 2740      FFFEFF
 2741 1f36 4889D6   		movq	%rdx, %rsi
 2742 1f39 4889C7   		movq	%rax, %rdi
 2743 1f3c E8000000 		call	flAwaitAsyncWrites
 2743      00
 2744 1f41 8985CCFF 		movl	%eax, -65588(%rbp)
 2744      FEFF
 589:main.c        **** 	CHECK_STATUS(fStatus, FLP_LIBERR, cleanup, "doWrite()");
 2745              		.loc 1 589 0
 2746 1f47 83BDCCFF 		cmpl	$0, -65588(%rbp)
 2746      FEFF00
 2747 1f4e 7420     		je	.L140
 2748              		.loc 1 589 0 is_stmt 0 discriminator 1
 2749 1f50 488B8590 		movq	-65648(%rbp), %rax
 2749      FFFEFF
 2750 1f57 BE000000 		movl	$.LC27, %esi
 2750      00
 2751 1f5c 4889C7   		movq	%rax, %rdi
 2752 1f5f E8000000 		call	errPrefix
 2752      00
 2753 1f64 C785C8FF 		movl	$1, -65592(%rbp)
 2753      FEFF0100 
 2753      0000
 2754 1f6e EB22     		jmp	.L136
 2755              	.L140:
 590:main.c        **** 
 591:main.c        **** 	// Return checksum & length to caller
 592:main.c        **** 	*checksum = csVal;
 2756              		.loc 1 592 0 is_stmt 1
 2757 1f70 488B8598 		movq	-65640(%rbp), %rax
 2757      FFFEFF
 2758 1f77 0FB795C6 		movzwl	-65594(%rbp), %edx
 2758      FFFEFF
 2759 1f7e 668910   		movw	%dx, (%rax)
 593:main.c        **** 	*length = lenVal;
 2760              		.loc 1 593 0
 2761 1f81 488B85A0 		movq	-65632(%rbp), %rax
 2761      FFFEFF
 2762 1f88 488B95E0 		movq	-65568(%rbp), %rdx
 2762      FFFEFF
 2763 1f8f 488910   		movq	%rdx, (%rax)
 2764              	.L136:
 594:main.c        **** 	cleanup:
 595:main.c        **** 	return retVal;
 2765              		.loc 1 595 0
 2766 1f92 8B85C8FF 		movl	-65592(%rbp), %eax
 2766      FEFF
 596:main.c        **** }
 2767              		.loc 1 596 0
 2768 1f98 488B4DF8 		movq	-8(%rbp), %rcx
 2769 1f9c 6448330C 		xorq	%fs:40, %rcx
 2769      25280000 
 2769      00
 2770 1fa5 7405     		je	.L142
 2771 1fa7 E8000000 		call	__stack_chk_fail
 2771      00
 2772              	.L142:
 2773 1fac C9       		leave
 2774              		.cfi_def_cfa 7, 8
 2775 1fad C3       		ret
 2776              		.cfi_endproc
 2777              	.LFE20:
 2779              		.section	.rodata
 2780              	.LC28:
 2781 0222 776200   		.string	"wb"
 2782 0225 000000   		.align 8
 2783              	.LC31:
 2784 0228 52656164 		.string	"Read %d bytes (checksum 0x%04X) from channel %d at %f MiB/s\n"
 2784      20256420 
 2784      62797465 
 2784      73202863 
 2784      6865636B 
 2785              	.LC32:
 2786 0265 726200   		.string	"rb"
 2787              		.align 8
 2788              	.LC33:
 2789 0268 57726F74 		.string	"Wrote %zu bytes (checksum 0x%04X) to channel %lu at %f MiB/s\n"
 2789      6520257A 
 2789      75206279 
 2789      74657320 
 2789      28636865 
 2790              	.LC34:
 2791 02a6 25732061 		.string	"%s at column %d\n  %s\n  "
 2791      7420636F 
 2791      6C756D6E 
 2791      2025640A 
 2791      20202573 
 2792              	.LC35:
 2793 02be 5E0A00   		.string	"^\n"
 2794              		.text
 2796              	parseLine:
 2797              	.LFB21:
 597:main.c        **** 
 598:main.c        **** static int parseLine(struct FLContext *handle, const char *line, const char **error) {
 2798              		.loc 1 598 0
 2799              		.cfi_startproc
 2800 1fae 55       		pushq	%rbp
 2801              		.cfi_def_cfa_offset 16
 2802              		.cfi_offset 6, -16
 2803 1faf 4889E5   		movq	%rsp, %rbp
 2804              		.cfi_def_cfa_register 6
 2805 1fb2 4881EC10 		subq	$272, %rsp
 2805      010000
 2806 1fb9 4889BD08 		movq	%rdi, -248(%rbp)
 2806      FFFFFF
 2807 1fc0 4889B500 		movq	%rsi, -256(%rbp)
 2807      FFFFFF
 2808 1fc7 488995F8 		movq	%rdx, -264(%rbp)
 2808      FEFFFF
 2809              		.loc 1 598 0
 2810 1fce 64488B04 		movq	%fs:40, %rax
 2810      25280000 
 2810      00
 2811 1fd7 488945F8 		movq	%rax, -8(%rbp)
 2812 1fdb 31C0     		xorl	%eax, %eax
 599:main.c        **** 	ReturnCode retVal = FLP_SUCCESS, status;
 2813              		.loc 1 599 0
 2814 1fdd C78514FF 		movl	$0, -236(%rbp)
 2814      FFFF0000 
 2814      0000
 600:main.c        **** 	FLStatus fStatus;
 601:main.c        **** 	struct Buffer dataFromFPGA = {0,};
 2815              		.loc 1 601 0
 2816 1fe7 48C745D0 		movq	$0, -48(%rbp)
 2816      00000000 
 2817 1fef 48C745D8 		movq	$0, -40(%rbp)
 2817      00000000 
 2818 1ff7 48C745E0 		movq	$0, -32(%rbp)
 2818      00000000 
 2819 1fff 48C745E8 		movq	$0, -24(%rbp)
 2819      00000000 
 602:main.c        **** 	BufferStatus bStatus;
 603:main.c        **** 	uint8 *data = NULL;
 2820              		.loc 1 603 0
 2821 2007 48C78548 		movq	$0, -184(%rbp)
 2821      FFFFFF00 
 2821      000000
 604:main.c        **** 	char *fileName = NULL;
 2822              		.loc 1 604 0
 2823 2012 48C78550 		movq	$0, -176(%rbp)
 2823      FFFFFF00 
 2823      000000
 605:main.c        **** 	FILE *file = NULL;
 2824              		.loc 1 605 0
 2825 201d 48C78558 		movq	$0, -168(%rbp)
 2825      FFFFFF00 
 2825      000000
 606:main.c        **** 	double totalTime, speed;
 607:main.c        **** 	#ifdef WIN32
 608:main.c        **** 	LARGE_INTEGER tvStart, tvEnd, freq;
 609:main.c        **** 	DWORD_PTR mask = 1;
 610:main.c        **** 	SetThreadAffinityMask(GetCurrentThread(), mask);
 611:main.c        **** 	QueryPerformanceFrequency(&freq);
 612:main.c        **** 	#else
 613:main.c        **** 	struct timeval tvStart, tvEnd;
 614:main.c        **** 	long long startTime, endTime;
 615:main.c        **** 	#endif
 616:main.c        **** 	bStatus = bufInitialise(&dataFromFPGA, 1024, 0x00, error);
 2826              		.loc 1 616 0
 2827 2028 488B95F8 		movq	-264(%rbp), %rdx
 2827      FEFFFF
 2828 202f 488D45D0 		leaq	-48(%rbp), %rax
 2829 2033 4889D1   		movq	%rdx, %rcx
 2830 2036 BA000000 		movl	$0, %edx
 2830      00
 2831 203b BE000400 		movl	$1024, %esi
 2831      00
 2832 2040 4889C7   		movq	%rax, %rdi
 2833 2043 E8000000 		call	bufInitialise
 2833      00
 2834 2048 898520FF 		movl	%eax, -224(%rbp)
 2834      FFFF
 617:main.c        **** 	CHECK_STATUS(bStatus, FLP_LIBERR, cleanup);
 2835              		.loc 1 617 0
 2836 204e 83BD20FF 		cmpl	$0, -224(%rbp)
 2836      FFFF00
 2837 2055 740F     		je	.L144
 2838              		.loc 1 617 0 is_stmt 0 discriminator 1
 2839 2057 C78514FF 		movl	$1, -236(%rbp)
 2839      FFFF0100 
 2839      0000
 2840 2061 E9E40E00 		jmp	.L145
 2840      00
 2841              	.L144:
 618:main.c        **** 	ptr = line;
 2842              		.loc 1 618 0 is_stmt 1
 2843 2066 488B8500 		movq	-256(%rbp), %rax
 2843      FFFFFF
 2844 206d 48890500 		movq	%rax, ptr(%rip)
 2844      000000
 619:main.c        **** 	do {
 620:main.c        **** 		while ( *ptr == ';' ) {
 2845              		.loc 1 620 0
 2846 2074 EB12     		jmp	.L146
 2847              	.L147:
 621:main.c        **** 			ptr++;
 2848              		.loc 1 621 0
 2849 2076 488B0500 		movq	ptr(%rip), %rax
 2849      000000
 2850 207d 4883C001 		addq	$1, %rax
 2851 2081 48890500 		movq	%rax, ptr(%rip)
 2851      000000
 2852              	.L146:
 620:main.c        **** 			ptr++;
 2853              		.loc 1 620 0
 2854 2088 488B0500 		movq	ptr(%rip), %rax
 2854      000000
 2855 208f 0FB600   		movzbl	(%rax), %eax
 2856 2092 3C3B     		cmpb	$59, %al
 2857 2094 74E0     		je	.L147
 622:main.c        **** 		}
 623:main.c        **** 		switch ( *ptr ) {
 2858              		.loc 1 623 0
 2859 2096 488B0500 		movq	ptr(%rip), %rax
 2859      000000
 2860 209d 0FB600   		movzbl	(%rax), %eax
 2861 20a0 0FBEC0   		movsbl	%al, %eax
 2862 20a3 83F872   		cmpl	$114, %eax
 2863 20a6 7417     		je	.L149
 2864 20a8 83F877   		cmpl	$119, %eax
 2865 20ab 0F84C306 		je	.L150
 2865      0000
 2866 20b1 83F82B   		cmpl	$43, %eax
 2867 20b4 0F84530D 		je	.L151
 2867      0000
 2868 20ba E93A0E00 		jmp	.L221
 2868      00
 2869              	.L149:
 2870              	.LBB32:
 624:main.c        **** 			case 'r':{
 625:main.c        **** 				uint32 chan;
 626:main.c        **** 				uint32 length = 1;
 2871              		.loc 1 626 0
 2872 20bf C78518FF 		movl	$1, -232(%rbp)
 2872      FFFF0100 
 2872      0000
 627:main.c        **** 				char *end;
 628:main.c        **** 				ptr++;
 2873              		.loc 1 628 0
 2874 20c9 488B0500 		movq	ptr(%rip), %rax
 2874      000000
 2875 20d0 4883C001 		addq	$1, %rax
 2876 20d4 48890500 		movq	%rax, ptr(%rip)
 2876      000000
 629:main.c        **** 
 630:main.c        **** 			// Get the channel to be read:
 631:main.c        **** 				errno = 0;
 2877              		.loc 1 631 0
 2878 20db E8000000 		call	__errno_location
 2878      00
 2879 20e0 C7000000 		movl	$0, (%rax)
 2879      0000
 632:main.c        **** 				chan = (uint32)strtoul(ptr, &end, 16);
 2880              		.loc 1 632 0
 2881 20e6 488B0500 		movq	ptr(%rip), %rax
 2881      000000
 2882 20ed 488D8D40 		leaq	-192(%rbp), %rcx
 2882      FFFFFF
 2883 20f4 BA100000 		movl	$16, %edx
 2883      00
 2884 20f9 4889CE   		movq	%rcx, %rsi
 2885 20fc 4889C7   		movq	%rax, %rdi
 2886 20ff E8000000 		call	strtoul
 2886      00
 2887 2104 898530FF 		movl	%eax, -208(%rbp)
 2887      FFFF
 633:main.c        **** 				CHECK_STATUS(errno, FLP_BAD_HEX, cleanup);
 2888              		.loc 1 633 0
 2889 210a E8000000 		call	__errno_location
 2889      00
 2890 210f 8B00     		movl	(%rax), %eax
 2891 2111 85C0     		testl	%eax, %eax
 2892 2113 740F     		je	.L152
 2893              		.loc 1 633 0 is_stmt 0 discriminator 1
 2894 2115 C78514FF 		movl	$2, -236(%rbp)
 2894      FFFF0200 
 2894      0000
 2895 211f E9260E00 		jmp	.L145
 2895      00
 2896              	.L152:
 634:main.c        **** 
 635:main.c        **** 			// Ensure that it's 0-127
 636:main.c        **** 				CHECK_STATUS(chan > 127, FLP_CHAN_RANGE, cleanup);
 2897              		.loc 1 636 0 is_stmt 1
 2898 2124 83BD30FF 		cmpl	$127, -208(%rbp)
 2898      FFFF7F
 2899 212b 760F     		jbe	.L154
 2900              		.loc 1 636 0 is_stmt 0 discriminator 1
 2901 212d C78514FF 		movl	$3, -236(%rbp)
 2901      FFFF0300 
 2901      0000
 2902 2137 E90E0E00 		jmp	.L145
 2902      00
 2903              	.L154:
 637:main.c        **** 				ptr = end;
 2904              		.loc 1 637 0 is_stmt 1
 2905 213c 488B8540 		movq	-192(%rbp), %rax
 2905      FFFFFF
 2906 2143 48890500 		movq	%rax, ptr(%rip)
 2906      000000
 638:main.c        **** 
 639:main.c        **** 			// Only three valid chars at this point:
 640:main.c        **** 				CHECK_STATUS(*ptr != '\0' && *ptr != ';' && *ptr != ' ', FLP_ILL_CHAR, cleanup);
 2907              		.loc 1 640 0
 2908 214a 488B0500 		movq	ptr(%rip), %rax
 2908      000000
 2909 2151 0FB600   		movzbl	(%rax), %eax
 2910 2154 84C0     		testb	%al, %al
 2911 2156 742B     		je	.L155
 2912              		.loc 1 640 0 is_stmt 0 discriminator 1
 2913 2158 488B0500 		movq	ptr(%rip), %rax
 2913      000000
 2914 215f 0FB600   		movzbl	(%rax), %eax
 2915 2162 3C3B     		cmpb	$59, %al
 2916 2164 741D     		je	.L155
 2917              		.loc 1 640 0 discriminator 2
 2918 2166 488B0500 		movq	ptr(%rip), %rax
 2918      000000
 2919 216d 0FB600   		movzbl	(%rax), %eax
 2920 2170 3C20     		cmpb	$32, %al
 2921 2172 740F     		je	.L155
 2922              		.loc 1 640 0 discriminator 3
 2923 2174 C78514FF 		movl	$5, -236(%rbp)
 2923      FFFF0500 
 2923      0000
 2924 217e E9C70D00 		jmp	.L145
 2924      00
 2925              	.L155:
 641:main.c        **** 
 642:main.c        **** 				if ( *ptr == ' ' ) {
 2926              		.loc 1 642 0 is_stmt 1
 2927 2183 488B0500 		movq	ptr(%rip), %rax
 2927      000000
 2928 218a 0FB600   		movzbl	(%rax), %eax
 2929 218d 3C20     		cmpb	$32, %al
 2930 218f 0F851D02 		jne	.L156
 2930      0000
 643:main.c        **** 					ptr++;
 2931              		.loc 1 643 0
 2932 2195 488B0500 		movq	ptr(%rip), %rax
 2932      000000
 2933 219c 4883C001 		addq	$1, %rax
 2934 21a0 48890500 		movq	%rax, ptr(%rip)
 2934      000000
 644:main.c        **** 
 645:main.c        **** 				// Get the read count:
 646:main.c        **** 					errno = 0;
 2935              		.loc 1 646 0
 2936 21a7 E8000000 		call	__errno_location
 2936      00
 2937 21ac C7000000 		movl	$0, (%rax)
 2937      0000
 647:main.c        **** 					length = (uint32)strtoul(ptr, &end, 16);
 2938              		.loc 1 647 0
 2939 21b2 488B0500 		movq	ptr(%rip), %rax
 2939      000000
 2940 21b9 488D8D40 		leaq	-192(%rbp), %rcx
 2940      FFFFFF
 2941 21c0 BA100000 		movl	$16, %edx
 2941      00
 2942 21c5 4889CE   		movq	%rcx, %rsi
 2943 21c8 4889C7   		movq	%rax, %rdi
 2944 21cb E8000000 		call	strtoul
 2944      00
 2945 21d0 898518FF 		movl	%eax, -232(%rbp)
 2945      FFFF
 648:main.c        **** 					CHECK_STATUS(errno, FLP_BAD_HEX, cleanup);
 2946              		.loc 1 648 0
 2947 21d6 E8000000 		call	__errno_location
 2947      00
 2948 21db 8B00     		movl	(%rax), %eax
 2949 21dd 85C0     		testl	%eax, %eax
 2950 21df 740F     		je	.L157
 2951              		.loc 1 648 0 is_stmt 0 discriminator 1
 2952 21e1 C78514FF 		movl	$2, -236(%rbp)
 2952      FFFF0200 
 2952      0000
 2953 21eb E95A0D00 		jmp	.L145
 2953      00
 2954              	.L157:
 649:main.c        **** 					ptr = end;
 2955              		.loc 1 649 0 is_stmt 1
 2956 21f0 488B8540 		movq	-192(%rbp), %rax
 2956      FFFFFF
 2957 21f7 48890500 		movq	%rax, ptr(%rip)
 2957      000000
 650:main.c        **** 
 651:main.c        **** 				// Only three valid chars at this point:
 652:main.c        **** 					CHECK_STATUS(*ptr != '\0' && *ptr != ';' && *ptr != ' ', FLP_ILL_CHAR, cleanup);
 2958              		.loc 1 652 0
 2959 21fe 488B0500 		movq	ptr(%rip), %rax
 2959      000000
 2960 2205 0FB600   		movzbl	(%rax), %eax
 2961 2208 84C0     		testb	%al, %al
 2962 220a 742B     		je	.L158
 2963              		.loc 1 652 0 is_stmt 0 discriminator 1
 2964 220c 488B0500 		movq	ptr(%rip), %rax
 2964      000000
 2965 2213 0FB600   		movzbl	(%rax), %eax
 2966 2216 3C3B     		cmpb	$59, %al
 2967 2218 741D     		je	.L158
 2968              		.loc 1 652 0 discriminator 2
 2969 221a 488B0500 		movq	ptr(%rip), %rax
 2969      000000
 2970 2221 0FB600   		movzbl	(%rax), %eax
 2971 2224 3C20     		cmpb	$32, %al
 2972 2226 740F     		je	.L158
 2973              		.loc 1 652 0 discriminator 3
 2974 2228 C78514FF 		movl	$5, -236(%rbp)
 2974      FFFF0500 
 2974      0000
 2975 2232 E9130D00 		jmp	.L145
 2975      00
 2976              	.L158:
 653:main.c        **** 					if ( *ptr == ' ' ) {
 2977              		.loc 1 653 0 is_stmt 1
 2978 2237 488B0500 		movq	ptr(%rip), %rax
 2978      000000
 2979 223e 0FB600   		movzbl	(%rax), %eax
 2980 2241 3C20     		cmpb	$32, %al
 2981 2243 0F856901 		jne	.L156
 2981      0000
 2982              	.LBB33:
 654:main.c        **** 						const char *p;
 655:main.c        **** 						const char quoteChar = *++ptr;
 2983              		.loc 1 655 0
 2984 2249 488B0500 		movq	ptr(%rip), %rax
 2984      000000
 2985 2250 4883C001 		addq	$1, %rax
 2986 2254 48890500 		movq	%rax, ptr(%rip)
 2986      000000
 2987 225b 488B0500 		movq	ptr(%rip), %rax
 2987      000000
 2988 2262 0FB600   		movzbl	(%rax), %eax
 2989 2265 888511FF 		movb	%al, -239(%rbp)
 2989      FFFF
 656:main.c        **** 						CHECK_STATUS(
 2990              		.loc 1 656 0
 2991 226b 80BD11FF 		cmpb	$34, -239(%rbp)
 2991      FFFF22
 2992 2272 7418     		je	.L159
 2993              		.loc 1 656 0 is_stmt 0 discriminator 1
 2994 2274 80BD11FF 		cmpb	$39, -239(%rbp)
 2994      FFFF27
 2995 227b 740F     		je	.L159
 2996              		.loc 1 656 0 discriminator 2
 2997 227d C78514FF 		movl	$5, -236(%rbp)
 2997      FFFF0500 
 2997      0000
 2998 2287 E9BE0C00 		jmp	.L145
 2998      00
 2999              	.L159:
 657:main.c        **** 							(quoteChar != '"' && quoteChar != '\''),
 658:main.c        **** 							FLP_ILL_CHAR, cleanup);
 659:main.c        **** 
 660:main.c        **** 					// Get the file to write bytes to:
 661:main.c        **** 						ptr++;
 3000              		.loc 1 661 0 is_stmt 1
 3001 228c 488B0500 		movq	ptr(%rip), %rax
 3001      000000
 3002 2293 4883C001 		addq	$1, %rax
 3003 2297 48890500 		movq	%rax, ptr(%rip)
 3003      000000
 662:main.c        **** 						p = ptr;
 3004              		.loc 1 662 0
 3005 229e 488B0500 		movq	ptr(%rip), %rax
 3005      000000
 3006 22a5 48898560 		movq	%rax, -160(%rbp)
 3006      FFFFFF
 663:main.c        **** 						while ( *p != quoteChar && *p != '\0' ) {
 3007              		.loc 1 663 0
 3008 22ac EB08     		jmp	.L160
 3009              	.L162:
 664:main.c        **** 							p++;
 3010              		.loc 1 664 0
 3011 22ae 48838560 		addq	$1, -160(%rbp)
 3011      FFFFFF01 
 3012              	.L160:
 663:main.c        **** 						while ( *p != quoteChar && *p != '\0' ) {
 3013              		.loc 1 663 0
 3014 22b6 488B8560 		movq	-160(%rbp), %rax
 3014      FFFFFF
 3015 22bd 0FB600   		movzbl	(%rax), %eax
 3016 22c0 3A8511FF 		cmpb	-239(%rbp), %al
 3016      FFFF
 3017 22c6 740E     		je	.L161
 663:main.c        **** 						while ( *p != quoteChar && *p != '\0' ) {
 3018              		.loc 1 663 0 is_stmt 0 discriminator 1
 3019 22c8 488B8560 		movq	-160(%rbp), %rax
 3019      FFFFFF
 3020 22cf 0FB600   		movzbl	(%rax), %eax
 3021 22d2 84C0     		testb	%al, %al
 3022 22d4 75D8     		jne	.L162
 3023              	.L161:
 665:main.c        **** 						}
 666:main.c        **** 						CHECK_STATUS(*p == '\0', FLP_UNTERM_STRING, cleanup);
 3024              		.loc 1 666 0 is_stmt 1
 3025 22d6 488B8560 		movq	-160(%rbp), %rax
 3025      FFFFFF
 3026 22dd 0FB600   		movzbl	(%rax), %eax
 3027 22e0 84C0     		testb	%al, %al
 3028 22e2 750F     		jne	.L163
 3029              		.loc 1 666 0 is_stmt 0 discriminator 1
 3030 22e4 C78514FF 		movl	$6, -236(%rbp)
 3030      FFFF0600 
 3030      0000
 3031 22ee E9570C00 		jmp	.L145
 3031      00
 3032              	.L163:
 667:main.c        **** 						fileName = malloc((size_t)(p - ptr + 1));
 3033              		.loc 1 667 0 is_stmt 1
 3034 22f3 488B8560 		movq	-160(%rbp), %rax
 3034      FFFFFF
 3035 22fa 488B1500 		movq	ptr(%rip), %rdx
 3035      000000
 3036 2301 4829D0   		subq	%rdx, %rax
 3037 2304 4883C001 		addq	$1, %rax
 3038 2308 4889C7   		movq	%rax, %rdi
 3039 230b E8000000 		call	malloc
 3039      00
 3040 2310 48898550 		movq	%rax, -176(%rbp)
 3040      FFFFFF
 668:main.c        **** 						CHECK_STATUS(!fileName, FLP_NO_MEMORY, cleanup);
 3041              		.loc 1 668 0
 3042 2317 4883BD50 		cmpq	$0, -176(%rbp)
 3042      FFFFFF00 
 3043 231f 750F     		jne	.L164
 3044              		.loc 1 668 0 is_stmt 0 discriminator 1
 3045 2321 C78514FF 		movl	$7, -236(%rbp)
 3045      FFFF0700 
 3045      0000
 3046 232b E91A0C00 		jmp	.L145
 3046      00
 3047              	.L164:
 669:main.c        **** 						CHECK_STATUS(p - ptr == 0, FLP_EMPTY_STRING, cleanup);
 3048              		.loc 1 669 0 is_stmt 1
 3049 2330 488B8560 		movq	-160(%rbp), %rax
 3049      FFFFFF
 3050 2337 488B1500 		movq	ptr(%rip), %rdx
 3050      000000
 3051 233e 4839D0   		cmpq	%rdx, %rax
 3052 2341 750F     		jne	.L165
 3053              		.loc 1 669 0 is_stmt 0 discriminator 1
 3054 2343 C78514FF 		movl	$8, -236(%rbp)
 3054      FFFF0800 
 3054      0000
 3055 234d E9F80B00 		jmp	.L145
 3055      00
 3056              	.L165:
 670:main.c        **** 						strncpy(fileName, ptr, (size_t)(p - ptr));
 3057              		.loc 1 670 0 is_stmt 1
 3058 2352 488B8560 		movq	-160(%rbp), %rax
 3058      FFFFFF
 3059 2359 488B1500 		movq	ptr(%rip), %rdx
 3059      000000
 3060 2360 4829D0   		subq	%rdx, %rax
 3061 2363 4889C2   		movq	%rax, %rdx
 3062 2366 488B0D00 		movq	ptr(%rip), %rcx
 3062      000000
 3063 236d 488B8550 		movq	-176(%rbp), %rax
 3063      FFFFFF
 3064 2374 4889CE   		movq	%rcx, %rsi
 3065 2377 4889C7   		movq	%rax, %rdi
 3066 237a E8000000 		call	strncpy
 3066      00
 671:main.c        **** 						fileName[p - ptr] = '\0';
 3067              		.loc 1 671 0
 3068 237f 488B8560 		movq	-160(%rbp), %rax
 3068      FFFFFF
 3069 2386 488B1500 		movq	ptr(%rip), %rdx
 3069      000000
 3070 238d 4829D0   		subq	%rdx, %rax
 3071 2390 4889C2   		movq	%rax, %rdx
 3072 2393 488B8550 		movq	-176(%rbp), %rax
 3072      FFFFFF
 3073 239a 4801D0   		addq	%rdx, %rax
 3074 239d C60000   		movb	$0, (%rax)
 672:main.c        **** 						ptr = p + 1;
 3075              		.loc 1 672 0
 3076 23a0 488B8560 		movq	-160(%rbp), %rax
 3076      FFFFFF
 3077 23a7 4883C001 		addq	$1, %rax
 3078 23ab 48890500 		movq	%rax, ptr(%rip)
 3078      000000
 3079              	.L156:
 3080              	.LBE33:
 673:main.c        **** 					}
 674:main.c        **** 				}
 675:main.c        **** 				if ( fileName ) {
 3081              		.loc 1 675 0
 3082 23b2 4883BD50 		cmpq	$0, -176(%rbp)
 3082      FFFFFF00 
 3083 23ba 0F84EA01 		je	.L166
 3083      0000
 3084              	.LBB34:
 676:main.c        **** 					uint16 checksum = 0x0000;
 3085              		.loc 1 676 0
 3086 23c0 66C78538 		movw	$0, -200(%rbp)
 3086      FFFFFF00 
 3086      00
 677:main.c        **** 
 678:main.c        **** 				// Open file for writing
 679:main.c        **** 					file = fopen(fileName, "wb");
 3087              		.loc 1 679 0
 3088 23c9 488B8550 		movq	-176(%rbp), %rax
 3088      FFFFFF
 3089 23d0 BE000000 		movl	$.LC28, %esi
 3089      00
 3090 23d5 4889C7   		movq	%rax, %rdi
 3091 23d8 E8000000 		call	fopen
 3091      00
 3092 23dd 48898558 		movq	%rax, -168(%rbp)
 3092      FFFFFF
 680:main.c        **** 					CHECK_STATUS(!file, FLP_CANNOT_SAVE, cleanup);
 3093              		.loc 1 680 0
 3094 23e4 4883BD58 		cmpq	$0, -168(%rbp)
 3094      FFFFFF00 
 3095 23ec 750F     		jne	.L167
 3096              		.loc 1 680 0 is_stmt 0 discriminator 1
 3097 23ee C78514FF 		movl	$11, -236(%rbp)
 3097      FFFF0B00 
 3097      0000
 3098 23f8 E94D0B00 		jmp	.L145
 3098      00
 3099              	.L167:
 681:main.c        **** 					free(fileName);
 3100              		.loc 1 681 0 is_stmt 1
 3101 23fd 488B8550 		movq	-176(%rbp), %rax
 3101      FFFFFF
 3102 2404 4889C7   		movq	%rax, %rdi
 3103 2407 E8000000 		call	free
 3103      00
 682:main.c        **** 					fileName = NULL;
 3104              		.loc 1 682 0
 3105 240c 48C78550 		movq	$0, -176(%rbp)
 3105      FFFFFF00 
 3105      000000
 683:main.c        **** 					
 684:main.c        **** 				#ifdef WIN32
 685:main.c        **** 					QueryPerformanceCounter(&tvStart);
 686:main.c        **** 					status = doRead(handle, (uint8)chan, length, file, &checksum, error);
 687:main.c        **** 					QueryPerformanceCounter(&tvEnd);
 688:main.c        **** 					totalTime = (double)(tvEnd.QuadPart - tvStart.QuadPart);
 689:main.c        **** 					totalTime /= freq.QuadPart;
 690:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 691:main.c        **** 				#else
 692:main.c        **** 					gettimeofday(&tvStart, NULL);
 3106              		.loc 1 692 0
 3107 2417 488D45B0 		leaq	-80(%rbp), %rax
 3108 241b BE000000 		movl	$0, %esi
 3108      00
 3109 2420 4889C7   		movq	%rax, %rdi
 3110 2423 E8000000 		call	gettimeofday
 3110      00
 693:main.c        **** 					status = doRead(handle, (uint8)chan, length, file, &checksum, error);
 3111              		.loc 1 693 0
 3112 2428 8B8530FF 		movl	-208(%rbp), %eax
 3112      FFFF
 3113 242e 0FB6F0   		movzbl	%al, %esi
 3114 2431 4C8B85F8 		movq	-264(%rbp), %r8
 3114      FEFFFF
 3115 2438 488DBD38 		leaq	-200(%rbp), %rdi
 3115      FFFFFF
 3116 243f 488B8D58 		movq	-168(%rbp), %rcx
 3116      FFFFFF
 3117 2446 8B9518FF 		movl	-232(%rbp), %edx
 3117      FFFF
 3118 244c 488B8508 		movq	-248(%rbp), %rax
 3118      FFFFFF
 3119 2453 4D89C1   		movq	%r8, %r9
 3120 2456 4989F8   		movq	%rdi, %r8
 3121 2459 4889C7   		movq	%rax, %rdi
 3122 245c E8A7F6FF 		call	doRead
 3122      FF
 3123 2461 898528FF 		movl	%eax, -216(%rbp)
 3123      FFFF
 694:main.c        **** 					gettimeofday(&tvEnd, NULL);
 3124              		.loc 1 694 0
 3125 2467 488D45C0 		leaq	-64(%rbp), %rax
 3126 246b BE000000 		movl	$0, %esi
 3126      00
 3127 2470 4889C7   		movq	%rax, %rdi
 3128 2473 E8000000 		call	gettimeofday
 3128      00
 695:main.c        **** 					startTime = tvStart.tv_sec;
 3129              		.loc 1 695 0
 3130 2478 488B45B0 		movq	-80(%rbp), %rax
 3131 247c 48894588 		movq	%rax, -120(%rbp)
 696:main.c        **** 					startTime *= 1000000;
 3132              		.loc 1 696 0
 3133 2480 488B4588 		movq	-120(%rbp), %rax
 3134 2484 4869C040 		imulq	$1000000, %rax, %rax
 3134      420F00
 3135 248b 48894588 		movq	%rax, -120(%rbp)
 697:main.c        **** 					startTime += tvStart.tv_usec;
 3136              		.loc 1 697 0
 3137 248f 488B45B8 		movq	-72(%rbp), %rax
 3138 2493 48014588 		addq	%rax, -120(%rbp)
 698:main.c        **** 					endTime = tvEnd.tv_sec;
 3139              		.loc 1 698 0
 3140 2497 488B45C0 		movq	-64(%rbp), %rax
 3141 249b 48894590 		movq	%rax, -112(%rbp)
 699:main.c        **** 					endTime *= 1000000;
 3142              		.loc 1 699 0
 3143 249f 488B4590 		movq	-112(%rbp), %rax
 3144 24a3 4869C040 		imulq	$1000000, %rax, %rax
 3144      420F00
 3145 24aa 48894590 		movq	%rax, -112(%rbp)
 700:main.c        **** 					endTime += tvEnd.tv_usec;
 3146              		.loc 1 700 0
 3147 24ae 488B45C8 		movq	-56(%rbp), %rax
 3148 24b2 48014590 		addq	%rax, -112(%rbp)
 701:main.c        **** 					totalTime = (double)(endTime - startTime);
 3149              		.loc 1 701 0
 3150 24b6 488B4590 		movq	-112(%rbp), %rax
 3151 24ba 482B4588 		subq	-120(%rbp), %rax
 3152 24be 660FEFC0 		pxor	%xmm0, %xmm0
 3153 24c2 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 3153      C0
 3154 24c7 F20F1145 		movsd	%xmm0, -104(%rbp)
 3154      98
 702:main.c        **** 					totalTime /= 1000000;  // convert from uS to S.
 3155              		.loc 1 702 0
 3156 24cc F20F1045 		movsd	-104(%rbp), %xmm0
 3156      98
 3157 24d1 F20F100D 		movsd	.LC29(%rip), %xmm1
 3157      00000000 
 3158 24d9 F20F5EC1 		divsd	%xmm1, %xmm0
 3159 24dd F20F1145 		movsd	%xmm0, -104(%rbp)
 3159      98
 703:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 3160              		.loc 1 703 0
 3161 24e2 8B8518FF 		movl	-232(%rbp), %eax
 3161      FFFF
 3162 24e8 4885C0   		testq	%rax, %rax
 3163 24eb 780B     		js	.L169
 3164 24ed 660FEFC0 		pxor	%xmm0, %xmm0
 3165 24f1 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 3165      C0
 3166 24f6 EB19     		jmp	.L170
 3167              	.L169:
 3168 24f8 4889C2   		movq	%rax, %rdx
 3169 24fb 48D1EA   		shrq	%rdx
 3170 24fe 83E001   		andl	$1, %eax
 3171 2501 4809C2   		orq	%rax, %rdx
 3172 2504 660FEFC0 		pxor	%xmm0, %xmm0
 3173 2508 F2480F2A 		cvtsi2sdq	%rdx, %xmm0
 3173      C2
 3174 250d F20F58C0 		addsd	%xmm0, %xmm0
 3175              	.L170:
 3176 2511 F20F1055 		movsd	-104(%rbp), %xmm2
 3176      98
 3177 2516 F20F100D 		movsd	.LC30(%rip), %xmm1
 3177      00000000 
 3178 251e F20F59CA 		mulsd	%xmm2, %xmm1
 3179 2522 F20F5EC1 		divsd	%xmm1, %xmm0
 3180 2526 F20F1145 		movsd	%xmm0, -96(%rbp)
 3180      A0
 704:main.c        **** 				#endif
 705:main.c        **** 					if ( enableBenchmarking ) {
 3181              		.loc 1 705 0
 3182 252b 0FB60500 		movzbl	enableBenchmarking(%rip), %eax
 3182      000000
 3183 2532 84C0     		testb	%al, %al
 3184 2534 743A     		je	.L171
 706:main.c        **** 						printf(
 3185              		.loc 1 706 0
 3186 2536 0FB78538 		movzwl	-200(%rbp), %eax
 3186      FFFFFF
 3187 253d 0FB7D0   		movzwl	%ax, %edx
 3188 2540 488B75A0 		movq	-96(%rbp), %rsi
 3189 2544 8B8D30FF 		movl	-208(%rbp), %ecx
 3189      FFFF
 3190 254a 8B8518FF 		movl	-232(%rbp), %eax
 3190      FFFF
 3191 2550 4889B5F0 		movq	%rsi, -272(%rbp)
 3191      FEFFFF
 3192 2557 F20F1085 		movsd	-272(%rbp), %xmm0
 3192      F0FEFFFF 
 3193 255f 89C6     		movl	%eax, %esi
 3194 2561 BF000000 		movl	$.LC31, %edi
 3194      00
 3195 2566 B8010000 		movl	$1, %eax
 3195      00
 3196 256b E8000000 		call	printf
 3196      00
 3197              	.L171:
 707:main.c        **** 							"Read %d bytes (checksum 0x%04X) from channel %d at %f MiB/s\n",
 708:main.c        **** 							length, checksum, chan, speed);
 709:main.c        **** 					}
 710:main.c        **** 					CHECK_STATUS(status, status, cleanup);
 3198              		.loc 1 710 0
 3199 2570 83BD28FF 		cmpl	$0, -216(%rbp)
 3199      FFFF00
 3200 2577 7412     		je	.L172
 3201              		.loc 1 710 0 is_stmt 0 discriminator 1
 3202 2579 8B8528FF 		movl	-216(%rbp), %eax
 3202      FFFF
 3203 257f 898514FF 		movl	%eax, -236(%rbp)
 3203      FFFF
 3204 2585 90       		nop
 3205              	.LBE34:
 633:main.c        **** 
 3206              		.loc 1 633 0 is_stmt 1 discriminator 1
 3207 2586 E9BF0900 		jmp	.L145
 3207      00
 3208              	.L172:
 3209              	.LBB35:
 711:main.c        **** 
 712:main.c        **** 				// Close the file
 713:main.c        **** 					fclose(file);
 3210              		.loc 1 713 0
 3211 258b 488B8558 		movq	-168(%rbp), %rax
 3211      FFFFFF
 3212 2592 4889C7   		movq	%rax, %rdi
 3213 2595 E8000000 		call	fclose
 3213      00
 714:main.c        **** 					file = NULL;
 3214              		.loc 1 714 0
 3215 259a 48C78558 		movq	$0, -168(%rbp)
 3215      FFFFFF00 
 3215      000000
 3216              	.LBE35:
 715:main.c        **** 				} else {
 716:main.c        **** 					size_t oldLength = dataFromFPGA.length;
 717:main.c        **** 					bStatus = bufAppendConst(&dataFromFPGA, 0x00, length, error);
 718:main.c        **** 					CHECK_STATUS(bStatus, FLP_LIBERR, cleanup);
 719:main.c        **** 				#ifdef WIN32
 720:main.c        **** 					QueryPerformanceCounter(&tvStart);
 721:main.c        **** 					fStatus = flReadChannel(handle, (uint8)chan, length, dataFromFPGA.data + oldLength, error);
 722:main.c        **** 					QueryPerformanceCounter(&tvEnd);
 723:main.c        **** 					totalTime = (double)(tvEnd.QuadPart - tvStart.QuadPart);
 724:main.c        **** 					totalTime /= freq.QuadPart;
 725:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 726:main.c        **** 				#else
 727:main.c        **** 					gettimeofday(&tvStart, NULL);
 728:main.c        **** 					fStatus = flReadChannel(handle, (uint8)chan, length, dataFromFPGA.data + oldLength, error);
 729:main.c        **** 					gettimeofday(&tvEnd, NULL);
 730:main.c        **** 					startTime = tvStart.tv_sec;
 731:main.c        **** 					startTime *= 1000000;
 732:main.c        **** 					startTime += tvStart.tv_usec;
 733:main.c        **** 					endTime = tvEnd.tv_sec;
 734:main.c        **** 					endTime *= 1000000;
 735:main.c        **** 					endTime += tvEnd.tv_usec;
 736:main.c        **** 					totalTime = (double)(endTime - startTime);
 737:main.c        **** 					totalTime /= 1000000;  // convert from uS to S.
 738:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 739:main.c        **** 				#endif
 740:main.c        **** 					if ( enableBenchmarking ) {
 741:main.c        **** 						printf(
 742:main.c        **** 							"Read %d bytes (checksum 0x%04X) from channel %d at %f MiB/s\n",
 743:main.c        **** 							length, calcChecksum(dataFromFPGA.data + oldLength, length), chan, speed);
 744:main.c        **** 					}
 745:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 746:main.c        **** 				}
 747:main.c        **** 				break;
 3217              		.loc 1 747 0
 3218 25a5 E95B0900 		jmp	.L222
 3218      00
 3219              	.L166:
 3220              	.LBB36:
 716:main.c        **** 					bStatus = bufAppendConst(&dataFromFPGA, 0x00, length, error);
 3221              		.loc 1 716 0
 3222 25aa 488B45D8 		movq	-40(%rbp), %rax
 3223 25ae 488945A8 		movq	%rax, -88(%rbp)
 717:main.c        **** 					CHECK_STATUS(bStatus, FLP_LIBERR, cleanup);
 3224              		.loc 1 717 0
 3225 25b2 8B9518FF 		movl	-232(%rbp), %edx
 3225      FFFF
 3226 25b8 488B8DF8 		movq	-264(%rbp), %rcx
 3226      FEFFFF
 3227 25bf 488D45D0 		leaq	-48(%rbp), %rax
 3228 25c3 BE000000 		movl	$0, %esi
 3228      00
 3229 25c8 4889C7   		movq	%rax, %rdi
 3230 25cb E8000000 		call	bufAppendConst
 3230      00
 3231 25d0 898520FF 		movl	%eax, -224(%rbp)
 3231      FFFF
 718:main.c        **** 				#ifdef WIN32
 3232              		.loc 1 718 0
 3233 25d6 83BD20FF 		cmpl	$0, -224(%rbp)
 3233      FFFF00
 3234 25dd 740F     		je	.L174
 718:main.c        **** 				#ifdef WIN32
 3235              		.loc 1 718 0 is_stmt 0 discriminator 1
 3236 25df C78514FF 		movl	$1, -236(%rbp)
 3236      FFFF0100 
 3236      0000
 3237 25e9 E95C0900 		jmp	.L145
 3237      00
 3238              	.L174:
 727:main.c        **** 					fStatus = flReadChannel(handle, (uint8)chan, length, dataFromFPGA.data + oldLength, error);
 3239              		.loc 1 727 0 is_stmt 1
 3240 25ee 488D45B0 		leaq	-80(%rbp), %rax
 3241 25f2 BE000000 		movl	$0, %esi
 3241      00
 3242 25f7 4889C7   		movq	%rax, %rdi
 3243 25fa E8000000 		call	gettimeofday
 3243      00
 728:main.c        **** 					gettimeofday(&tvEnd, NULL);
 3244              		.loc 1 728 0
 3245 25ff 488B55D0 		movq	-48(%rbp), %rdx
 3246 2603 488B45A8 		movq	-88(%rbp), %rax
 3247 2607 488D0C02 		leaq	(%rdx,%rax), %rcx
 3248 260b 8B9518FF 		movl	-232(%rbp), %edx
 3248      FFFF
 3249 2611 8B8530FF 		movl	-208(%rbp), %eax
 3249      FFFF
 3250 2617 0FB6F0   		movzbl	%al, %esi
 3251 261a 488BBDF8 		movq	-264(%rbp), %rdi
 3251      FEFFFF
 3252 2621 488B8508 		movq	-248(%rbp), %rax
 3252      FFFFFF
 3253 2628 4989F8   		movq	%rdi, %r8
 3254 262b 4889C7   		movq	%rax, %rdi
 3255 262e E8000000 		call	flReadChannel
 3255      00
 3256 2633 898524FF 		movl	%eax, -220(%rbp)
 3256      FFFF
 729:main.c        **** 					startTime = tvStart.tv_sec;
 3257              		.loc 1 729 0
 3258 2639 488D45C0 		leaq	-64(%rbp), %rax
 3259 263d BE000000 		movl	$0, %esi
 3259      00
 3260 2642 4889C7   		movq	%rax, %rdi
 3261 2645 E8000000 		call	gettimeofday
 3261      00
 730:main.c        **** 					startTime *= 1000000;
 3262              		.loc 1 730 0
 3263 264a 488B45B0 		movq	-80(%rbp), %rax
 3264 264e 48894588 		movq	%rax, -120(%rbp)
 731:main.c        **** 					startTime += tvStart.tv_usec;
 3265              		.loc 1 731 0
 3266 2652 488B4588 		movq	-120(%rbp), %rax
 3267 2656 4869C040 		imulq	$1000000, %rax, %rax
 3267      420F00
 3268 265d 48894588 		movq	%rax, -120(%rbp)
 732:main.c        **** 					endTime = tvEnd.tv_sec;
 3269              		.loc 1 732 0
 3270 2661 488B45B8 		movq	-72(%rbp), %rax
 3271 2665 48014588 		addq	%rax, -120(%rbp)
 733:main.c        **** 					endTime *= 1000000;
 3272              		.loc 1 733 0
 3273 2669 488B45C0 		movq	-64(%rbp), %rax
 3274 266d 48894590 		movq	%rax, -112(%rbp)
 734:main.c        **** 					endTime += tvEnd.tv_usec;
 3275              		.loc 1 734 0
 3276 2671 488B4590 		movq	-112(%rbp), %rax
 3277 2675 4869C040 		imulq	$1000000, %rax, %rax
 3277      420F00
 3278 267c 48894590 		movq	%rax, -112(%rbp)
 735:main.c        **** 					totalTime = (double)(endTime - startTime);
 3279              		.loc 1 735 0
 3280 2680 488B45C8 		movq	-56(%rbp), %rax
 3281 2684 48014590 		addq	%rax, -112(%rbp)
 736:main.c        **** 					totalTime /= 1000000;  // convert from uS to S.
 3282              		.loc 1 736 0
 3283 2688 488B4590 		movq	-112(%rbp), %rax
 3284 268c 482B4588 		subq	-120(%rbp), %rax
 3285 2690 660FEFC0 		pxor	%xmm0, %xmm0
 3286 2694 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 3286      C0
 3287 2699 F20F1145 		movsd	%xmm0, -104(%rbp)
 3287      98
 737:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 3288              		.loc 1 737 0
 3289 269e F20F1045 		movsd	-104(%rbp), %xmm0
 3289      98
 3290 26a3 F20F100D 		movsd	.LC29(%rip), %xmm1
 3290      00000000 
 3291 26ab F20F5EC1 		divsd	%xmm1, %xmm0
 3292 26af F20F1145 		movsd	%xmm0, -104(%rbp)
 3292      98
 738:main.c        **** 				#endif
 3293              		.loc 1 738 0
 3294 26b4 8B8518FF 		movl	-232(%rbp), %eax
 3294      FFFF
 3295 26ba 4885C0   		testq	%rax, %rax
 3296 26bd 780B     		js	.L175
 3297 26bf 660FEFC0 		pxor	%xmm0, %xmm0
 3298 26c3 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 3298      C0
 3299 26c8 EB19     		jmp	.L176
 3300              	.L175:
 3301 26ca 4889C2   		movq	%rax, %rdx
 3302 26cd 48D1EA   		shrq	%rdx
 3303 26d0 83E001   		andl	$1, %eax
 3304 26d3 4809C2   		orq	%rax, %rdx
 3305 26d6 660FEFC0 		pxor	%xmm0, %xmm0
 3306 26da F2480F2A 		cvtsi2sdq	%rdx, %xmm0
 3306      C2
 3307 26df F20F58C0 		addsd	%xmm0, %xmm0
 3308              	.L176:
 3309 26e3 F20F1055 		movsd	-104(%rbp), %xmm2
 3309      98
 3310 26e8 F20F100D 		movsd	.LC30(%rip), %xmm1
 3310      00000000 
 3311 26f0 F20F59CA 		mulsd	%xmm2, %xmm1
 3312 26f4 F20F5EC1 		divsd	%xmm1, %xmm0
 3313 26f8 F20F1145 		movsd	%xmm0, -96(%rbp)
 3313      A0
 740:main.c        **** 						printf(
 3314              		.loc 1 740 0
 3315 26fd 0FB60500 		movzbl	enableBenchmarking(%rip), %eax
 3315      000000
 3316 2704 84C0     		testb	%al, %al
 3317 2706 744F     		je	.L177
 743:main.c        **** 					}
 3318              		.loc 1 743 0
 3319 2708 8B8518FF 		movl	-232(%rbp), %eax
 3319      FFFF
 3320 270e 488B4DD0 		movq	-48(%rbp), %rcx
 3321 2712 488B55A8 		movq	-88(%rbp), %rdx
 3322 2716 4801CA   		addq	%rcx, %rdx
 3323 2719 4889C6   		movq	%rax, %rsi
 3324 271c 4889D7   		movq	%rdx, %rdi
 3325 271f E88BF2FF 		call	calcChecksum
 3325      FF
 741:main.c        **** 							"Read %d bytes (checksum 0x%04X) from channel %d at %f MiB/s\n",
 3326              		.loc 1 741 0
 3327 2724 0FB7D0   		movzwl	%ax, %edx
 3328 2727 488B75A0 		movq	-96(%rbp), %rsi
 3329 272b 8B8D30FF 		movl	-208(%rbp), %ecx
 3329      FFFF
 3330 2731 8B8518FF 		movl	-232(%rbp), %eax
 3330      FFFF
 3331 2737 4889B5F0 		movq	%rsi, -272(%rbp)
 3331      FEFFFF
 3332 273e F20F1085 		movsd	-272(%rbp), %xmm0
 3332      F0FEFFFF 
 3333 2746 89C6     		movl	%eax, %esi
 3334 2748 BF000000 		movl	$.LC31, %edi
 3334      00
 3335 274d B8010000 		movl	$1, %eax
 3335      00
 3336 2752 E8000000 		call	printf
 3336      00
 3337              	.L177:
 745:main.c        **** 				}
 3338              		.loc 1 745 0
 3339 2757 83BD24FF 		cmpl	$0, -220(%rbp)
 3339      FFFF00
 3340 275e 0F84A107 		je	.L222
 3340      0000
 745:main.c        **** 				}
 3341              		.loc 1 745 0 is_stmt 0 discriminator 1
 3342 2764 C78514FF 		movl	$1, -236(%rbp)
 3342      FFFF0100 
 3342      0000
 3343 276e 90       		nop
 3344 276f E9D60700 		jmp	.L145
 3344      00
 3345              	.L150:
 3346              	.LBE36:
 3347              	.LBE32:
 3348              	.LBB37:
 748:main.c        **** 			}
 749:main.c        **** 			case 'w':{
 750:main.c        **** 				unsigned long int chan;
 751:main.c        **** 				size_t length = 1, i;
 3349              		.loc 1 751 0 is_stmt 1
 3350 2774 48C78538 		movq	$1, -200(%rbp)
 3350      FFFFFF01 
 3350      000000
 752:main.c        **** 				char *end, ch;
 753:main.c        **** 				const char *p;
 754:main.c        **** 				ptr++;
 3351              		.loc 1 754 0
 3352 277f 488B0500 		movq	ptr(%rip), %rax
 3352      000000
 3353 2786 4883C001 		addq	$1, %rax
 3354 278a 48890500 		movq	%rax, ptr(%rip)
 3354      000000
 755:main.c        **** 
 756:main.c        **** 			// Get the channel to be written:
 757:main.c        **** 				errno = 0;
 3355              		.loc 1 757 0
 3356 2791 E8000000 		call	__errno_location
 3356      00
 3357 2796 C7000000 		movl	$0, (%rax)
 3357      0000
 758:main.c        **** 				chan = strtoul(ptr, &end, 16);
 3358              		.loc 1 758 0
 3359 279c 488B0500 		movq	ptr(%rip), %rax
 3359      000000
 3360 27a3 488D8D40 		leaq	-192(%rbp), %rcx
 3360      FFFFFF
 3361 27aa BA100000 		movl	$16, %edx
 3361      00
 3362 27af 4889CE   		movq	%rcx, %rsi
 3363 27b2 4889C7   		movq	%rax, %rdi
 3364 27b5 E8000000 		call	strtoul
 3364      00
 3365 27ba 48894580 		movq	%rax, -128(%rbp)
 759:main.c        **** 				CHECK_STATUS(errno, FLP_BAD_HEX, cleanup);
 3366              		.loc 1 759 0
 3367 27be E8000000 		call	__errno_location
 3367      00
 3368 27c3 8B00     		movl	(%rax), %eax
 3369 27c5 85C0     		testl	%eax, %eax
 3370 27c7 740F     		je	.L179
 3371              		.loc 1 759 0 is_stmt 0 discriminator 1
 3372 27c9 C78514FF 		movl	$2, -236(%rbp)
 3372      FFFF0200 
 3372      0000
 3373 27d3 E9720700 		jmp	.L145
 3373      00
 3374              	.L179:
 760:main.c        **** 
 761:main.c        **** 			// Ensure that it's 0-127
 762:main.c        **** 				CHECK_STATUS(chan > 127, FLP_CHAN_RANGE, cleanup);
 3375              		.loc 1 762 0 is_stmt 1
 3376 27d8 48837D80 		cmpq	$127, -128(%rbp)
 3376      7F
 3377 27dd 760F     		jbe	.L181
 3378              		.loc 1 762 0 is_stmt 0 discriminator 1
 3379 27df C78514FF 		movl	$3, -236(%rbp)
 3379      FFFF0300 
 3379      0000
 3380 27e9 E95C0700 		jmp	.L145
 3380      00
 3381              	.L181:
 763:main.c        **** 				ptr = end;
 3382              		.loc 1 763 0 is_stmt 1
 3383 27ee 488B8540 		movq	-192(%rbp), %rax
 3383      FFFFFF
 3384 27f5 48890500 		movq	%rax, ptr(%rip)
 3384      000000
 764:main.c        **** 
 765:main.c        **** 			// There must be a space now:
 766:main.c        **** 				CHECK_STATUS(*ptr != ' ', FLP_ILL_CHAR, cleanup);
 3385              		.loc 1 766 0
 3386 27fc 488B0500 		movq	ptr(%rip), %rax
 3386      000000
 3387 2803 0FB600   		movzbl	(%rax), %eax
 3388 2806 3C20     		cmpb	$32, %al
 3389 2808 740F     		je	.L182
 3390              		.loc 1 766 0 is_stmt 0 discriminator 1
 3391 280a C78514FF 		movl	$5, -236(%rbp)
 3391      FFFF0500 
 3391      0000
 3392 2814 E9310700 		jmp	.L145
 3392      00
 3393              	.L182:
 767:main.c        **** 
 768:main.c        **** 			// Now either a quote or a hex digit
 769:main.c        **** 				ch = *++ptr;
 3394              		.loc 1 769 0 is_stmt 1
 3395 2819 488B0500 		movq	ptr(%rip), %rax
 3395      000000
 3396 2820 4883C001 		addq	$1, %rax
 3397 2824 48890500 		movq	%rax, ptr(%rip)
 3397      000000
 3398 282b 488B0500 		movq	ptr(%rip), %rax
 3398      000000
 3399 2832 0FB600   		movzbl	(%rax), %eax
 3400 2835 888510FF 		movb	%al, -240(%rbp)
 3400      FFFF
 770:main.c        **** 				if ( ch == '"' || ch == '\'' ) {
 3401              		.loc 1 770 0
 3402 283b 80BD10FF 		cmpb	$34, -240(%rbp)
 3402      FFFF22
 3403 2842 740D     		je	.L183
 3404              		.loc 1 770 0 is_stmt 0 discriminator 1
 3405 2844 80BD10FF 		cmpb	$39, -240(%rbp)
 3405      FFFF27
 3406 284b 0F851203 		jne	.L184
 3406      0000
 3407              	.L183:
 3408              	.LBB38:
 771:main.c        **** 					uint16 checksum = 0x0000;
 3409              		.loc 1 771 0 is_stmt 1
 3410 2851 66C78512 		movw	$0, -238(%rbp)
 3410      FFFFFF00 
 3410      00
 772:main.c        **** 
 773:main.c        **** 				// Get the file to read bytes from:
 774:main.c        **** 					ptr++;
 3411              		.loc 1 774 0
 3412 285a 488B0500 		movq	ptr(%rip), %rax
 3412      000000
 3413 2861 4883C001 		addq	$1, %rax
 3414 2865 48890500 		movq	%rax, ptr(%rip)
 3414      000000
 775:main.c        **** 					p = ptr;
 3415              		.loc 1 775 0
 3416 286c 488B0500 		movq	ptr(%rip), %rax
 3416      000000
 3417 2873 48898570 		movq	%rax, -144(%rbp)
 3417      FFFFFF
 776:main.c        **** 					while ( *p != ch && *p != '\0' ) {
 3418              		.loc 1 776 0
 3419 287a EB08     		jmp	.L185
 3420              	.L187:
 777:main.c        **** 						p++;
 3421              		.loc 1 777 0
 3422 287c 48838570 		addq	$1, -144(%rbp)
 3422      FFFFFF01 
 3423              	.L185:
 776:main.c        **** 					while ( *p != ch && *p != '\0' ) {
 3424              		.loc 1 776 0
 3425 2884 488B8570 		movq	-144(%rbp), %rax
 3425      FFFFFF
 3426 288b 0FB600   		movzbl	(%rax), %eax
 3427 288e 3A8510FF 		cmpb	-240(%rbp), %al
 3427      FFFF
 3428 2894 740E     		je	.L186
 776:main.c        **** 					while ( *p != ch && *p != '\0' ) {
 3429              		.loc 1 776 0 is_stmt 0 discriminator 1
 3430 2896 488B8570 		movq	-144(%rbp), %rax
 3430      FFFFFF
 3431 289d 0FB600   		movzbl	(%rax), %eax
 3432 28a0 84C0     		testb	%al, %al
 3433 28a2 75D8     		jne	.L187
 3434              	.L186:
 778:main.c        **** 					}
 779:main.c        **** 					CHECK_STATUS(*p == '\0', FLP_UNTERM_STRING, cleanup);
 3435              		.loc 1 779 0 is_stmt 1
 3436 28a4 488B8570 		movq	-144(%rbp), %rax
 3436      FFFFFF
 3437 28ab 0FB600   		movzbl	(%rax), %eax
 3438 28ae 84C0     		testb	%al, %al
 3439 28b0 750F     		jne	.L188
 3440              		.loc 1 779 0 is_stmt 0 discriminator 1
 3441 28b2 C78514FF 		movl	$6, -236(%rbp)
 3441      FFFF0600 
 3441      0000
 3442 28bc E9890600 		jmp	.L145
 3442      00
 3443              	.L188:
 780:main.c        **** 					fileName = malloc((size_t)(p - ptr + 1));
 3444              		.loc 1 780 0 is_stmt 1
 3445 28c1 488B8570 		movq	-144(%rbp), %rax
 3445      FFFFFF
 3446 28c8 488B1500 		movq	ptr(%rip), %rdx
 3446      000000
 3447 28cf 4829D0   		subq	%rdx, %rax
 3448 28d2 4883C001 		addq	$1, %rax
 3449 28d6 4889C7   		movq	%rax, %rdi
 3450 28d9 E8000000 		call	malloc
 3450      00
 3451 28de 48898550 		movq	%rax, -176(%rbp)
 3451      FFFFFF
 781:main.c        **** 					CHECK_STATUS(!fileName, FLP_NO_MEMORY, cleanup);
 3452              		.loc 1 781 0
 3453 28e5 4883BD50 		cmpq	$0, -176(%rbp)
 3453      FFFFFF00 
 3454 28ed 750F     		jne	.L190
 3455              		.loc 1 781 0 is_stmt 0 discriminator 1
 3456 28ef C78514FF 		movl	$7, -236(%rbp)
 3456      FFFF0700 
 3456      0000
 3457 28f9 E9600200 		jmp	.L189
 3457      00
 3458              	.L190:
 782:main.c        **** 					CHECK_STATUS(p - ptr == 0, FLP_EMPTY_STRING, cleanup);
 3459              		.loc 1 782 0 is_stmt 1
 3460 28fe 488B8570 		movq	-144(%rbp), %rax
 3460      FFFFFF
 3461 2905 488B1500 		movq	ptr(%rip), %rdx
 3461      000000
 3462 290c 4839D0   		cmpq	%rdx, %rax
 3463 290f 750F     		jne	.L191
 3464              		.loc 1 782 0 is_stmt 0 discriminator 1
 3465 2911 C78514FF 		movl	$8, -236(%rbp)
 3465      FFFF0800 
 3465      0000
 3466 291b E93E0200 		jmp	.L189
 3466      00
 3467              	.L191:
 783:main.c        **** 					strncpy(fileName, ptr, (size_t)(p - ptr));
 3468              		.loc 1 783 0 is_stmt 1
 3469 2920 488B8570 		movq	-144(%rbp), %rax
 3469      FFFFFF
 3470 2927 488B1500 		movq	ptr(%rip), %rdx
 3470      000000
 3471 292e 4829D0   		subq	%rdx, %rax
 3472 2931 4889C2   		movq	%rax, %rdx
 3473 2934 488B0D00 		movq	ptr(%rip), %rcx
 3473      000000
 3474 293b 488B8550 		movq	-176(%rbp), %rax
 3474      FFFFFF
 3475 2942 4889CE   		movq	%rcx, %rsi
 3476 2945 4889C7   		movq	%rax, %rdi
 3477 2948 E8000000 		call	strncpy
 3477      00
 784:main.c        **** 					fileName[p - ptr] = '\0';
 3478              		.loc 1 784 0
 3479 294d 488B8570 		movq	-144(%rbp), %rax
 3479      FFFFFF
 3480 2954 488B1500 		movq	ptr(%rip), %rdx
 3480      000000
 3481 295b 4829D0   		subq	%rdx, %rax
 3482 295e 4889C2   		movq	%rax, %rdx
 3483 2961 488B8550 		movq	-176(%rbp), %rax
 3483      FFFFFF
 3484 2968 4801D0   		addq	%rdx, %rax
 3485 296b C60000   		movb	$0, (%rax)
 785:main.c        **** 				ptr = p + 1;  // skip over closing quote
 3486              		.loc 1 785 0
 3487 296e 488B8570 		movq	-144(%rbp), %rax
 3487      FFFFFF
 3488 2975 4883C001 		addq	$1, %rax
 3489 2979 48890500 		movq	%rax, ptr(%rip)
 3489      000000
 786:main.c        **** 
 787:main.c        **** 				// Open file for reading
 788:main.c        **** 				file = fopen(fileName, "rb");
 3490              		.loc 1 788 0
 3491 2980 488B8550 		movq	-176(%rbp), %rax
 3491      FFFFFF
 3492 2987 BE000000 		movl	$.LC32, %esi
 3492      00
 3493 298c 4889C7   		movq	%rax, %rdi
 3494 298f E8000000 		call	fopen
 3494      00
 3495 2994 48898558 		movq	%rax, -168(%rbp)
 3495      FFFFFF
 789:main.c        **** 				CHECK_STATUS(!file, FLP_CANNOT_LOAD, cleanup);
 3496              		.loc 1 789 0
 3497 299b 4883BD58 		cmpq	$0, -168(%rbp)
 3497      FFFFFF00 
 3498 29a3 750F     		jne	.L192
 3499              		.loc 1 789 0 is_stmt 0 discriminator 1
 3500 29a5 C78514FF 		movl	$10, -236(%rbp)
 3500      FFFF0A00 
 3500      0000
 3501 29af E9AA0100 		jmp	.L189
 3501      00
 3502              	.L192:
 790:main.c        **** 				free(fileName);
 3503              		.loc 1 790 0 is_stmt 1
 3504 29b4 488B8550 		movq	-176(%rbp), %rax
 3504      FFFFFF
 3505 29bb 4889C7   		movq	%rax, %rdi
 3506 29be E8000000 		call	free
 3506      00
 791:main.c        **** 				fileName = NULL;
 3507              		.loc 1 791 0
 3508 29c3 48C78550 		movq	$0, -176(%rbp)
 3508      FFFFFF00 
 3508      000000
 792:main.c        **** 				
 793:main.c        **** 				#ifdef WIN32
 794:main.c        **** 				QueryPerformanceCounter(&tvStart);
 795:main.c        **** 				status = doWrite(handle, (uint8)chan, file, &length, &checksum, error);
 796:main.c        **** 				QueryPerformanceCounter(&tvEnd);
 797:main.c        **** 				totalTime = (double)(tvEnd.QuadPart - tvStart.QuadPart);
 798:main.c        **** 				totalTime /= freq.QuadPart;
 799:main.c        **** 				speed = (double)length / (1024*1024*totalTime);
 800:main.c        **** 				#else
 801:main.c        **** 				gettimeofday(&tvStart, NULL);
 3509              		.loc 1 801 0
 3510 29ce 488D45B0 		leaq	-80(%rbp), %rax
 3511 29d2 BE000000 		movl	$0, %esi
 3511      00
 3512 29d7 4889C7   		movq	%rax, %rdi
 3513 29da E8000000 		call	gettimeofday
 3513      00
 802:main.c        **** 				status = doWrite(handle, (uint8)chan, file, &length, &checksum, error);
 3514              		.loc 1 802 0
 3515 29df 488B4580 		movq	-128(%rbp), %rax
 3516 29e3 0FB6F0   		movzbl	%al, %esi
 3517 29e6 4C8B85F8 		movq	-264(%rbp), %r8
 3517      FEFFFF
 3518 29ed 488DBD12 		leaq	-238(%rbp), %rdi
 3518      FFFFFF
 3519 29f4 488D8D38 		leaq	-200(%rbp), %rcx
 3519      FFFFFF
 3520 29fb 488B9558 		movq	-168(%rbp), %rdx
 3520      FFFFFF
 3521 2a02 488B8508 		movq	-248(%rbp), %rax
 3521      FFFFFF
 3522 2a09 4D89C1   		movq	%r8, %r9
 3523 2a0c 4989F8   		movq	%rdi, %r8
 3524 2a0f 4889C7   		movq	%rax, %rdi
 3525 2a12 E8A3F3FF 		call	doWrite
 3525      FF
 3526 2a17 898528FF 		movl	%eax, -216(%rbp)
 3526      FFFF
 803:main.c        **** 				gettimeofday(&tvEnd, NULL);
 3527              		.loc 1 803 0
 3528 2a1d 488D45C0 		leaq	-64(%rbp), %rax
 3529 2a21 BE000000 		movl	$0, %esi
 3529      00
 3530 2a26 4889C7   		movq	%rax, %rdi
 3531 2a29 E8000000 		call	gettimeofday
 3531      00
 804:main.c        **** 				startTime = tvStart.tv_sec;
 3532              		.loc 1 804 0
 3533 2a2e 488B45B0 		movq	-80(%rbp), %rax
 3534 2a32 48894588 		movq	%rax, -120(%rbp)
 805:main.c        **** 				startTime *= 1000000;
 3535              		.loc 1 805 0
 3536 2a36 488B4588 		movq	-120(%rbp), %rax
 3537 2a3a 4869C040 		imulq	$1000000, %rax, %rax
 3537      420F00
 3538 2a41 48894588 		movq	%rax, -120(%rbp)
 806:main.c        **** 				startTime += tvStart.tv_usec;
 3539              		.loc 1 806 0
 3540 2a45 488B45B8 		movq	-72(%rbp), %rax
 3541 2a49 48014588 		addq	%rax, -120(%rbp)
 807:main.c        **** 				endTime = tvEnd.tv_sec;
 3542              		.loc 1 807 0
 3543 2a4d 488B45C0 		movq	-64(%rbp), %rax
 3544 2a51 48894590 		movq	%rax, -112(%rbp)
 808:main.c        **** 				endTime *= 1000000;
 3545              		.loc 1 808 0
 3546 2a55 488B4590 		movq	-112(%rbp), %rax
 3547 2a59 4869C040 		imulq	$1000000, %rax, %rax
 3547      420F00
 3548 2a60 48894590 		movq	%rax, -112(%rbp)
 809:main.c        **** 				endTime += tvEnd.tv_usec;
 3549              		.loc 1 809 0
 3550 2a64 488B45C8 		movq	-56(%rbp), %rax
 3551 2a68 48014590 		addq	%rax, -112(%rbp)
 810:main.c        **** 				totalTime = (double)(endTime - startTime);
 3552              		.loc 1 810 0
 3553 2a6c 488B4590 		movq	-112(%rbp), %rax
 3554 2a70 482B4588 		subq	-120(%rbp), %rax
 3555 2a74 660FEFC0 		pxor	%xmm0, %xmm0
 3556 2a78 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 3556      C0
 3557 2a7d F20F1145 		movsd	%xmm0, -104(%rbp)
 3557      98
 811:main.c        **** 					totalTime /= 1000000;  // convert from uS to S.
 3558              		.loc 1 811 0
 3559 2a82 F20F1045 		movsd	-104(%rbp), %xmm0
 3559      98
 3560 2a87 F20F100D 		movsd	.LC29(%rip), %xmm1
 3560      00000000 
 3561 2a8f F20F5EC1 		divsd	%xmm1, %xmm0
 3562 2a93 F20F1145 		movsd	%xmm0, -104(%rbp)
 3562      98
 812:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 3563              		.loc 1 812 0
 3564 2a98 488B8538 		movq	-200(%rbp), %rax
 3564      FFFFFF
 3565 2a9f 4885C0   		testq	%rax, %rax
 3566 2aa2 780B     		js	.L193
 3567 2aa4 660FEFC0 		pxor	%xmm0, %xmm0
 3568 2aa8 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 3568      C0
 3569 2aad EB19     		jmp	.L194
 3570              	.L193:
 3571 2aaf 4889C2   		movq	%rax, %rdx
 3572 2ab2 48D1EA   		shrq	%rdx
 3573 2ab5 83E001   		andl	$1, %eax
 3574 2ab8 4809C2   		orq	%rax, %rdx
 3575 2abb 660FEFC0 		pxor	%xmm0, %xmm0
 3576 2abf F2480F2A 		cvtsi2sdq	%rdx, %xmm0
 3576      C2
 3577 2ac4 F20F58C0 		addsd	%xmm0, %xmm0
 3578              	.L194:
 3579 2ac8 F20F1055 		movsd	-104(%rbp), %xmm2
 3579      98
 3580 2acd F20F100D 		movsd	.LC30(%rip), %xmm1
 3580      00000000 
 3581 2ad5 F20F59CA 		mulsd	%xmm2, %xmm1
 3582 2ad9 F20F5EC1 		divsd	%xmm1, %xmm0
 3583 2add F20F1145 		movsd	%xmm0, -96(%rbp)
 3583      A0
 813:main.c        **** 				#endif
 814:main.c        **** 					if ( enableBenchmarking ) {
 3584              		.loc 1 814 0
 3585 2ae2 0FB60500 		movzbl	enableBenchmarking(%rip), %eax
 3585      000000
 3586 2ae9 84C0     		testb	%al, %al
 3587 2aeb 743A     		je	.L195
 815:main.c        **** 						printf(
 3588              		.loc 1 815 0
 3589 2aed 0FB78512 		movzwl	-238(%rbp), %eax
 3589      FFFFFF
 3590 2af4 0FB7D0   		movzwl	%ax, %edx
 3591 2af7 488B8538 		movq	-200(%rbp), %rax
 3591      FFFFFF
 3592 2afe 488B75A0 		movq	-96(%rbp), %rsi
 3593 2b02 488B4D80 		movq	-128(%rbp), %rcx
 3594 2b06 4889B5F0 		movq	%rsi, -272(%rbp)
 3594      FEFFFF
 3595 2b0d F20F1085 		movsd	-272(%rbp), %xmm0
 3595      F0FEFFFF 
 3596 2b15 4889C6   		movq	%rax, %rsi
 3597 2b18 BF000000 		movl	$.LC33, %edi
 3597      00
 3598 2b1d B8010000 		movl	$1, %eax
 3598      00
 3599 2b22 E8000000 		call	printf
 3599      00
 3600              	.L195:
 816:main.c        **** 							"Wrote "PFSZD" bytes (checksum 0x%04X) to channel %lu at %f MiB/s\n",
 817:main.c        **** 							length, checksum, chan, speed);
 818:main.c        **** 					}
 819:main.c        **** 					CHECK_STATUS(status, status, cleanup);
 3601              		.loc 1 819 0
 3602 2b27 83BD28FF 		cmpl	$0, -216(%rbp)
 3602      FFFF00
 3603 2b2e 740E     		je	.L196
 3604              		.loc 1 819 0 is_stmt 0 discriminator 1
 3605 2b30 8B8528FF 		movl	-216(%rbp), %eax
 3605      FFFF
 3606 2b36 898514FF 		movl	%eax, -236(%rbp)
 3606      FFFF
 3607 2b3c EB20     		jmp	.L189
 3608              	.L196:
 820:main.c        **** 
 821:main.c        **** 				// Close the file
 822:main.c        **** 					fclose(file);
 3609              		.loc 1 822 0 is_stmt 1
 3610 2b3e 488B8558 		movq	-168(%rbp), %rax
 3610      FFFFFF
 3611 2b45 4889C7   		movq	%rax, %rdi
 3612 2b48 E8000000 		call	fclose
 3612      00
 823:main.c        **** 					file = NULL;
 3613              		.loc 1 823 0
 3614 2b4d 48C78558 		movq	$0, -168(%rbp)
 3614      FFFFFF00 
 3614      000000
 3615              	.LBE38:
 770:main.c        **** 					uint16 checksum = 0x0000;
 3616              		.loc 1 770 0
 3617 2b58 90       		nop
 3618 2b59 E9AB0300 		jmp	.L178
 3618      00
 3619              	.L189:
 759:main.c        **** 
 3620              		.loc 1 759 0 discriminator 2
 3621 2b5e E9E70300 		jmp	.L145
 3621      00
 3622              	.L184:
 824:main.c        **** 				} else if ( isHexDigit(ch) ) {
 3623              		.loc 1 824 0
 3624 2b63 0FBE8510 		movsbl	-240(%rbp), %eax
 3624      FFFFFF
 3625 2b6a 89C7     		movl	%eax, %edi
 3626 2b6c E800EEFF 		call	isHexDigit
 3626      FF
 3627 2b71 84C0     		testb	%al, %al
 3628 2b73 0F848402 		je	.L198
 3628      0000
 3629              	.LBB39:
 825:main.c        **** 				// Read a sequence of hex bytes to write
 826:main.c        **** 					uint8 *dataPtr;
 827:main.c        **** 					p = ptr + 1;
 3630              		.loc 1 827 0
 3631 2b79 488B0500 		movq	ptr(%rip), %rax
 3631      000000
 3632 2b80 4883C001 		addq	$1, %rax
 3633 2b84 48898570 		movq	%rax, -144(%rbp)
 3633      FFFFFF
 828:main.c        **** 					while ( isHexDigit(*p) ) {
 3634              		.loc 1 828 0
 3635 2b8b EB08     		jmp	.L199
 3636              	.L200:
 829:main.c        **** 						p++;
 3637              		.loc 1 829 0
 3638 2b8d 48838570 		addq	$1, -144(%rbp)
 3638      FFFFFF01 
 3639              	.L199:
 828:main.c        **** 					while ( isHexDigit(*p) ) {
 3640              		.loc 1 828 0
 3641 2b95 488B8570 		movq	-144(%rbp), %rax
 3641      FFFFFF
 3642 2b9c 0FB600   		movzbl	(%rax), %eax
 3643 2b9f 0FBEC0   		movsbl	%al, %eax
 3644 2ba2 89C7     		movl	%eax, %edi
 3645 2ba4 E8C8EDFF 		call	isHexDigit
 3645      FF
 3646 2ba9 84C0     		testb	%al, %al
 3647 2bab 75E0     		jne	.L200
 830:main.c        **** 					}
 831:main.c        **** 					CHECK_STATUS((p - ptr) & 1, FLP_ODD_DIGITS, cleanup);
 3648              		.loc 1 831 0
 3649 2bad 488B8570 		movq	-144(%rbp), %rax
 3649      FFFFFF
 3650 2bb4 488B1500 		movq	ptr(%rip), %rdx
 3650      000000
 3651 2bbb 4829D0   		subq	%rdx, %rax
 3652 2bbe 83E001   		andl	$1, %eax
 3653 2bc1 4885C0   		testq	%rax, %rax
 3654 2bc4 740F     		je	.L201
 3655              		.loc 1 831 0 is_stmt 0 discriminator 1
 3656 2bc6 C78514FF 		movl	$9, -236(%rbp)
 3656      FFFF0900 
 3656      0000
 3657 2bd0 E9750300 		jmp	.L145
 3657      00
 3658              	.L201:
 832:main.c        **** 					length = (size_t)(p - ptr) / 2;
 3659              		.loc 1 832 0 is_stmt 1
 3660 2bd5 488B8570 		movq	-144(%rbp), %rax
 3660      FFFFFF
 3661 2bdc 488B1500 		movq	ptr(%rip), %rdx
 3661      000000
 3662 2be3 4829D0   		subq	%rdx, %rax
 3663 2be6 48D1E8   		shrq	%rax
 3664 2be9 48898538 		movq	%rax, -200(%rbp)
 3664      FFFFFF
 833:main.c        **** 					data = malloc(length);
 3665              		.loc 1 833 0
 3666 2bf0 488B8538 		movq	-200(%rbp), %rax
 3666      FFFFFF
 3667 2bf7 4889C7   		movq	%rax, %rdi
 3668 2bfa E8000000 		call	malloc
 3668      00
 3669 2bff 48898548 		movq	%rax, -184(%rbp)
 3669      FFFFFF
 834:main.c        **** 					dataPtr = data;
 3670              		.loc 1 834 0
 3671 2c06 488B8548 		movq	-184(%rbp), %rax
 3671      FFFFFF
 3672 2c0d 48898578 		movq	%rax, -136(%rbp)
 3672      FFFFFF
 835:main.c        **** 					for ( i = 0; i < length; i++ ) {
 3673              		.loc 1 835 0
 3674 2c14 48C78568 		movq	$0, -152(%rbp)
 3674      FFFFFF00 
 3674      000000
 3675 2c1f EB34     		jmp	.L202
 3676              	.L203:
 836:main.c        **** 						getHexByte(dataPtr++);
 3677              		.loc 1 836 0 discriminator 3
 3678 2c21 488B8578 		movq	-136(%rbp), %rax
 3678      FFFFFF
 3679 2c28 488D5001 		leaq	1(%rax), %rdx
 3680 2c2c 48899578 		movq	%rdx, -136(%rbp)
 3680      FFFFFF
 3681 2c33 4889C7   		movq	%rax, %rdi
 3682 2c36 E829EEFF 		call	getHexByte
 3682      FF
 837:main.c        **** 						ptr += 2;
 3683              		.loc 1 837 0 discriminator 3
 3684 2c3b 488B0500 		movq	ptr(%rip), %rax
 3684      000000
 3685 2c42 4883C002 		addq	$2, %rax
 3686 2c46 48890500 		movq	%rax, ptr(%rip)
 3686      000000
 835:main.c        **** 					for ( i = 0; i < length; i++ ) {
 3687              		.loc 1 835 0 discriminator 3
 3688 2c4d 48838568 		addq	$1, -152(%rbp)
 3688      FFFFFF01 
 3689              	.L202:
 835:main.c        **** 					for ( i = 0; i < length; i++ ) {
 3690              		.loc 1 835 0 is_stmt 0 discriminator 1
 3691 2c55 488B8538 		movq	-200(%rbp), %rax
 3691      FFFFFF
 3692 2c5c 48398568 		cmpq	%rax, -152(%rbp)
 3692      FFFFFF
 3693 2c63 72BC     		jb	.L203
 838:main.c        **** 					}
 839:main.c        **** 				#ifdef WIN32
 840:main.c        **** 					QueryPerformanceCounter(&tvStart);
 841:main.c        **** 					fStatus = flWriteChannel(handle, (uint8)chan, length, data, error);
 842:main.c        **** 					QueryPerformanceCounter(&tvEnd);
 843:main.c        **** 					totalTime = (double)(tvEnd.QuadPart - tvStart.QuadPart);
 844:main.c        **** 					totalTime /= freq.QuadPart;
 845:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 846:main.c        **** 				#else
 847:main.c        **** 					gettimeofday(&tvStart, NULL);
 3694              		.loc 1 847 0 is_stmt 1
 3695 2c65 488D45B0 		leaq	-80(%rbp), %rax
 3696 2c69 BE000000 		movl	$0, %esi
 3696      00
 3697 2c6e 4889C7   		movq	%rax, %rdi
 3698 2c71 E8000000 		call	gettimeofday
 3698      00
 848:main.c        **** 					fStatus = flWriteChannel(handle, (uint8)chan, length, data, error);
 3699              		.loc 1 848 0
 3700 2c76 488B9538 		movq	-200(%rbp), %rdx
 3700      FFFFFF
 3701 2c7d 488B4580 		movq	-128(%rbp), %rax
 3702 2c81 0FB6F0   		movzbl	%al, %esi
 3703 2c84 488BBDF8 		movq	-264(%rbp), %rdi
 3703      FEFFFF
 3704 2c8b 488B8D48 		movq	-184(%rbp), %rcx
 3704      FFFFFF
 3705 2c92 488B8508 		movq	-248(%rbp), %rax
 3705      FFFFFF
 3706 2c99 4989F8   		movq	%rdi, %r8
 3707 2c9c 4889C7   		movq	%rax, %rdi
 3708 2c9f E8000000 		call	flWriteChannel
 3708      00
 3709 2ca4 898524FF 		movl	%eax, -220(%rbp)
 3709      FFFF
 849:main.c        **** 					gettimeofday(&tvEnd, NULL);
 3710              		.loc 1 849 0
 3711 2caa 488D45C0 		leaq	-64(%rbp), %rax
 3712 2cae BE000000 		movl	$0, %esi
 3712      00
 3713 2cb3 4889C7   		movq	%rax, %rdi
 3714 2cb6 E8000000 		call	gettimeofday
 3714      00
 850:main.c        **** 					startTime = tvStart.tv_sec;
 3715              		.loc 1 850 0
 3716 2cbb 488B45B0 		movq	-80(%rbp), %rax
 3717 2cbf 48894588 		movq	%rax, -120(%rbp)
 851:main.c        **** 					startTime *= 1000000;
 3718              		.loc 1 851 0
 3719 2cc3 488B4588 		movq	-120(%rbp), %rax
 3720 2cc7 4869C040 		imulq	$1000000, %rax, %rax
 3720      420F00
 3721 2cce 48894588 		movq	%rax, -120(%rbp)
 852:main.c        **** 					startTime += tvStart.tv_usec;
 3722              		.loc 1 852 0
 3723 2cd2 488B45B8 		movq	-72(%rbp), %rax
 3724 2cd6 48014588 		addq	%rax, -120(%rbp)
 853:main.c        **** 					endTime = tvEnd.tv_sec;
 3725              		.loc 1 853 0
 3726 2cda 488B45C0 		movq	-64(%rbp), %rax
 3727 2cde 48894590 		movq	%rax, -112(%rbp)
 854:main.c        **** 					endTime *= 1000000;
 3728              		.loc 1 854 0
 3729 2ce2 488B4590 		movq	-112(%rbp), %rax
 3730 2ce6 4869C040 		imulq	$1000000, %rax, %rax
 3730      420F00
 3731 2ced 48894590 		movq	%rax, -112(%rbp)
 855:main.c        **** 					endTime += tvEnd.tv_usec;
 3732              		.loc 1 855 0
 3733 2cf1 488B45C8 		movq	-56(%rbp), %rax
 3734 2cf5 48014590 		addq	%rax, -112(%rbp)
 856:main.c        **** 					totalTime = (double)(endTime - startTime);
 3735              		.loc 1 856 0
 3736 2cf9 488B4590 		movq	-112(%rbp), %rax
 3737 2cfd 482B4588 		subq	-120(%rbp), %rax
 3738 2d01 660FEFC0 		pxor	%xmm0, %xmm0
 3739 2d05 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 3739      C0
 3740 2d0a F20F1145 		movsd	%xmm0, -104(%rbp)
 3740      98
 857:main.c        **** 					totalTime /= 1000000;  // convert from uS to S.
 3741              		.loc 1 857 0
 3742 2d0f F20F1045 		movsd	-104(%rbp), %xmm0
 3742      98
 3743 2d14 F20F100D 		movsd	.LC29(%rip), %xmm1
 3743      00000000 
 3744 2d1c F20F5EC1 		divsd	%xmm1, %xmm0
 3745 2d20 F20F1145 		movsd	%xmm0, -104(%rbp)
 3745      98
 858:main.c        **** 					speed = (double)length / (1024*1024*totalTime);
 3746              		.loc 1 858 0
 3747 2d25 488B8538 		movq	-200(%rbp), %rax
 3747      FFFFFF
 3748 2d2c 4885C0   		testq	%rax, %rax
 3749 2d2f 780B     		js	.L204
 3750 2d31 660FEFC0 		pxor	%xmm0, %xmm0
 3751 2d35 F2480F2A 		cvtsi2sdq	%rax, %xmm0
 3751      C0
 3752 2d3a EB19     		jmp	.L205
 3753              	.L204:
 3754 2d3c 4889C2   		movq	%rax, %rdx
 3755 2d3f 48D1EA   		shrq	%rdx
 3756 2d42 83E001   		andl	$1, %eax
 3757 2d45 4809C2   		orq	%rax, %rdx
 3758 2d48 660FEFC0 		pxor	%xmm0, %xmm0
 3759 2d4c F2480F2A 		cvtsi2sdq	%rdx, %xmm0
 3759      C2
 3760 2d51 F20F58C0 		addsd	%xmm0, %xmm0
 3761              	.L205:
 3762 2d55 F20F1055 		movsd	-104(%rbp), %xmm2
 3762      98
 3763 2d5a F20F100D 		movsd	.LC30(%rip), %xmm1
 3763      00000000 
 3764 2d62 F20F59CA 		mulsd	%xmm2, %xmm1
 3765 2d66 F20F5EC1 		divsd	%xmm1, %xmm0
 3766 2d6a F20F1145 		movsd	%xmm0, -96(%rbp)
 3766      A0
 859:main.c        **** 				#endif
 860:main.c        **** 					if ( enableBenchmarking ) {
 3767              		.loc 1 860 0
 3768 2d6f 0FB60500 		movzbl	enableBenchmarking(%rip), %eax
 3768      000000
 3769 2d76 84C0     		testb	%al, %al
 3770 2d78 744C     		je	.L206
 861:main.c        **** 						printf(
 862:main.c        **** 							"Wrote "PFSZD" bytes (checksum 0x%04X) to channel %lu at %f MiB/s\n",
 863:main.c        **** 							length, calcChecksum(data, length), chan, speed);
 3771              		.loc 1 863 0
 3772 2d7a 488B9538 		movq	-200(%rbp), %rdx
 3772      FFFFFF
 3773 2d81 488B8548 		movq	-184(%rbp), %rax
 3773      FFFFFF
 3774 2d88 4889D6   		movq	%rdx, %rsi
 3775 2d8b 4889C7   		movq	%rax, %rdi
 3776 2d8e E81CECFF 		call	calcChecksum
 3776      FF
 861:main.c        **** 						printf(
 3777              		.loc 1 861 0
 3778 2d93 0FB7D0   		movzwl	%ax, %edx
 3779 2d96 488B8538 		movq	-200(%rbp), %rax
 3779      FFFFFF
 3780 2d9d 488B75A0 		movq	-96(%rbp), %rsi
 3781 2da1 488B4D80 		movq	-128(%rbp), %rcx
 3782 2da5 4889B5F0 		movq	%rsi, -272(%rbp)
 3782      FEFFFF
 3783 2dac F20F1085 		movsd	-272(%rbp), %xmm0
 3783      F0FEFFFF 
 3784 2db4 4889C6   		movq	%rax, %rsi
 3785 2db7 BF000000 		movl	$.LC33, %edi
 3785      00
 3786 2dbc B8010000 		movl	$1, %eax
 3786      00
 3787 2dc1 E8000000 		call	printf
 3787      00
 3788              	.L206:
 864:main.c        **** 					}
 865:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3789              		.loc 1 865 0
 3790 2dc6 83BD24FF 		cmpl	$0, -220(%rbp)
 3790      FFFF00
 3791 2dcd 740F     		je	.L207
 3792              		.loc 1 865 0 is_stmt 0 discriminator 1
 3793 2dcf C78514FF 		movl	$1, -236(%rbp)
 3793      FFFF0100 
 3793      0000
 3794 2dd9 E96C0100 		jmp	.L145
 3794      00
 3795              	.L207:
 866:main.c        **** 					free(data);
 3796              		.loc 1 866 0 is_stmt 1
 3797 2dde 488B8548 		movq	-184(%rbp), %rax
 3797      FFFFFF
 3798 2de5 4889C7   		movq	%rax, %rdi
 3799 2de8 E8000000 		call	free
 3799      00
 867:main.c        **** 					data = NULL;
 3800              		.loc 1 867 0
 3801 2ded 48C78548 		movq	$0, -184(%rbp)
 3801      FFFFFF00 
 3801      000000
 3802              	.LBE39:
 868:main.c        **** 				} else {
 869:main.c        **** 					FAIL(FLP_ILL_CHAR, cleanup);
 870:main.c        **** 				}
 871:main.c        **** 				break;
 3803              		.loc 1 871 0
 3804 2df8 E90C0100 		jmp	.L178
 3804      00
 3805              	.L198:
 869:main.c        **** 				}
 3806              		.loc 1 869 0
 3807 2dfd C78514FF 		movl	$5, -236(%rbp)
 3807      FFFF0500 
 3807      0000
 3808 2e07 90       		nop
 3809 2e08 E93D0100 		jmp	.L145
 3809      00
 3810              	.L151:
 3811              	.LBE37:
 3812              	.LBB40:
 872:main.c        **** 			}
 873:main.c        **** 			case '+':{
 874:main.c        **** 				uint32 conduit;
 875:main.c        **** 				char *end;
 876:main.c        **** 				ptr++;
 3813              		.loc 1 876 0
 3814 2e0d 488B0500 		movq	ptr(%rip), %rax
 3814      000000
 3815 2e14 4883C001 		addq	$1, %rax
 3816 2e18 48890500 		movq	%rax, ptr(%rip)
 3816      000000
 877:main.c        **** 
 878:main.c        **** 			// Get the conduit
 879:main.c        **** 				errno = 0;
 3817              		.loc 1 879 0
 3818 2e1f E8000000 		call	__errno_location
 3818      00
 3819 2e24 C7000000 		movl	$0, (%rax)
 3819      0000
 880:main.c        **** 				conduit = (uint32)strtoul(ptr, &end, 16);
 3820              		.loc 1 880 0
 3821 2e2a 488B0500 		movq	ptr(%rip), %rax
 3821      000000
 3822 2e31 488D8D40 		leaq	-192(%rbp), %rcx
 3822      FFFFFF
 3823 2e38 BA100000 		movl	$16, %edx
 3823      00
 3824 2e3d 4889CE   		movq	%rcx, %rsi
 3825 2e40 4889C7   		movq	%rax, %rdi
 3826 2e43 E8000000 		call	strtoul
 3826      00
 3827 2e48 89852CFF 		movl	%eax, -212(%rbp)
 3827      FFFF
 881:main.c        **** 				CHECK_STATUS(errno, FLP_BAD_HEX, cleanup);
 3828              		.loc 1 881 0
 3829 2e4e E8000000 		call	__errno_location
 3829      00
 3830 2e53 8B00     		movl	(%rax), %eax
 3831 2e55 85C0     		testl	%eax, %eax
 3832 2e57 740F     		je	.L208
 3833              		.loc 1 881 0 is_stmt 0 discriminator 1
 3834 2e59 C78514FF 		movl	$2, -236(%rbp)
 3834      FFFF0200 
 3834      0000
 3835 2e63 E9E20000 		jmp	.L145
 3835      00
 3836              	.L208:
 882:main.c        **** 
 883:main.c        **** 			// Ensure that it's 0-127
 884:main.c        **** 				CHECK_STATUS(conduit > 255, FLP_CONDUIT_RANGE, cleanup);
 3837              		.loc 1 884 0 is_stmt 1
 3838 2e68 81BD2CFF 		cmpl	$255, -212(%rbp)
 3838      FFFFFF00 
 3838      0000
 3839 2e72 760F     		jbe	.L210
 3840              		.loc 1 884 0 is_stmt 0 discriminator 1
 3841 2e74 C78514FF 		movl	$4, -236(%rbp)
 3841      FFFF0400 
 3841      0000
 3842 2e7e E9C70000 		jmp	.L145
 3842      00
 3843              	.L210:
 885:main.c        **** 				ptr = end;
 3844              		.loc 1 885 0 is_stmt 1
 3845 2e83 488B8540 		movq	-192(%rbp), %rax
 3845      FFFFFF
 3846 2e8a 48890500 		movq	%rax, ptr(%rip)
 3846      000000
 886:main.c        **** 
 887:main.c        **** 			// Only two valid chars at this point:
 888:main.c        **** 				CHECK_STATUS(*ptr != '\0' && *ptr != ';', FLP_ILL_CHAR, cleanup);
 3847              		.loc 1 888 0
 3848 2e91 488B0500 		movq	ptr(%rip), %rax
 3848      000000
 3849 2e98 0FB600   		movzbl	(%rax), %eax
 3850 2e9b 84C0     		testb	%al, %al
 3851 2e9d 741D     		je	.L211
 3852              		.loc 1 888 0 is_stmt 0 discriminator 1
 3853 2e9f 488B0500 		movq	ptr(%rip), %rax
 3853      000000
 3854 2ea6 0FB600   		movzbl	(%rax), %eax
 3855 2ea9 3C3B     		cmpb	$59, %al
 3856 2eab 740F     		je	.L211
 3857              		.loc 1 888 0 discriminator 2
 3858 2ead C78514FF 		movl	$5, -236(%rbp)
 3858      FFFF0500 
 3858      0000
 3859 2eb7 E98E0000 		jmp	.L145
 3859      00
 3860              	.L211:
 889:main.c        **** 
 890:main.c        **** 				fStatus = flSelectConduit(handle, (uint8)conduit, error);
 3861              		.loc 1 890 0 is_stmt 1
 3862 2ebc 8B852CFF 		movl	-212(%rbp), %eax
 3862      FFFF
 3863 2ec2 0FB6C8   		movzbl	%al, %ecx
 3864 2ec5 488B95F8 		movq	-264(%rbp), %rdx
 3864      FEFFFF
 3865 2ecc 488B8508 		movq	-248(%rbp), %rax
 3865      FFFFFF
 3866 2ed3 89CE     		movl	%ecx, %esi
 3867 2ed5 4889C7   		movq	%rax, %rdi
 3868 2ed8 E8000000 		call	flSelectConduit
 3868      00
 3869 2edd 898524FF 		movl	%eax, -220(%rbp)
 3869      FFFF
 891:main.c        **** 				CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 3870              		.loc 1 891 0
 3871 2ee3 83BD24FF 		cmpl	$0, -220(%rbp)
 3871      FFFF00
 3872 2eea 741C     		je	.L223
 3873              		.loc 1 891 0 is_stmt 0 discriminator 1
 3874 2eec C78514FF 		movl	$1, -236(%rbp)
 3874      FFFF0100 
 3874      0000
 3875 2ef6 90       		nop
 3876 2ef7 EB51     		jmp	.L145
 3877              	.L221:
 3878              	.LBE40:
 892:main.c        **** 				break;
 893:main.c        **** 			}
 894:main.c        **** 			default:
 895:main.c        **** 			FAIL(FLP_ILL_CHAR, cleanup);
 3879              		.loc 1 895 0 is_stmt 1
 3880 2ef9 C78514FF 		movl	$5, -236(%rbp)
 3880      FFFF0500 
 3880      0000
 3881 2f03 EB45     		jmp	.L145
 3882              	.L222:
 3883              	.LBB41:
 747:main.c        **** 			}
 3884              		.loc 1 747 0
 3885 2f05 90       		nop
 3886 2f06 EB01     		jmp	.L178
 3887              	.L223:
 3888              	.LBE41:
 3889              	.LBB42:
 892:main.c        **** 				break;
 3890              		.loc 1 892 0
 3891 2f08 90       		nop
 3892              	.L178:
 3893              	.LBE42:
 896:main.c        **** 		}
 897:main.c        **** 	} while ( *ptr == ';' );
 3894              		.loc 1 897 0
 3895 2f09 488B0500 		movq	ptr(%rip), %rax
 3895      000000
 3896 2f10 0FB600   		movzbl	(%rax), %eax
 3897 2f13 3C3B     		cmpb	$59, %al
 3898 2f15 0F846DF1 		je	.L146
 3898      FFFF
 898:main.c        **** 	CHECK_STATUS(*ptr != '\0', FLP_ILL_CHAR, cleanup);
 3899              		.loc 1 898 0
 3900 2f1b 488B0500 		movq	ptr(%rip), %rax
 3900      000000
 3901 2f22 0FB600   		movzbl	(%rax), %eax
 3902 2f25 84C0     		testb	%al, %al
 3903 2f27 740C     		je	.L214
 3904              		.loc 1 898 0 is_stmt 0 discriminator 1
 3905 2f29 C78514FF 		movl	$5, -236(%rbp)
 3905      FFFF0500 
 3905      0000
 3906 2f33 EB15     		jmp	.L145
 3907              	.L214:
 899:main.c        **** 
 900:main.c        **** 	dump(0x00000000, dataFromFPGA.data, dataFromFPGA.length);
 3908              		.loc 1 900 0 is_stmt 1
 3909 2f35 488B55D8 		movq	-40(%rbp), %rdx
 3910 2f39 488B45D0 		movq	-48(%rbp), %rax
 3911 2f3d 4889C6   		movq	%rax, %rsi
 3912 2f40 BF000000 		movl	$0, %edi
 3912      00
 3913 2f45 E8000000 		call	dump
 3913      00
 3914              	.L145:
 901:main.c        **** 
 902:main.c        **** 	cleanup:
 903:main.c        **** 	bufDestroy(&dataFromFPGA);
 3915              		.loc 1 903 0
 3916 2f4a 488D45D0 		leaq	-48(%rbp), %rax
 3917 2f4e 4889C7   		movq	%rax, %rdi
 3918 2f51 E8000000 		call	bufDestroy
 3918      00
 904:main.c        **** 	if ( file ) {
 3919              		.loc 1 904 0
 3920 2f56 4883BD58 		cmpq	$0, -168(%rbp)
 3920      FFFFFF00 
 3921 2f5e 740F     		je	.L215
 905:main.c        **** 		fclose(file);
 3922              		.loc 1 905 0
 3923 2f60 488B8558 		movq	-168(%rbp), %rax
 3923      FFFFFF
 3924 2f67 4889C7   		movq	%rax, %rdi
 3925 2f6a E8000000 		call	fclose
 3925      00
 3926              	.L215:
 906:main.c        **** 	}
 907:main.c        **** 	free(fileName);
 3927              		.loc 1 907 0
 3928 2f6f 488B8550 		movq	-176(%rbp), %rax
 3928      FFFFFF
 3929 2f76 4889C7   		movq	%rax, %rdi
 3930 2f79 E8000000 		call	free
 3930      00
 908:main.c        **** 	free(data);
 3931              		.loc 1 908 0
 3932 2f7e 488B8548 		movq	-184(%rbp), %rax
 3932      FFFFFF
 3933 2f85 4889C7   		movq	%rax, %rdi
 3934 2f88 E8000000 		call	free
 3934      00
 909:main.c        **** 	if ( retVal > FLP_LIBERR ) {
 3935              		.loc 1 909 0
 3936 2f8d 83BD14FF 		cmpl	$1, -236(%rbp)
 3936      FFFF01
 3937 2f94 0F86A700 		jbe	.L216
 3937      0000
 3938              	.LBB43:
 910:main.c        **** 		const int column = (int)(ptr - line);
 3939              		.loc 1 910 0
 3940 2f9a 488B0500 		movq	ptr(%rip), %rax
 3940      000000
 3941 2fa1 4889C2   		movq	%rax, %rdx
 3942 2fa4 488B8500 		movq	-256(%rbp), %rax
 3942      FFFFFF
 3943 2fab 4829C2   		subq	%rax, %rdx
 3944 2fae 4889D0   		movq	%rdx, %rax
 3945 2fb1 898534FF 		movl	%eax, -204(%rbp)
 3945      FFFF
 911:main.c        **** 		int i;
 912:main.c        **** 		fprintf(stderr, "%s at column %d\n  %s\n  ", errMessages[retVal], column, line);
 3946              		.loc 1 912 0
 3947 2fb7 8B8514FF 		movl	-236(%rbp), %eax
 3947      FFFF
 3948 2fbd 488B14C5 		movq	errMessages(,%rax,8), %rdx
 3948      00000000 
 3949 2fc5 488B0500 		movq	stderr(%rip), %rax
 3949      000000
 3950 2fcc 488BB500 		movq	-256(%rbp), %rsi
 3950      FFFFFF
 3951 2fd3 8B8D34FF 		movl	-204(%rbp), %ecx
 3951      FFFF
 3952 2fd9 4989F0   		movq	%rsi, %r8
 3953 2fdc BE000000 		movl	$.LC34, %esi
 3953      00
 3954 2fe1 4889C7   		movq	%rax, %rdi
 3955 2fe4 B8000000 		movl	$0, %eax
 3955      00
 3956 2fe9 E8000000 		call	fprintf
 3956      00
 913:main.c        **** 		for ( i = 0; i < column; i++ ) {
 3957              		.loc 1 913 0
 3958 2fee C7851CFF 		movl	$0, -228(%rbp)
 3958      FFFF0000 
 3958      0000
 3959 2ff8 EB1B     		jmp	.L217
 3960              	.L218:
 914:main.c        **** 			fprintf(stderr, " ");
 3961              		.loc 1 914 0 discriminator 3
 3962 2ffa 488B0500 		movq	stderr(%rip), %rax
 3962      000000
 3963 3001 4889C6   		movq	%rax, %rsi
 3964 3004 BF200000 		movl	$32, %edi
 3964      00
 3965 3009 E8000000 		call	fputc
 3965      00
 913:main.c        **** 		for ( i = 0; i < column; i++ ) {
 3966              		.loc 1 913 0 discriminator 3
 3967 300e 83851CFF 		addl	$1, -228(%rbp)
 3967      FFFF01
 3968              	.L217:
 913:main.c        **** 		for ( i = 0; i < column; i++ ) {
 3969              		.loc 1 913 0 is_stmt 0 discriminator 1
 3970 3015 8B851CFF 		movl	-228(%rbp), %eax
 3970      FFFF
 3971 301b 3B8534FF 		cmpl	-204(%rbp), %eax
 3971      FFFF
 3972 3021 7CD7     		jl	.L218
 915:main.c        **** 		}
 916:main.c        **** 		fprintf(stderr, "^\n");
 3973              		.loc 1 916 0 is_stmt 1
 3974 3023 488B0500 		movq	stderr(%rip), %rax
 3974      000000
 3975 302a 4889C1   		movq	%rax, %rcx
 3976 302d BA020000 		movl	$2, %edx
 3976      00
 3977 3032 BE010000 		movl	$1, %esi
 3977      00
 3978 3037 BF000000 		movl	$.LC35, %edi
 3978      00
 3979 303c E8000000 		call	fwrite
 3979      00
 3980              	.L216:
 3981              	.LBE43:
 917:main.c        **** 	}
 918:main.c        **** 	return retVal;
 3982              		.loc 1 918 0
 3983 3041 8B8514FF 		movl	-236(%rbp), %eax
 3983      FFFF
 919:main.c        **** }
 3984              		.loc 1 919 0
 3985 3047 488B4DF8 		movq	-8(%rbp), %rcx
 3986 304b 6448330C 		xorq	%fs:40, %rcx
 3986      25280000 
 3986      00
 3987 3054 7405     		je	.L220
 3988 3056 E8000000 		call	__stack_chk_fail
 3988      00
 3989              	.L220:
 3990 305b C9       		leave
 3991              		.cfi_def_cfa 7, 8
 3992 305c C3       		ret
 3993              		.cfi_endproc
 3994              	.LFE21:
 3996              		.section	.rodata
 3997              	.LC36:
 3998 02c1 30303030 		.string	"0000"
 3998      00
 3999              	.LC37:
 4000 02c6 30303031 		.string	"0001"
 4000      00
 4001              	.LC38:
 4002 02cb 30303130 		.string	"0010"
 4002      00
 4003              	.LC39:
 4004 02d0 30303131 		.string	"0011"
 4004      00
 4005              	.LC40:
 4006 02d5 30313030 		.string	"0100"
 4006      00
 4007              	.LC41:
 4008 02da 30313031 		.string	"0101"
 4008      00
 4009              	.LC42:
 4010 02df 30313130 		.string	"0110"
 4010      00
 4011              	.LC43:
 4012 02e4 30313131 		.string	"0111"
 4012      00
 4013              	.LC44:
 4014 02e9 31303030 		.string	"1000"
 4014      00
 4015              	.LC45:
 4016 02ee 31303031 		.string	"1001"
 4016      00
 4017              	.LC46:
 4018 02f3 58585858 		.string	"XXXX"
 4018      00
 4019              	.LC47:
 4020 02f8 31303130 		.string	"1010"
 4020      00
 4021              	.LC48:
 4022 02fd 31303131 		.string	"1011"
 4022      00
 4023              	.LC49:
 4024 0302 31313030 		.string	"1100"
 4024      00
 4025              	.LC50:
 4026 0307 31313031 		.string	"1101"
 4026      00
 4027              	.LC51:
 4028 030c 31313130 		.string	"1110"
 4028      00
 4029              	.LC52:
 4030 0311 31313131 		.string	"1111"
 4030      00
 4031              		.data
 4032              		.align 32
 4035              	nibbles:
 4036 0000 00000000 		.quad	.LC36
 4036      00000000 
 4037 0008 00000000 		.quad	.LC37
 4037      00000000 
 4038 0010 00000000 		.quad	.LC38
 4038      00000000 
 4039 0018 00000000 		.quad	.LC39
 4039      00000000 
 4040 0020 00000000 		.quad	.LC40
 4040      00000000 
 4041 0028 00000000 		.quad	.LC41
 4041      00000000 
 4042 0030 00000000 		.quad	.LC42
 4042      00000000 
 4043 0038 00000000 		.quad	.LC43
 4043      00000000 
 4044 0040 00000000 		.quad	.LC44
 4044      00000000 
 4045 0048 00000000 		.quad	.LC45
 4045      00000000 
 4046 0050 00000000 		.quad	.LC46
 4046      00000000 
 4047 0058 00000000 		.quad	.LC46
 4047      00000000 
 4048 0060 00000000 		.quad	.LC46
 4048      00000000 
 4049 0068 00000000 		.quad	.LC46
 4049      00000000 
 4050 0070 00000000 		.quad	.LC46
 4050      00000000 
 4051 0078 00000000 		.quad	.LC46
 4051      00000000 
 4052 0080 00000000 		.quad	.LC46
 4052      00000000 
 4053 0088 00000000 		.quad	.LC47
 4053      00000000 
 4054 0090 00000000 		.quad	.LC48
 4054      00000000 
 4055 0098 00000000 		.quad	.LC49
 4055      00000000 
 4056 00a0 00000000 		.quad	.LC50
 4056      00000000 
 4057 00a8 00000000 		.quad	.LC51
 4057      00000000 
 4058 00b0 00000000 		.quad	.LC52
 4058      00000000 
 4059              		.text
 4060              		.globl	asciiToBinary
 4062              	asciiToBinary:
 4063              	.LFB22:
 920:main.c        **** 
 921:main.c        **** static const char *nibbles[] = {
 922:main.c        **** 	"0000",  // '0'
 923:main.c        **** 	"0001",  // '1'
 924:main.c        **** 	"0010",  // '2'
 925:main.c        **** 	"0011",  // '3'
 926:main.c        **** 	"0100",  // '4'
 927:main.c        **** 	"0101",  // '5'
 928:main.c        **** 	"0110",  // '6'
 929:main.c        **** 	"0111",  // '7'
 930:main.c        **** 	"1000",  // '8'
 931:main.c        **** 	"1001",  // '9'
 932:main.c        **** 
 933:main.c        **** 	"XXXX",  // ':'
 934:main.c        **** 	"XXXX",  // ';'
 935:main.c        **** 	"XXXX",  // '<'
 936:main.c        **** 	"XXXX",  // '='
 937:main.c        **** 	"XXXX",  // '>'
 938:main.c        **** 	"XXXX",  // '?'
 939:main.c        **** 	"XXXX",  // '@'
 940:main.c        **** 
 941:main.c        **** 	"1010",  // 'A'
 942:main.c        **** 	"1011",  // 'B'
 943:main.c        **** 	"1100",  // 'C'
 944:main.c        **** 	"1101",  // 'D'
 945:main.c        **** 	"1110",  // 'E'
 946:main.c        **** 	"1111"   // 'F'
 947:main.c        **** };
 948:main.c        **** 
 949:main.c        **** ////////////////////////////////////////////////////////////////////////
 950:main.c        **** int asciiToBinary(int input) {
 4064              		.loc 1 950 0
 4065              		.cfi_startproc
 4066 305d 55       		pushq	%rbp
 4067              		.cfi_def_cfa_offset 16
 4068              		.cfi_offset 6, -16
 4069 305e 4889E5   		movq	%rsp, %rbp
 4070              		.cfi_def_cfa_register 6
 4071 3061 897DEC   		movl	%edi, -20(%rbp)
 951:main.c        **** 	int result = 0, i = 1, remainder;
 4072              		.loc 1 951 0
 4073 3064 C745F400 		movl	$0, -12(%rbp)
 4073      000000
 4074 306b C745F801 		movl	$1, -8(%rbp)
 4074      000000
 952:main.c        **** 
 953:main.c        ****         /* convert decimal to binary format */
 954:main.c        **** 	while (input > 0) {
 4075              		.loc 1 954 0
 4076 3072 EB39     		jmp	.L225
 4077              	.L226:
 955:main.c        **** 		remainder = input % 2;
 4078              		.loc 1 955 0
 4079 3074 8B45EC   		movl	-20(%rbp), %eax
 4080 3077 99       		cltd
 4081 3078 C1EA1F   		shrl	$31, %edx
 4082 307b 01D0     		addl	%edx, %eax
 4083 307d 83E001   		andl	$1, %eax
 4084 3080 29D0     		subl	%edx, %eax
 4085 3082 8945FC   		movl	%eax, -4(%rbp)
 956:main.c        **** 		result = result + (i * remainder);
 4086              		.loc 1 956 0
 4087 3085 8B45F8   		movl	-8(%rbp), %eax
 4088 3088 0FAF45FC 		imull	-4(%rbp), %eax
 4089 308c 0145F4   		addl	%eax, -12(%rbp)
 957:main.c        **** 		input = input / 2;
 4090              		.loc 1 957 0
 4091 308f 8B45EC   		movl	-20(%rbp), %eax
 4092 3092 89C2     		movl	%eax, %edx
 4093 3094 C1EA1F   		shrl	$31, %edx
 4094 3097 01D0     		addl	%edx, %eax
 4095 3099 D1F8     		sarl	%eax
 4096 309b 8945EC   		movl	%eax, -20(%rbp)
 958:main.c        **** 		i = i * 10;
 4097              		.loc 1 958 0
 4098 309e 8B55F8   		movl	-8(%rbp), %edx
 4099 30a1 89D0     		movl	%edx, %eax
 4100 30a3 C1E002   		sall	$2, %eax
 4101 30a6 01D0     		addl	%edx, %eax
 4102 30a8 01C0     		addl	%eax, %eax
 4103 30aa 8945F8   		movl	%eax, -8(%rbp)
 4104              	.L225:
 954:main.c        **** 		remainder = input % 2;
 4105              		.loc 1 954 0
 4106 30ad 837DEC00 		cmpl	$0, -20(%rbp)
 4107 30b1 7FC1     		jg	.L226
 959:main.c        **** 	}
 960:main.c        **** 
 961:main.c        ****         /* print the resultant binary value */
 962:main.c        **** 	return(result);
 4108              		.loc 1 962 0
 4109 30b3 8B45F4   		movl	-12(%rbp), %eax
 963:main.c        **** }
 4110              		.loc 1 963 0
 4111 30b6 5D       		popq	%rbp
 4112              		.cfi_def_cfa 7, 8
 4113 30b7 C3       		ret
 4114              		.cfi_endproc
 4115              	.LFE22:
 4117              		.section	.rodata
 4118 0316 0000     		.align 8
 4119              	.LC53:
 4120 0318 20202020 		.string	"            vendor ID and product ID (e.g 04B4:8613)"
 4120      20202020 
 4120      20202020 
 4120      76656E64 
 4120      6F722049 
 4121              	.LC54:
 4122 034d 3C564944 		.string	"<VID:PID>"
 4122      3A504944 
 4122      3E00
 4123              	.LC55:
 4124 0357 69767000 		.string	"ivp"
 4125              	.LC56:
 4126 035b 6900     		.string	"i"
 4127 035d 000000   		.align 8
 4128              	.LC57:
 4129 0360 20202020 		.string	"       VID, PID and opt. dev ID (e.g 1D50:602B:0001)"
 4129      20202056 
 4129      49442C20 
 4129      50494420 
 4129      616E6420 
 4130              	.LC58:
 4131 0395 3C564944 		.string	"<VID:PID[:DID]>"
 4131      3A504944 
 4131      5B3A4449 
 4131      445D3E00 
 4132              	.LC59:
 4133 03a5 767000   		.string	"vp"
 4134              	.LC60:
 4135 03a8 7600     		.string	"v"
 4136 03aa 00000000 		.align 8
 4136      0000
 4137              	.LC61:
 4138 03b0 20202020 		.string	"        firmware to RAM-load (or use std fw)"
 4138      20202020 
 4138      6669726D 
 4138      77617265 
 4138      20746F20 
 4139              	.LC62:
 4140 03dd 3C666972 		.string	"<firmware.hex>"
 4140      6D776172 
 4140      652E6865 
 4140      783E00
 4141              	.LC63:
 4142 03ec 667700   		.string	"fw"
 4143              	.LC64:
 4144 03ef 6600     		.string	"f"
 4145 03f1 00000000 		.align 8
 4145      000000
 4146              	.LC65:
 4147 03f8 20726561 		.string	" read/write digital ports (e.g B13+,C1-,B2?)"
 4147      642F7772 
 4147      69746520 
 4147      64696769 
 4147      74616C20 
 4148              	.LC66:
 4149 0425 3C626974 		.string	"<bitCfg[,bitCfg]*>"
 4149      4366675B 
 4149      2C626974 
 4149      4366675D 
 4149      2A3E00
 4150              	.LC67:
 4151 0438 706F7274 		.string	"ports"
 4151      7300
 4152              	.LC68:
 4153 043e 6400     		.string	"d"
 4154              	.LC69:
 4155 0440 20202020 		.string	"         query the JTAG chain"
 4155      20202020 
 4155      20717565 
 4155      72792074 
 4155      6865204A 
 4156              	.LC70:
 4157 045e 3C6A7461 		.string	"<jtagBits>"
 4157      67426974 
 4157      733E00
 4158              	.LC71:
 4159 0469 71756572 		.string	"query"
 4159      7900
 4160              	.LC72:
 4161 046f 7100     		.string	"q"
 4162              	.LC73:
 4163 0471 20202020 		.string	"         program a device"
 4163      20202020 
 4163      2070726F 
 4163      6772616D 
 4163      20612064 
 4164              	.LC74:
 4165 048b 3C636F6E 		.string	"<config>"
 4165      6669673E 
 4165      00
 4166              	.LC75:
 4167 0494 70726F67 		.string	"program"
 4167      72616D00 
 4168              	.LC76:
 4169 049c 7000     		.string	"p"
 4170 049e 0000     		.align 8
 4171              	.LC77:
 4172 04a0 20202020 		.string	"        which comm conduit to choose (default 0x01)"
 4172      20202020 
 4172      77686963 
 4172      6820636F 
 4172      6D6D2063 
 4173              	.LC78:
 4174 04d4 3C636F6E 		.string	"<conduit>"
 4174      64756974 
 4174      3E00
 4175              	.LC79:
 4176 04de 636F6E64 		.string	"conduit"
 4176      75697400 
 4177              	.LC80:
 4178 04e6 6300     		.string	"c"
 4179              		.align 8
 4180              	.LC81:
 4181 04e8 20202020 		.string	"    a series of CommFPGA actions"
 4181      61207365 
 4181      72696573 
 4181      206F6620 
 4181      436F6D6D 
 4182              	.LC82:
 4183 0509 3C616374 		.string	"<actionString>"
 4183      696F6E53 
 4183      7472696E 
 4183      673E00
 4184              	.LC83:
 4185 0518 61637469 		.string	"action"
 4185      6F6E00
 4186              	.LC84:
 4187 051f 6100     		.string	"a"
 4188 0521 00000000 		.align 8
 4188      000000
 4189              	.LC85:
 4190 0528 20202020 		.string	"                 some other stuff"
 4190      20202020 
 4190      20202020 
 4190      20202020 
 4190      20736F6D 
 4191              	.LC86:
 4192 054a 736F6D65 		.string	"some stuff"
 4192      20737475 
 4192      666600
 4193              	.LC87:
 4194 0555 7A00     		.string	"z"
 4195 0557 00       		.align 8
 4196              	.LC88:
 4197 0558 20202020 		.string	"                    start up an interactive CommFPGA session"
 4197      20202020 
 4197      20202020 
 4197      20202020 
 4197      20202020 
 4198              	.LC89:
 4199 0595 7368656C 		.string	"shell"
 4199      6C00
 4200              	.LC90:
 4201 059b 7300     		.string	"s"
 4202 059d 000000   		.align 8
 4203              	.LC91:
 4204 05a0 20202020 		.string	"                enable benchmarking & chefcksumming"
 4204      20202020 
 4204      20202020 
 4204      20202020 
 4204      656E6162 
 4205              	.LC92:
 4206 05d4 62656E63 		.string	"benchmark"
 4206      686D6172 
 4206      6B00
 4207              	.LC93:
 4208 05de 6200     		.string	"b"
 4209              		.align 8
 4210              	.LC94:
 4211 05e0 20202020 		.string	"                    reset the bulk endpoints"
 4211      20202020 
 4211      20202020 
 4211      20202020 
 4211      20202020 
 4212              	.LC95:
 4213 060d 72657365 		.string	"reset"
 4213      7400
 4214 0613 00000000 		.align 8
 4214      00
 4215              	.LC96:
 4216 0618 20202077 		.string	"   write data from channel ch to file"
 4216      72697465 
 4216      20646174 
 4216      61206672 
 4216      6F6D2063 
 4217              	.LC97:
 4218 063e 3C63683A 		.string	"<ch:file.bin>"
 4218      66696C65 
 4218      2E62696E 
 4218      3E00
 4219              	.LC98:
 4220 064c 64756D70 		.string	"dumploop"
 4220      6C6F6F70 
 4220      00
 4221              	.LC99:
 4222 0655 6C00     		.string	"l"
 4223 0657 00       		.align 8
 4224              	.LC100:
 4225 0658 20202020 		.string	"                     print this help and exit"
 4225      20202020 
 4225      20202020 
 4225      20202020 
 4225      20202020 
 4226              	.LC101:
 4227 0686 68656C70 		.string	"help"
 4227      00
 4228              	.LC102:
 4229 068b 6800     		.string	"h"
 4230 068d 000000   		.align 8
 4231              	.LC103:
 4232 0690 20202077 		.string	"   write firmware to FX2's EEPROM (!!)"
 4232      72697465 
 4232      20666972 
 4232      6D776172 
 4232      6520746F 
 4233              	.LC104:
 4234 06b7 3C737464 		.string	"<std|fw.hex|fw.iic>"
 4234      7C66772E 
 4234      6865787C 
 4234      66772E69 
 4234      69633E00 
 4235              	.LC105:
 4236 06cb 65657072 		.string	"eeprom"
 4236      6F6D00
 4237 06d2 00000000 		.align 8
 4237      0000
 4238              	.LC106:
 4239 06d8 20202020 		.string	"     backup FX2's EEPROM (e.g 128:fw.iic)\n"
 4239      20626163 
 4239      6B757020 
 4239      46583227 
 4239      73204545 
 4240              	.LC107:
 4241 0703 3C6B6269 		.string	"<kbitSize:fw.iic>"
 4241      7453697A 
 4241      653A6677 
 4241      2E696963 
 4241      3E00
 4242              	.LC108:
 4243 0715 6261636B 		.string	"backup"
 4243      757000
 4244              	.LC109:
 4245 071c 666C636C 		.string	"flcli"
 4245      6900
 4246              	.LC110:
 4247 0722 25733A20 		.string	"%s: insufficient memory\n"
 4247      696E7375 
 4247      66666963 
 4247      69656E74 
 4247      206D656D 
 4248 073b 00000000 		.align 8
 4248      00
 4249              	.LC111:
 4250 0740 46504741 		.string	"FPGALink Command-Line Interface Copyright (C) 2012-2014 Chris McClelland\n\nUsage: %s"
 4250      4C696E6B 
 4250      20436F6D 
 4250      6D616E64 
 4250      2D4C696E 
 4251              	.LC112:
 4252 0794 0A00     		.string	"\n"
 4253 0796 0000     		.align 8
 4254              	.LC113:
 4255 0798 0A496E74 		.string	"\nInteract with an FPGALink device.\n"
 4255      65726163 
 4255      74207769 
 4255      74682061 
 4255      6E204650 
 4256              	.LC114:
 4257 07bc 2020252D 		.string	"  %-10s %s\n"
 4257      31307320 
 4257      25730A00 
 4258              		.align 8
 4259              	.LC115:
 4260 07c8 54727920 		.string	"Try '%s --help' for more information.\n"
 4260      27257320 
 4260      2D2D6865 
 4260      6C702720 
 4260      666F7220 
 4261 07ef 00       		.align 8
 4262              	.LC116:
 4263 07f0 41747465 		.string	"Attempting to open connection to FPGALink device %s...\n"
 4263      6D707469 
 4263      6E672074 
 4263      6F206F70 
 4263      656E2063 
 4264              	.LC117:
 4265 0828 4C6F6164 		.string	"Loading firmware into %s...\n"
 4265      696E6720 
 4265      6669726D 
 4265      77617265 
 4265      20696E74 
 4266              	.LC118:
 4267 0845 41776169 		.string	"Awaiting renumeration"
 4267      74696E67 
 4267      2072656E 
 4267      756D6572 
 4267      6174696F 
 4268 085b 00000000 		.align 8
 4268      00
 4269              	.LC119:
 4270 0860 46504741 		.string	"FPGALink device did not renumerate properly as %s\n"
 4270      4C696E6B 
 4270      20646576 
 4270      69636520 
 4270      64696420 
 4271 0893 00000000 		.align 8
 4271      00
 4272              	.LC120:
 4273 0898 41747465 		.string	"Attempting to open connection to FPGLink device %s again...\n"
 4273      6D707469 
 4273      6E672074 
 4273      6F206F70 
 4273      656E2063 
 4274 08d5 000000   		.align 8
 4275              	.LC121:
 4276 08d8 436F756C 		.string	"Could not open FPGALink device at %s and no initial VID:PID was supplied\n"
 4276      64206E6F 
 4276      74206F70 
 4276      656E2046 
 4276      5047414C 
 4277 0922 00000000 		.align 8
 4277      0000
 4278              	.LC122:
 4279 0928 436F6E6E 		.string	"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n"
 4279      65637465 
 4279      6420746F 
 4279      20465047 
 4279      414C696E 
 4280              	.LC123:
 4281 0977 73746400 		.string	"std"
 4282 097b 00000000 		.align 8
 4282      00
 4283              	.LC124:
 4284 0980 57726974 		.string	"Writing the standard FPGALink firmware to the FX2's EEPROM..."
 4284      696E6720 
 4284      74686520 
 4284      7374616E 
 4284      64617264 
 4285 09be 0000     		.align 8
 4286              	.LC125:
 4287 09c0 57726974 		.string	"Writing custom FPGALink firmware from %s to the FX2's EEPROM...\n"
 4287      696E6720 
 4287      63757374 
 4287      6F6D2046 
 4287      5047414C 
 4288 0a01 00000000 		.align 8
 4288      000000
 4289              	.LC126:
 4290 0a08 25733A20 		.string	"%s: invalid argument to option --backup=<kbitSize:fw.iic>\n"
 4290      696E7661 
 4290      6C696420 
 4290      61726775 
 4290      6D656E74 
 4291 0a43 00000000 		.align 8
 4291      00
 4292              	.LC127:
 4293 0a48 53617669 		.string	"Saving a backup of %d kbit from the FX2's EEPROM to %s...\n"
 4293      6E672061 
 4293      20626163 
 4293      6B757020 
 4293      6F662025 
 4294              	.LC128:
 4295 0a83 436F6E66 		.string	"Configuring ports..."
 4295      69677572 
 4295      696E6720 
 4295      706F7274 
 4295      732E2E2E 
 4296              	.LC129:
 4297 0a98 25303858 		.string	"%08X"
 4297      00
 4298 0a9d 000000   		.align 8
 4299              	.LC130:
 4300 0aa0 52656164 		.string	"Readback:   28   24   20   16    12    8    4    0\n          %s"
 4300      6261636B 
 4300      3A202020 
 4300      32382020 
 4300      20323420 
 4301              	.LC131:
 4302 0ae0 20257300 		.string	" %s"
 4303              	.LC132:
 4304 0ae4 20202573 		.string	"  %s"
 4304      00
 4305              	.LC133:
 4306 0ae9 2025730A 		.string	" %s\n"
 4306      00
 4307 0aee 0000     		.align 8
 4308              	.LC134:
 4309 0af0 54686520 		.string	"The FPGALink device at %s scanned its JTAG chain, yielding:\n"
 4309      46504741 
 4309      4C696E6B 
 4309      20646576 
 4309      69636520 
 4310              	.LC135:
 4311 0b2d 20203078 		.string	"  0x%08X\n"
 4311      25303858 
 4311      0A00
 4312 0b37 00       		.align 8
 4313              	.LC136:
 4314 0b38 54686520 		.string	"The FPGALink device at %s scanned its JTAG chain but did not find any attached devices\n"
 4314      46504741 
 4314      4C696E6B 
 4314      20646576 
 4314      69636520 
 4315              		.align 8
 4316              	.LC137:
 4317 0b90 4A544147 		.string	"JTAG chain scan requested but FPGALink device at %s does not support NeroProg\n"
 4317      20636861 
 4317      696E2073 
 4317      63616E20 
 4317      72657175 
 4318              	.LC138:
 4319 0bdf 50726F67 		.string	"Programming device..."
 4319      72616D6D 
 4319      696E6720 
 4319      64657669 
 4319      63652E2E 
 4320 0bf5 000000   		.align 8
 4321              	.LC139:
 4322 0bf8 50726F67 		.string	"Program operation requested but device at %s does not support NeroProg\n"
 4322      72616D20 
 4322      6F706572 
 4322      6174696F 
 4322      6E207265 
 4323              		.align 8
 4324              	.LC140:
 4325 0c40 45786563 		.string	"Executing CommFPGA actions on FPGALink device %s...\n"
 4325      7574696E 
 4325      6720436F 
 4325      6D6D4650 
 4325      47412061 
 4326 0c75 000000   		.align 8
 4327              	.LC141:
 4328 0c78 54686520 		.string	"The FPGALink device at %s is not ready to talk - did you forget --program?\n"
 4328      46504741 
 4328      4C696E6B 
 4328      20646576 
 4328      69636520 
 4329 0cc4 00000000 		.align 8
 4330              	.LC142:
 4331 0cc8 41637469 		.string	"Action requested but device at %s does not support CommFPGA\n"
 4331      6F6E2072 
 4331      65717565 
 4331      73746564 
 4331      20627574 
 4332 0d05 000000   		.align 8
 4333              	.LC143:
 4334 0d08 25733A20 		.string	"%s: invalid argument to option -l|--dumploop=<ch:file.bin>\n"
 4334      696E7661 
 4334      6C696420 
 4334      61726775 
 4334      6D656E74 
 4335 0d44 00000000 		.align 8
 4336              	.LC144:
 4337 0d48 436F7079 		.string	"Copying from channel %lu to %s"
 4337      696E6720 
 4337      66726F6D 
 4337      20636861 
 4337      6E6E656C 
 4338              	.LC145:
 4339 0d67 0A436175 		.string	"\nCaught SIGINT, quitting..."
 4339      67687420 
 4339      53494749 
 4339      4E542C20 
 4339      71756974 
 4340 0d83 00000000 		.align 8
 4340      00
 4341              	.LC146:
 4342 0d88 0A456E74 		.string	"\nEntering CommFPGA command-line mode:"
 4342      6572696E 
 4342      6720436F 
 4342      6D6D4650 
 4342      47412063 
 4343              	.LC147:
 4344 0dae 3E2000   		.string	"> "
 4345 0db1 00000000 		.align 8
 4345      000000
 4346              	.LC148:
 4347 0db8 54686520 		.string	"The FPGALink device at %s is not ready to talk - did you forget --xsvf?\n"
 4347      46504741 
 4347      4C696E6B 
 4347      20646576 
 4347      69636520 
 4348 0e01 00000000 		.align 8
 4348      000000
 4349              	.LC149:
 4350 0e08 5368656C 		.string	"Shell requested but device at %s does not support CommFPGA\n"
 4350      6C207265 
 4350      71756573 
 4350      74656420 
 4350      62757420 
 4351              	.LC150:
 4352 0e44 4368616E 		.string	"Channel = "
 4352      6E656C20 
 4352      3D2000
 4353              	.LC151:
 4354 0e4f 257300   		.string	"%s"
 4355              	.LC152:
 4356 0e52 25640A00 		.string	"%d\n"
 4357 0e56 0000     		.align 8
 4358              	.LC153:
 4359 0e58 2D2D2D2D 		.string	"----------------------H2.1 started----------------------- "
 4359      2D2D2D2D 
 4359      2D2D2D2D 
 4359      2D2D2D2D 
 4359      2D2D2D2D 
 4360 0e93 00000000 		.align 8
 4360      00
 4361              	.LC154:
 4362 0e98 57616974 		.string	"Waiting for encrypted co_ordinates"
 4362      696E6720 
 4362      666F7220 
 4362      656E6372 
 4362      79707465 
 4363 0ebb 00000000 		.align 8
 4363      00
 4364              	.LC155:
 4365 0ec0 2D2D2D2D 		.string	"-------------------------RESET------------------------"
 4365      2D2D2D2D 
 4365      2D2D2D2D 
 4365      2D2D2D2D 
 4365      2D2D2D2D 
 4366 0ef7 00       		.align 8
 4367              	.LC156:
 4368 0ef8 476F7420 		.string	"Got the encrypted co_ordinates, they are as in uint8 form --"
 4368      74686520 
 4368      656E6372 
 4368      79707465 
 4368      6420636F 
 4369 0f35 000000   		.align 8
 4370              	.LC157:
 4371 0f38 656E6372 		.string	"encrypted_pos is converted to binary"
 4371      79707465 
 4371      645F706F 
 4371      73206973 
 4371      20636F6E 
 4372              	.LC158:
 4373 0f5d 54686520 		.string	"The encrypted_pos are as --"
 4373      656E6372 
 4373      79707465 
 4373      645F706F 
 4373      73206172 
 4374 0f79 00000000 		.align 8
 4374      000000
 4375              	.LC159:
 4376 0f80 54686520 		.string	"The decrypted pos in binary form are as --"
 4376      64656372 
 4376      79707465 
 4376      6420706F 
 4376      7320696E 
 4377 0fab 00000000 		.align 8
 4377      00
 4378              	.LC160:
 4379 0fb0 2D2D2D2D 		.string	"----------------------H2.1 ended----------------------- "
 4379      2D2D2D2D 
 4379      2D2D2D2D 
 4379      2D2D2D2D 
 4379      2D2D2D2D 
 4380 0fe9 00000000 		.align 8
 4380      000000
 4381              	.LC161:
 4382 0ff0 2D2D2D2D 		.string	"----------------------H2.2 started----------------------- "
 4382      2D2D2D2D 
 4382      2D2D2D2D 
 4382      2D2D2D2D 
 4382      2D2D2D2D 
 4383 102b 00000000 		.align 8
 4383      00
 4384              	.LC162:
 4385 1030 54686520 		.string	"The co_ordinates are re-encrypted in binary form"
 4385      636F5F6F 
 4385      7264696E 
 4385      61746573 
 4385      20617265 
 4386 1061 00000000 		.align 8
 4386      000000
 4387              	.LC163:
 4388 1068 54686520 		.string	"The re-encrypted co_ords are as follows"
 4388      72652D65 
 4388      6E637279 
 4388      70746564 
 4388      20636F5F 
 4389              		.align 8
 4390              	.LC164:
 4391 1090 436F6E76 		.string	"Converting the re-encrypted data in binary to uint8 form"
 4391      65727469 
 4391      6E672074 
 4391      68652072 
 4391      652D656E 
 4392 10c9 00000000 		.align 8
 4392      000000
 4393              	.LC165:
 4394 10d0 50726570 		.string	"Preparing to send the encrypted co_ordinates "
 4394      6172696E 
 4394      6720746F 
 4394      2073656E 
 4394      64207468 
 4395 10fe 0000     		.align 8
 4396              	.LC166:
 4397 1100 53756363 		.string	"Successfully send the encrypted co_ordinates in uint8 form"
 4397      65737366 
 4397      756C6C79 
 4397      2073656E 
 4397      64207468 
 4398 113b 00000000 		.align 8
 4398      00
 4399              	.LC167:
 4400 1140 2D2D2D2D 		.string	"----------------------H2.2 ended----------------------- "
 4400      2D2D2D2D 
 4400      2D2D2D2D 
 4400      2D2D2D2D 
 4400      2D2D2D2D 
 4401 1179 00000000 		.align 8
 4401      000000
 4402              	.LC168:
 4403 1180 2D2D2D2D 		.string	"----------------------H2.3 started----------------------- "
 4403      2D2D2D2D 
 4403      2D2D2D2D 
 4403      2D2D2D2D 
 4403      2D2D2D2D 
 4404 11bb 00000000 		.align 8
 4404      00
 4405              	.LC169:
 4406 11c0 57616974 		.string	"Waiting to get Ack1 from the fpga controller"
 4406      696E6720 
 4406      746F2067 
 4406      65742041 
 4406      636B3120 
 4407 11ed 000000   		.align 8
 4408              	.LC170:
 4409 11f0 46697273 		.string	"First ack1 received successfully"
 4409      74206163 
 4409      6B312072 
 4409      65636569 
 4409      76656420 
 4410 1211 00000000 		.align 8
 4410      000000
 4411              	.LC171:
 4412 1218 54686520 		.string	"The first ack1 is ----- in uint8 form"
 4412      66697273 
 4412      74206163 
 4412      6B312069 
 4412      73202D2D 
 4413 123e 0000     		.align 8
 4414              	.LC172:
 4415 1240 2D2D2D2D 		.string	"----------------------H2.3 ended----------------------- "
 4415      2D2D2D2D 
 4415      2D2D2D2D 
 4415      2D2D2D2D 
 4415      2D2D2D2D 
 4416 1279 00000000 		.align 8
 4416      000000
 4417              	.LC173:
 4418 1280 2D2D2D2D 		.string	"----------------------H2.4 started----------------------- "
 4418      2D2D2D2D 
 4418      2D2D2D2D 
 4418      2D2D2D2D 
 4418      2D2D2D2D 
 4419 12bb 00000000 		.align 8
 4419      00
 4420              	.LC174:
 4421 12c0 436F6E76 		.string	"Converting encrypted ack1 from uint8 to binary"
 4421      65727469 
 4421      6E672065 
 4421      6E637279 
 4421      70746564 
 4422 12ef 00       		.align 8
 4423              	.LC175:
 4424 12f0 54686520 		.string	"The encrypted ack1 is as follows in binary form --"
 4424      656E6372 
 4424      79707465 
 4424      64206163 
 4424      6B312069 
 4425 1323 00000000 		.align 8
 4425      00
 4426              	.LC176:
 4427 1328 54686520 		.string	"The decrypted ack1 in binary is as follows --"
 4427      64656372 
 4427      79707465 
 4427      64206163 
 4427      6B312069 
 4428 1356 0000     		.align 8
 4429              	.LC177:
 4430 1358 43686563 		.string	"Checking if this ack1 is equal to the original ack1 "
 4430      6B696E67 
 4430      20696620 
 4430      74686973 
 4430      2061636B 
 4431 138d 000000   		.align 8
 4432              	.LC178:
 4433 1390 41636B31 		.string	"Ack1 received doesn't match with the original one"
 4433      20726563 
 4433      65697665 
 4433      6420646F 
 4433      65736E27 
 4434              	.LC179:
 4435 13c2 52656164 		.string	"Reading the channel 2i again "
 4435      696E6720 
 4435      74686520 
 4435      6368616E 
 4435      6E656C20 
 4436              		.align 8
 4437              	.LC180:
 4438 13e0 47657420 		.string	"Get the encrypted ack1 again successfully ---"
 4438      74686520 
 4438      656E6372 
 4438      79707465 
 4438      64206163 
 4439 140e 0000     		.align 8
 4440              	.LC181:
 4441 1410 436F6E76 		.string	"Converted encrypted ack1 to binary and it is as ----"
 4441      65727465 
 4441      6420656E 
 4441      63727970 
 4441      74656420 
 4442 1445 000000   		.align 8
 4443              	.LC182:
 4444 1448 44656372 		.string	"Decrypting the encrypted ack1 "
 4444      79707469 
 4444      6E672074 
 4444      68652065 
 4444      6E637279 
 4445 1467 00       		.align 8
 4446              	.LC183:
 4447 1468 41636B31 		.string	"Ack1 got decrpyted and is as ----"
 4447      20676F74 
 4447      20646563 
 4447      72707974 
 4447      65642061 
 4448 148a 00000000 		.align 8
 4448      0000
 4449              	.LC184:
 4450 1490 2D2D2D2D 		.string	"----------------------H2.4 ended----------------------- "
 4450      2D2D2D2D 
 4450      2D2D2D2D 
 4450      2D2D2D2D 
 4450      2D2D2D2D 
 4451 14c9 00000000 		.align 8
 4451      000000
 4452              	.LC185:
 4453 14d0 2D2D2D2D 		.string	"-------------------------H2.5 started-------------------------"
 4453      2D2D2D2D 
 4453      2D2D2D2D 
 4453      2D2D2D2D 
 4453      2D2D2D2D 
 4454 150f 00       		.align 8
 4455              	.LC186:
 4456 1510 4661696C 		.string	"Fails to receive encrypted ack1 "
 4456      7320746F 
 4456      20726563 
 4456      65697665 
 4456      20656E63 
 4457 1531 00000000 		.align 8
 4457      000000
 4458              	.LC187:
 4459 1538 2D2D2D2D 		.string	"-------------------------H2.5 ended-------------------------"
 4459      2D2D2D2D 
 4459      2D2D2D2D 
 4459      2D2D2D2D 
 4459      2D2D2D2D 
 4460 1575 000000   		.align 8
 4461              	.LC188:
 4462 1578 2D2D2D2D 		.string	"-------------------------H3 starts--------------------------"
 4462      2D2D2D2D 
 4462      2D2D2D2D 
 4462      2D2D2D2D 
 4462      2D2D2D2D 
 4463              	.LC189:
 4464 15b5 656E6372 		.string	"encrypting ack2 "
 4464      79707469 
 4464      6E672061 
 4464      636B3220 
 4464      00
 4465 15c6 0000     		.align 8
 4466              	.LC190:
 4467 15c8 41636B32 		.string	"Ack2 got encrypted and it is as -----"
 4467      20676F74 
 4467      20656E63 
 4467      72797074 
 4467      65642061 
 4468 15ee 0000     		.align 8
 4469              	.LC191:
 4470 15f0 436F6E76 		.string	"Converting encrypted ack2 from binary to uint8"
 4470      65727469 
 4470      6E672065 
 4470      6E637279 
 4470      70746564 
 4471 161f 00       		.align 8
 4472              	.LC192:
 4473 1620 436F6E76 		.string	"Converted encrypted ack2 to uint8 and it is as -----"
 4473      65727465 
 4473      6420656E 
 4473      63727970 
 4473      74656420 
 4474 1655 000000   		.align 8
 4475              	.LC193:
 4476 1658 53656E64 		.string	"Sending encrypted ack2 to fpga "
 4476      696E6720 
 4476      656E6372 
 4476      79707465 
 4476      64206163 
 4477              		.align 8
 4478              	.LC194:
 4479 1678 456E6372 		.string	"Encrypted ack2 send successfully"
 4479      79707465 
 4479      64206163 
 4479      6B322073 
 4479      656E6420 
 4480 1699 00000000 		.align 8
 4480      000000
 4481              	.LC195:
 4482 16a0 2D2D2D2D 		.string	"-------------------------H3 ended----------------------------"
 4482      2D2D2D2D 
 4482      2D2D2D2D 
 4482      2D2D2D2D 
 4482      2D2D2D2D 
 4483 16de 0000     		.align 8
 4484              	.LC196:
 4485 16e0 2D2D2D2D 		.string	"-------------------------H4 started--------------------------"
 4485      2D2D2D2D 
 4485      2D2D2D2D 
 4485      2D2D2D2D 
 4485      2D2D2D2D 
 4486 171e 0000     		.align 8
 4487              	.LC197:
 4488 1720 43616C63 		.string	"Calculating x and y co_ordinates ------------------"
 4488      756C6174 
 4488      696E6720 
 4488      7820616E 
 4488      64207920 
 4489 1754 00000000 		.align 8
 4490              	.LC198:
 4491 1758 7820616E 		.string	"x and y co_ordinates calculated, they are as --"
 4491      64207920 
 4491      636F5F6F 
 4491      7264696E 
 4491      61746573 
 4492              	.LC199:
 4493 1788 25642025 		.string	"%d %d "
 4493      642000
 4494 178f 00       		.align 8
 4495              	.LC200:
 4496 1790 476F7420 		.string	"Got the information for x and y co_ordinates, 64 bits filled"
 4496      74686520 
 4496      696E666F 
 4496      726D6174 
 4496      696F6E20 
 4497 17cd 000000   		.align 8
 4498              	.LC201:
 4499 17d0 54686520 		.string	"The final 64 bit array in decrypted form --"
 4499      66696E61 
 4499      6C203634 
 4499      20626974 
 4499      20617272 
 4500 17fc 00000000 		.align 8
 4501              	.LC202:
 4502 1800 2D2D2D2D 		.string	"-------------------------H4 ended--------------------------"
 4502      2D2D2D2D 
 4502      2D2D2D2D 
 4502      2D2D2D2D 
 4502      2D2D2D2D 
 4503 183c 00000000 		.align 8
 4504              	.LC203:
 4505 1840 2D2D2D2D 		.string	"-------------------------H5 starts--------------------------"
 4505      2D2D2D2D 
 4505      2D2D2D2D 
 4505      2D2D2D2D 
 4505      2D2D2D2D 
 4506 187d 000000   		.align 8
 4507              	.LC204:
 4508 1880 456E6372 		.string	"Encrypting first 32 bits of final array"
 4508      79707469 
 4508      6E672066 
 4508      69727374 
 4508      20333220 
 4509              		.align 8
 4510              	.LC205:
 4511 18a8 46697273 		.string	"First 32 bits got encrypted , they are as ----"
 4511      74203332 
 4511      20626974 
 4511      7320676F 
 4511      7420656E 
 4512 18d7 00       		.align 8
 4513              	.LC206:
 4514 18d8 436F6E76 		.string	"Converting first 32 bits to uint8"
 4514      65727469 
 4514      6E672066 
 4514      69727374 
 4514      20333220 
 4515 18fa 00000000 		.align 8
 4515      0000
 4516              	.LC207:
 4517 1900 46697273 		.string	"First 32 bits got converted to uint8, they are as"
 4517      74203332 
 4517      20626974 
 4517      7320676F 
 4517      7420636F 
 4518 1932 00000000 		.align 8
 4518      0000
 4519              	.LC208:
 4520 1938 57726974 		.string	"Writing on channel first 32 bits encrypted"
 4520      696E6720 
 4520      6F6E2063 
 4520      68616E6E 
 4520      656C2066 
 4521 1963 00000000 		.align 8
 4521      00
 4522              	.LC209:
 4523 1968 2D2D2D2D 		.string	"-----------------------------H5 ends------------------"
 4523      2D2D2D2D 
 4523      2D2D2D2D 
 4523      2D2D2D2D 
 4523      2D2D2D2D 
 4524 199f 00       		.align 8
 4525              	.LC210:
 4526 19a0 2D2D2D2D 		.string	"-----------------------------H6 starts------------------"
 4526      2D2D2D2D 
 4526      2D2D2D2D 
 4526      2D2D2D2D 
 4526      2D2D2D2D 
 4527              	.LC211:
 4528 19d9 57616974 		.string	"Waiting for encrypted ack1 "
 4528      696E6720 
 4528      666F7220 
 4528      656E6372 
 4528      79707465 
 4529 19f5 000000   		.align 8
 4530              	.LC212:
 4531 19f8 2D2D2D2D 		.string	"-----------------------------H7 starts------------------"
 4531      2D2D2D2D 
 4531      2D2D2D2D 
 4531      2D2D2D2D 
 4531      2D2D2D2D 
 4532 1a31 00000000 		.align 8
 4532      000000
 4533              	.LC214:
 4534 1a38 476F696E 		.string	"Going to H2, time exceeded 256 seconds"
 4534      6720746F 
 4534      2048322C 
 4534      2074696D 
 4534      65206578 
 4535 1a5f 00       		.align 8
 4536              	.LC215:
 4537 1a60 41636B31 		.string	"Ack1 received successfully, not checked yet, it is as----"
 4537      20726563 
 4537      65697665 
 4537      64207375 
 4537      63636573 
 4538 1a9a 00000000 		.align 8
 4538      0000
 4539              	.LC216:
 4540 1aa0 436F6E76 		.string	"Converted encrypted ack1 from uint8 to binary , it is as --"
 4540      65727465 
 4540      6420656E 
 4540      63727970 
 4540      74656420 
 4541              	.LC217:
 4542 1adc 44656372 		.string	"Decrypting the encrypted ack1"
 4542      79707469 
 4542      6E672074 
 4542      68652065 
 4542      6E637279 
 4543 1afa 00000000 		.align 8
 4543      0000
 4544              	.LC218:
 4545 1b00 456E6372 		.string	"Encrypted ack1 decrypted successfully, it is as----"
 4545      79707465 
 4545      64206163 
 4545      6B312064 
 4545      65637279 
 4546              	.LC219:
 4547 1b34 41636B31 		.string	"Ack1 doesn't match"
 4547      20646F65 
 4547      736E2774 
 4547      206D6174 
 4547      636800
 4548              	.LC220:
 4549 1b47 41636B31 		.string	"Ack1 match successfully"
 4549      206D6174 
 4549      63682073 
 4549      75636365 
 4549      73736675 
 4550 1b5f 00       		.align 8
 4551              	.LC221:
 4552 1b60 656E6372 		.string	"encrypting last 32 bits to send to fpga "
 4552      79707469 
 4552      6E67206C 
 4552      61737420 
 4552      33322062 
 4553 1b89 00000000 		.align 8
 4553      000000
 4554              	.LC222:
 4555 1b90 4C617374 		.string	"Last 32 bits got encrypted , they are as in binary form"
 4555      20333220 
 4555      62697473 
 4555      20676F74 
 4555      20656E63 
 4556              		.align 8
 4557              	.LC223:
 4558 1bc8 436F6E76 		.string	"Converting last 32 bits to uint8"
 4558      65727469 
 4558      6E67206C 
 4558      61737420 
 4558      33322062 
 4559 1be9 00000000 		.align 8
 4559      000000
 4560              	.LC224:
 4561 1bf0 4C617374 		.string	"Last 32 bits got converted to uint8, they are as"
 4561      20333220 
 4561      62697473 
 4561      20676F74 
 4561      20636F6E 
 4562 1c21 00000000 		.align 8
 4562      000000
 4563              	.LC225:
 4564 1c28 57726974 		.string	"Writing on channel last 32 bits encrypted"
 4564      696E6720 
 4564      6F6E2063 
 4564      68616E6E 
 4564      656C206C 
 4565 1c52 00000000 		.align 8
 4565      0000
 4566              	.LC226:
 4567 1c58 53756363 		.string	"Successfully written last 32 bits"
 4567      65737366 
 4567      756C6C79 
 4567      20777269 
 4567      7474656E 
 4568 1c7a 00000000 		.align 8
 4568      0000
 4569              	.LC227:
 4570 1c80 2D2D2D2D 		.string	"---------------------------------H7 ends---------------------"
 4570      2D2D2D2D 
 4570      2D2D2D2D 
 4570      2D2D2D2D 
 4570      2D2D2D2D 
 4571              	.LC228:
 4572 1cbe 456E6372 		.string	"Encrypting ack2 "
 4572      79707469 
 4572      6E672061 
 4572      636B3220 
 4572      00
 4573 1ccf 00       		.align 8
 4574              	.LC229:
 4575 1cd0 456E6372 		.string	"Encrypted ack2 is as follows  ----"
 4575      79707465 
 4575      64206163 
 4575      6B322069 
 4575      73206173 
 4576 1cf3 00000000 		.align 8
 4576      00
 4577              	.LC230:
 4578 1cf8 436F6E76 		.string	"Converted encrypted ack2 to uint8, it is as follows"
 4578      65727465 
 4578      6420656E 
 4578      63727970 
 4578      74656420 
 4579 1d2c 00000000 		.align 8
 4580              	.LC231:
 4581 1d30 57726974 		.string	"Writing encrypted ack2 to channel"
 4581      696E6720 
 4581      656E6372 
 4581      79707465 
 4581      64206163 
 4582 1d52 00000000 		.align 8
 4582      0000
 4583              	.LC232:
 4584 1d58 57726974 		.string	"Written successfully encrypted ack2, the written data is --"
 4584      74656E20 
 4584      73756363 
 4584      65737366 
 4584      756C6C79 
 4585 1d94 00000000 		.align 8
 4586              	.LC233:
 4587 1d98 52656365 		.string	"Receiving data to update CSV file"
 4587      6976696E 
 4587      67206461 
 4587      74612074 
 4587      6F207570 
 4588 1dba 00000000 		.align 8
 4588      0000
 4589              	.LC234:
 4590 1dc0 4E6F2064 		.string	"No data from FPGA, gping to UART part"
 4590      61746120 
 4590      66726F6D 
 4590      20465047 
 4590      412C2067 
 4591 1de6 0000     		.align 8
 4592              	.LC235:
 4593 1de8 436F6E74 		.string	"Controlling signal is to update the CSV data"
 4593      726F6C6C 
 4593      696E6720 
 4593      7369676E 
 4593      616C2069 
 4594 1e15 000000   		.align 8
 4595              	.LC236:
 4596 1e18 52656365 		.string	"Receiving encrypted data from the FPGA to update CSV"
 4596      6976696E 
 4596      6720656E 
 4596      63727970 
 4596      74656420 
 4597 1e4d 000000   		.align 8
 4598              	.LC237:
 4599 1e50 456E6372 		.string	"Encrypted Data received successfully from the FPGA, it is as in uint8 format-----"
 4599      79707465 
 4599      64204461 
 4599      74612072 
 4599      65636569 
 4600 1ea2 00000000 		.align 8
 4600      0000
 4601              	.LC238:
 4602 1ea8 436F6E76 		.string	"Converting uint8 data to binary"
 4602      65727469 
 4602      6E672075 
 4602      696E7438 
 4602      20646174 
 4603              		.align 8
 4604              	.LC239:
 4605 1ec8 436F6E76 		.string	"Converted uint8 data to binary, it is as-----"
 4605      65727465 
 4605      64207569 
 4605      6E743820 
 4605      64617461 
 4606              	.LC240:
 4607 1ef6 44656372 		.string	"Decrypting the data"
 4607      79707469 
 4607      6E672074 
 4607      68652064 
 4607      61746100 
 4608 1f0a 00000000 		.align 8
 4608      0000
 4609              	.LC241:
 4610 1f10 44617461 		.string	"Data decrypted successfully, it is as----"
 4610      20646563 
 4610      72797074 
 4610      65642073 
 4610      75636365 
 4611              	.LC242:
 4612 1f3a 47657474 		.string	"Getting ready to update CSV"
 4612      696E6720 
 4612      72656164 
 4612      7920746F 
 4612      20757064 
 4613 1f56 0000     		.align 8
 4614              	.LC243:
 4615 1f58 2D2D2D2D 		.string	"-------------------------UART PART----------------------------"
 4615      2D2D2D2D 
 4615      2D2D2D2D 
 4615      2D2D2D2D 
 4615      2D2D2D2D 
 4616              	.LC244:
 4617 1f97 55415254 		.string	"UART part done"
 4617      20706172 
 4617      7420646F 
 4617      6E6500
 4618 1fa6 0000     		.align 8
 4619              	.LC245:
 4620 1fa8 54686520 		.string	"The information received from FPGA"
 4620      696E666F 
 4620      726D6174 
 4620      696F6E20 
 4620      72656365 
 4621              	.LC246:
 4622 1fcb 54686520 		.string	"The x_cord ----->"
 4622      785F636F 
 4622      7264202D 
 4622      2D2D2D2D 
 4622      3E00
 4623              	.LC247:
 4624 1fdd 54686520 		.string	"The y_cord ----->"
 4624      795F636F 
 4624      7264202D 
 4624      2D2D2D2D 
 4624      3E00
 4625              	.LC248:
 4626 1fef 54726163 		.string	"Track exists   ---->   "
 4626      6B206578 
 4626      69737473 
 4626      2020202D 
 4626      2D2D2D3E 
 4627              	.LC249:
 4628 2007 25732000 		.string	"%s "
 4629              	.LC250:
 4630 200b 54726163 		.string	"Track ok   ----->   "
 4630      6B206F6B 
 4630      2020202D 
 4630      2D2D2D2D 
 4630      3E202020 
 4631              	.LC251:
 4632 2020 44697265 		.string	"Direction   ----->   "
 4632      6374696F 
 4632      6E202020 
 4632      2D2D2D2D 
 4632      2D3E2020 
 4633              	.LC252:
 4634 2036 4E657874 		.string	"Next signal   ------>    "
 4634      20736967 
 4634      6E616C20 
 4634      20202D2D 
 4634      2D2D2D2D 
 4635              		.align 8
 4636              	.LC253:
 4637 2050 4F766572 		.string	"Overwriting the CSV file with the updated information"
 4637      77726974 
 4637      696E6720 
 4637      74686520 
 4637      43535620 
 4638 2086 0000     		.align 8
 4639              	.LC254:
 4640 2088 43535620 		.string	"CSV file overwritten successfully"
 4640      66696C65 
 4640      206F7665 
 4640      72777269 
 4640      7474656E 
 4641              	.LC255:
 4642 20aa 25730A00 		.string	"%s\n"
 4643              		.text
 4644              		.globl	main
 4646              	main:
 4647              	.LFB23:
 964:main.c        **** 
 965:main.c        **** // void decToBinary(int n, int arr[], int count)
 966:main.c        **** // {
 967:main.c        **** //     int binaryNum[count];
 968:main.c        **** //     for (int i = 0; i < count; ++i)
 969:main.c        **** //       binaryNum[i] = 0;
 970:main.c        **** 
 971:main.c        **** //     int i = 0;
 972:main.c        **** //     while (n > 0) {
 973:main.c        **** //         binaryNum[i] = n % 2;
 974:main.c        **** //         n = n / 2;
 975:main.c        **** //         i++;
 976:main.c        **** //     }
 977:main.c        **** 
 978:main.c        **** //      for (int i=0; i<count; i++)
 979:main.c        **** //         arr[i] = binaryNum[i];
 980:main.c        **** // }
 981:main.c        **** 
 982:main.c        **** //////////////////////////////////////////////////////////////////////////////////
 983:main.c        **** 
 984:main.c        **** 
 985:main.c        **** int main(int argc, char *argv[]) {
 4648              		.loc 1 985 0
 4649              		.cfi_startproc
 4650 30b8 55       		pushq	%rbp
 4651              		.cfi_def_cfa_offset 16
 4652              		.cfi_offset 6, -16
 4653 30b9 4889E5   		movq	%rsp, %rbp
 4654              		.cfi_def_cfa_register 6
 4655 30bc 53       		pushq	%rbx
 4656 30bd 4881EC68 		subq	$3432, %rsp
 4656      0D0000
 4657              		.cfi_offset 3, -24
 4658 30c4 89BD9CF2 		movl	%edi, -3428(%rbp)
 4658      FFFF
 4659 30ca 4889B590 		movq	%rsi, -3440(%rbp)
 4659      F2FFFF
 4660              		.loc 1 985 0
 4661 30d1 64488B04 		movq	%fs:40, %rax
 4661      25280000 
 4661      00
 4662 30da 488945E8 		movq	%rax, -24(%rbp)
 4663 30de 31C0     		xorl	%eax, %eax
 986:main.c        **** 	ReturnCode retVal = FLP_SUCCESS, pStatus;
 4664              		.loc 1 986 0
 4665 30e0 C785B8F2 		movl	$0, -3400(%rbp)
 4665      FFFF0000 
 4665      0000
 987:main.c        **** 	struct arg_str *ivpOpt = arg_str0("i", "ivp", "<VID:PID>", "            vendor ID and product ID (
 4666              		.loc 1 987 0
 4667 30ea B9000000 		movl	$.LC53, %ecx
 4667      00
 4668 30ef BA000000 		movl	$.LC54, %edx
 4668      00
 4669 30f4 BE000000 		movl	$.LC55, %esi
 4669      00
 4670 30f9 BF000000 		movl	$.LC56, %edi
 4670      00
 4671 30fe E8000000 		call	arg_str0
 4671      00
 4672 3103 48898520 		movq	%rax, -3040(%rbp)
 4672      F4FFFF
 988:main.c        **** 	struct arg_str *vpOpt = arg_str1("v", "vp", "<VID:PID[:DID]>", "       VID, PID and opt. dev ID (e
 4673              		.loc 1 988 0
 4674 310a B9000000 		movl	$.LC57, %ecx
 4674      00
 4675 310f BA000000 		movl	$.LC58, %edx
 4675      00
 4676 3114 BE000000 		movl	$.LC59, %esi
 4676      00
 4677 3119 BF000000 		movl	$.LC60, %edi
 4677      00
 4678 311e E8000000 		call	arg_str1
 4678      00
 4679 3123 48898528 		movq	%rax, -3032(%rbp)
 4679      F4FFFF
 989:main.c        **** 	struct arg_str *fwOpt = arg_str0("f", "fw", "<firmware.hex>", "        firmware to RAM-load (or us
 4680              		.loc 1 989 0
 4681 312a B9000000 		movl	$.LC61, %ecx
 4681      00
 4682 312f BA000000 		movl	$.LC62, %edx
 4682      00
 4683 3134 BE000000 		movl	$.LC63, %esi
 4683      00
 4684 3139 BF000000 		movl	$.LC64, %edi
 4684      00
 4685 313e E8000000 		call	arg_str0
 4685      00
 4686 3143 48898530 		movq	%rax, -3024(%rbp)
 4686      F4FFFF
 990:main.c        **** 	struct arg_str *portOpt = arg_str0("d", "ports", "<bitCfg[,bitCfg]*>", " read/write digital ports 
 4687              		.loc 1 990 0
 4688 314a B9000000 		movl	$.LC65, %ecx
 4688      00
 4689 314f BA000000 		movl	$.LC66, %edx
 4689      00
 4690 3154 BE000000 		movl	$.LC67, %esi
 4690      00
 4691 3159 BF000000 		movl	$.LC68, %edi
 4691      00
 4692 315e E8000000 		call	arg_str0
 4692      00
 4693 3163 48898538 		movq	%rax, -3016(%rbp)
 4693      F4FFFF
 991:main.c        **** 	struct arg_str *queryOpt = arg_str0("q", "query", "<jtagBits>", "         query the JTAG chain");
 4694              		.loc 1 991 0
 4695 316a B9000000 		movl	$.LC69, %ecx
 4695      00
 4696 316f BA000000 		movl	$.LC70, %edx
 4696      00
 4697 3174 BE000000 		movl	$.LC71, %esi
 4697      00
 4698 3179 BF000000 		movl	$.LC72, %edi
 4698      00
 4699 317e E8000000 		call	arg_str0
 4699      00
 4700 3183 48898540 		movq	%rax, -3008(%rbp)
 4700      F4FFFF
 992:main.c        **** 	struct arg_str *progOpt = arg_str0("p", "program", "<config>", "         program a device");
 4701              		.loc 1 992 0
 4702 318a B9000000 		movl	$.LC73, %ecx
 4702      00
 4703 318f BA000000 		movl	$.LC74, %edx
 4703      00
 4704 3194 BE000000 		movl	$.LC75, %esi
 4704      00
 4705 3199 BF000000 		movl	$.LC76, %edi
 4705      00
 4706 319e E8000000 		call	arg_str0
 4706      00
 4707 31a3 48898548 		movq	%rax, -3000(%rbp)
 4707      F4FFFF
 993:main.c        **** 	struct arg_uint *conOpt = arg_uint0("c", "conduit", "<conduit>", "        which comm conduit to ch
 4708              		.loc 1 993 0
 4709 31aa B9000000 		movl	$.LC77, %ecx
 4709      00
 4710 31af BA000000 		movl	$.LC78, %edx
 4710      00
 4711 31b4 BE000000 		movl	$.LC79, %esi
 4711      00
 4712 31b9 BF000000 		movl	$.LC80, %edi
 4712      00
 4713 31be E8000000 		call	arg_uint0
 4713      00
 4714 31c3 48898550 		movq	%rax, -2992(%rbp)
 4714      F4FFFF
 994:main.c        **** 	struct arg_str *actOpt = arg_str0("a", "action", "<actionString>", "    a series of CommFPGA actio
 4715              		.loc 1 994 0
 4716 31ca B9000000 		movl	$.LC81, %ecx
 4716      00
 4717 31cf BA000000 		movl	$.LC82, %edx
 4717      00
 4718 31d4 BE000000 		movl	$.LC83, %esi
 4718      00
 4719 31d9 BF000000 		movl	$.LC84, %edi
 4719      00
 4720 31de E8000000 		call	arg_str0
 4720      00
 4721 31e3 48898558 		movq	%rax, -2984(%rbp)
 4721      F4FFFF
 995:main.c        **** 	struct arg_lit *doworkOpt = arg_lit0("z", "some stuff" ,"                 some other stuff");
 4722              		.loc 1 995 0
 4723 31ea BA000000 		movl	$.LC85, %edx
 4723      00
 4724 31ef BE000000 		movl	$.LC86, %esi
 4724      00
 4725 31f4 BF000000 		movl	$.LC87, %edi
 4725      00
 4726 31f9 E8000000 		call	arg_lit0
 4726      00
 4727 31fe 48898560 		movq	%rax, -2976(%rbp)
 4727      F4FFFF
 996:main.c        **** 	struct arg_lit *shellOpt  = arg_lit0("s", "shell", "                    start up an interactive Co
 4728              		.loc 1 996 0
 4729 3205 BA000000 		movl	$.LC88, %edx
 4729      00
 4730 320a BE000000 		movl	$.LC89, %esi
 4730      00
 4731 320f BF000000 		movl	$.LC90, %edi
 4731      00
 4732 3214 E8000000 		call	arg_lit0
 4732      00
 4733 3219 48898568 		movq	%rax, -2968(%rbp)
 4733      F4FFFF
 997:main.c        **** 	struct arg_lit *benOpt  = arg_lit0("b", "benchmark", "                enable benchmarking & chefck
 4734              		.loc 1 997 0
 4735 3220 BA000000 		movl	$.LC91, %edx
 4735      00
 4736 3225 BE000000 		movl	$.LC92, %esi
 4736      00
 4737 322a BF000000 		movl	$.LC93, %edi
 4737      00
 4738 322f E8000000 		call	arg_lit0
 4738      00
 4739 3234 48898570 		movq	%rax, -2960(%rbp)
 4739      F4FFFF
 998:main.c        **** 	struct arg_lit *rstOpt  = arg_lit0("r", "reset", "                    reset the bulk endpoints");
 4740              		.loc 1 998 0
 4741 323b BA000000 		movl	$.LC94, %edx
 4741      00
 4742 3240 BE000000 		movl	$.LC95, %esi
 4742      00
 4743 3245 BF000000 		movl	$.LC6, %edi
 4743      00
 4744 324a E8000000 		call	arg_lit0
 4744      00
 4745 324f 48898578 		movq	%rax, -2952(%rbp)
 4745      F4FFFF
 999:main.c        **** 	struct arg_str *dumpOpt = arg_str0("l", "dumploop", "<ch:file.bin>", "   write data from channel c
 4746              		.loc 1 999 0
 4747 3256 B9000000 		movl	$.LC96, %ecx
 4747      00
 4748 325b BA000000 		movl	$.LC97, %edx
 4748      00
 4749 3260 BE000000 		movl	$.LC98, %esi
 4749      00
 4750 3265 BF000000 		movl	$.LC99, %edi
 4750      00
 4751 326a E8000000 		call	arg_str0
 4751      00
 4752 326f 48898580 		movq	%rax, -2944(%rbp)
 4752      F4FFFF
1000:main.c        **** 	struct arg_lit *helpOpt  = arg_lit0("h", "help", "                     print this help and exit");
 4753              		.loc 1 1000 0
 4754 3276 BA000000 		movl	$.LC100, %edx
 4754      00
 4755 327b BE000000 		movl	$.LC101, %esi
 4755      00
 4756 3280 BF000000 		movl	$.LC102, %edi
 4756      00
 4757 3285 E8000000 		call	arg_lit0
 4757      00
 4758 328a 48898588 		movq	%rax, -2936(%rbp)
 4758      F4FFFF
1001:main.c        **** 	struct arg_str *eepromOpt  = arg_str0(NULL, "eeprom", "<std|fw.hex|fw.iic>", "   write firmware to
 4759              		.loc 1 1001 0
 4760 3291 B9000000 		movl	$.LC103, %ecx
 4760      00
 4761 3296 BA000000 		movl	$.LC104, %edx
 4761      00
 4762 329b BE000000 		movl	$.LC105, %esi
 4762      00
 4763 32a0 BF000000 		movl	$0, %edi
 4763      00
 4764 32a5 E8000000 		call	arg_str0
 4764      00
 4765 32aa 48898590 		movq	%rax, -2928(%rbp)
 4765      F4FFFF
1002:main.c        **** 	struct arg_str *backupOpt  = arg_str0(NULL, "backup", "<kbitSize:fw.iic>", "     backup FX2's EEPR
 4766              		.loc 1 1002 0
 4767 32b1 B9000000 		movl	$.LC106, %ecx
 4767      00
 4768 32b6 BA000000 		movl	$.LC107, %edx
 4768      00
 4769 32bb BE000000 		movl	$.LC108, %esi
 4769      00
 4770 32c0 BF000000 		movl	$0, %edi
 4770      00
 4771 32c5 E8000000 		call	arg_str0
 4771      00
 4772 32ca 48898598 		movq	%rax, -2920(%rbp)
 4772      F4FFFF
1003:main.c        **** 	////////////////////////////////////////////////////////////////////////////////////
1004:main.c        ****     ////////////////////////////////////////////////////////////////////////////////////
1005:main.c        **** 	struct arg_end *endOpt   = arg_end(20);
 4773              		.loc 1 1005 0
 4774 32d1 BF140000 		movl	$20, %edi
 4774      00
 4775 32d6 E8000000 		call	arg_end
 4775      00
 4776 32db 488985A0 		movq	%rax, -2912(%rbp)
 4776      F4FFFF
1006:main.c        **** 
1007:main.c        **** 
1008:main.c        **** 
1009:main.c        **** 
1010:main.c        **** 	void *argTable[] = {
 4777              		.loc 1 1010 0
 4778 32e2 488B8520 		movq	-3040(%rbp), %rax
 4778      F4FFFF
 4779 32e9 488985D0 		movq	%rax, -560(%rbp)
 4779      FDFFFF
 4780 32f0 488B8528 		movq	-3032(%rbp), %rax
 4780      F4FFFF
 4781 32f7 488985D8 		movq	%rax, -552(%rbp)
 4781      FDFFFF
 4782 32fe 488B8530 		movq	-3024(%rbp), %rax
 4782      F4FFFF
 4783 3305 488985E0 		movq	%rax, -544(%rbp)
 4783      FDFFFF
 4784 330c 488B8538 		movq	-3016(%rbp), %rax
 4784      F4FFFF
 4785 3313 488985E8 		movq	%rax, -536(%rbp)
 4785      FDFFFF
 4786 331a 488B8540 		movq	-3008(%rbp), %rax
 4786      F4FFFF
 4787 3321 488985F0 		movq	%rax, -528(%rbp)
 4787      FDFFFF
 4788 3328 488B8548 		movq	-3000(%rbp), %rax
 4788      F4FFFF
 4789 332f 488985F8 		movq	%rax, -520(%rbp)
 4789      FDFFFF
 4790 3336 488B8550 		movq	-2992(%rbp), %rax
 4790      F4FFFF
 4791 333d 48898500 		movq	%rax, -512(%rbp)
 4791      FEFFFF
 4792 3344 488B8558 		movq	-2984(%rbp), %rax
 4792      F4FFFF
 4793 334b 48898508 		movq	%rax, -504(%rbp)
 4793      FEFFFF
 4794 3352 488B8568 		movq	-2968(%rbp), %rax
 4794      F4FFFF
 4795 3359 48898510 		movq	%rax, -496(%rbp)
 4795      FEFFFF
 4796 3360 488B8570 		movq	-2960(%rbp), %rax
 4796      F4FFFF
 4797 3367 48898518 		movq	%rax, -488(%rbp)
 4797      FEFFFF
 4798 336e 488B8578 		movq	-2952(%rbp), %rax
 4798      F4FFFF
 4799 3375 48898520 		movq	%rax, -480(%rbp)
 4799      FEFFFF
 4800 337c 488B8580 		movq	-2944(%rbp), %rax
 4800      F4FFFF
 4801 3383 48898528 		movq	%rax, -472(%rbp)
 4801      FEFFFF
 4802 338a 488B8588 		movq	-2936(%rbp), %rax
 4802      F4FFFF
 4803 3391 48898530 		movq	%rax, -464(%rbp)
 4803      FEFFFF
 4804 3398 488B8590 		movq	-2928(%rbp), %rax
 4804      F4FFFF
 4805 339f 48898538 		movq	%rax, -456(%rbp)
 4805      FEFFFF
 4806 33a6 488B8598 		movq	-2920(%rbp), %rax
 4806      F4FFFF
 4807 33ad 48898540 		movq	%rax, -448(%rbp)
 4807      FEFFFF
 4808 33b4 488B8560 		movq	-2976(%rbp), %rax
 4808      F4FFFF
 4809 33bb 48898548 		movq	%rax, -440(%rbp)
 4809      FEFFFF
 4810 33c2 488B85A0 		movq	-2912(%rbp), %rax
 4810      F4FFFF
 4811 33c9 48898550 		movq	%rax, -432(%rbp)
 4811      FEFFFF
1011:main.c        **** 		ivpOpt, vpOpt, fwOpt, portOpt, queryOpt, progOpt, conOpt, actOpt,
1012:main.c        **** 		shellOpt, benOpt, rstOpt, dumpOpt, helpOpt, eepromOpt, backupOpt, doworkOpt, endOpt
1013:main.c        **** 	};
1014:main.c        **** 	const char *progName = "flcli";
 4812              		.loc 1 1014 0
 4813 33d0 48C785A8 		movq	$.LC109, -2904(%rbp)
 4813      F4FFFF00 
 4813      000000
1015:main.c        **** 	int numErrors;
1016:main.c        **** 	struct FLContext *handle = NULL;
 4814              		.loc 1 1016 0
 4815 33db 48C785E0 		movq	$0, -3104(%rbp)
 4815      F3FFFF00 
 4815      000000
1017:main.c        **** 	FLStatus fStatus;
1018:main.c        **** 	const char *error = NULL;
 4816              		.loc 1 1018 0
 4817 33e6 48C785E8 		movq	$0, -3096(%rbp)
 4817      F3FFFF00 
 4817      000000
1019:main.c        **** 	const char *ivp = NULL;
 4818              		.loc 1 1019 0
 4819 33f1 48C785B0 		movq	$0, -2896(%rbp)
 4819      F4FFFF00 
 4819      000000
1020:main.c        **** 	const char *vp = NULL;
 4820              		.loc 1 1020 0
 4821 33fc 48C785B8 		movq	$0, -2888(%rbp)
 4821      F4FFFF00 
 4821      000000
1021:main.c        **** 	bool isNeroCapable, isCommCapable;
1022:main.c        **** 	uint32 numDevices, scanChain[16], i;
1023:main.c        **** 	const char *line = NULL;
 4822              		.loc 1 1023 0
 4823 3407 48C78518 		movq	$0, -3048(%rbp)
 4823      F4FFFF00 
 4823      000000
1024:main.c        **** 	uint8 conduit = 0x01;
 4824              		.loc 1 1024 0
 4825 3412 C685ABF2 		movb	$1, -3413(%rbp)
 4825      FFFF01
1025:main.c        **** 
1026:main.c        **** 	if ( arg_nullcheck(argTable) != 0 ) {
 4826              		.loc 1 1026 0
 4827 3419 488D85D0 		leaq	-560(%rbp), %rax
 4827      FDFFFF
 4828 3420 4889C7   		movq	%rax, %rdi
 4829 3423 E8000000 		call	arg_nullcheck
 4829      00
 4830 3428 85C0     		testl	%eax, %eax
 4831 342a 742F     		je	.L229
1027:main.c        **** 		fprintf(stderr, "%s: insufficient memory\n", progName);
 4832              		.loc 1 1027 0
 4833 342c 488B0500 		movq	stderr(%rip), %rax
 4833      000000
 4834 3433 488B95A8 		movq	-2904(%rbp), %rdx
 4834      F4FFFF
 4835 343a BE000000 		movl	$.LC110, %esi
 4835      00
 4836 343f 4889C7   		movq	%rax, %rdi
 4837 3442 B8000000 		movl	$0, %eax
 4837      00
 4838 3447 E8000000 		call	fprintf
 4838      00
1028:main.c        **** 		FAIL(1, cleanup);
 4839              		.loc 1 1028 0
 4840 344c C785B8F2 		movl	$1, -3400(%rbp)
 4840      FFFF0100 
 4840      0000
 4841 3456 E9C54900 		jmp	.L230
 4841      00
 4842              	.L229:
1029:main.c        **** 	}
1030:main.c        **** 
1031:main.c        **** 	numErrors = arg_parse(argc, argv, argTable);
 4843              		.loc 1 1031 0
 4844 345b 488D95D0 		leaq	-560(%rbp), %rdx
 4844      FDFFFF
 4845 3462 488B8D90 		movq	-3440(%rbp), %rcx
 4845      F2FFFF
 4846 3469 8B859CF2 		movl	-3428(%rbp), %eax
 4846      FFFF
 4847 346f 4889CE   		movq	%rcx, %rsi
 4848 3472 89C7     		movl	%eax, %edi
 4849 3474 E8000000 		call	arg_parse
 4849      00
 4850 3479 8985A0F3 		movl	%eax, -3168(%rbp)
 4850      FFFF
1032:main.c        **** 
1033:main.c        **** 	if ( helpOpt->count > 0 ) {
 4851              		.loc 1 1033 0
 4852 347f 488B8588 		movq	-2936(%rbp), %rax
 4852      F4FFFF
 4853 3486 8B4060   		movl	96(%rax), %eax
 4854 3489 85C0     		testl	%eax, %eax
 4855 348b 7E6E     		jle	.L231
1034:main.c        **** 		printf("FPGALink Command-Line Interface Copyright (C) 2012-2014 Chris McClelland\n\nUsage: %s", p
 4856              		.loc 1 1034 0
 4857 348d 488B85A8 		movq	-2904(%rbp), %rax
 4857      F4FFFF
 4858 3494 4889C6   		movq	%rax, %rsi
 4859 3497 BF000000 		movl	$.LC111, %edi
 4859      00
 4860 349c B8000000 		movl	$0, %eax
 4860      00
 4861 34a1 E8000000 		call	printf
 4861      00
1035:main.c        **** 		arg_print_syntax(stdout, argTable, "\n");
 4862              		.loc 1 1035 0
 4863 34a6 488B0500 		movq	stdout(%rip), %rax
 4863      000000
 4864 34ad 488D8DD0 		leaq	-560(%rbp), %rcx
 4864      FDFFFF
 4865 34b4 BA000000 		movl	$.LC112, %edx
 4865      00
 4866 34b9 4889CE   		movq	%rcx, %rsi
 4867 34bc 4889C7   		movq	%rax, %rdi
 4868 34bf E8000000 		call	arg_print_syntax
 4868      00
1036:main.c        **** 		printf("\nInteract with an FPGALink device.\n\n");
 4869              		.loc 1 1036 0
 4870 34c4 BF000000 		movl	$.LC113, %edi
 4870      00
 4871 34c9 E8000000 		call	puts
 4871      00
1037:main.c        **** 		arg_print_glossary(stdout, argTable,"  %-10s %s\n");
 4872              		.loc 1 1037 0
 4873 34ce 488B0500 		movq	stdout(%rip), %rax
 4873      000000
 4874 34d5 488D8DD0 		leaq	-560(%rbp), %rcx
 4874      FDFFFF
 4875 34dc BA000000 		movl	$.LC114, %edx
 4875      00
 4876 34e1 4889CE   		movq	%rcx, %rsi
 4877 34e4 4889C7   		movq	%rax, %rdi
 4878 34e7 E8000000 		call	arg_print_glossary
 4878      00
1038:main.c        **** 		FAIL(FLP_SUCCESS, cleanup);
 4879              		.loc 1 1038 0
 4880 34ec C785B8F2 		movl	$0, -3400(%rbp)
 4880      FFFF0000 
 4880      0000
 4881 34f6 E9254900 		jmp	.L230
 4881      00
 4882              	.L231:
1039:main.c        **** 	}
1040:main.c        **** 
1041:main.c        **** 	if ( numErrors > 0 ) {
 4883              		.loc 1 1041 0
 4884 34fb 83BDA0F3 		cmpl	$0, -3168(%rbp)
 4884      FFFF00
 4885 3502 7E4F     		jle	.L232
1042:main.c        **** 		arg_print_errors(stdout, endOpt, progName);
 4886              		.loc 1 1042 0
 4887 3504 488B0500 		movq	stdout(%rip), %rax
 4887      000000
 4888 350b 488B95A8 		movq	-2904(%rbp), %rdx
 4888      F4FFFF
 4889 3512 488B8DA0 		movq	-2912(%rbp), %rcx
 4889      F4FFFF
 4890 3519 4889CE   		movq	%rcx, %rsi
 4891 351c 4889C7   		movq	%rax, %rdi
 4892 351f E8000000 		call	arg_print_errors
 4892      00
1043:main.c        **** 		fprintf(stderr, "Try '%s --help' for more information.\n", progName);
 4893              		.loc 1 1043 0
 4894 3524 488B0500 		movq	stderr(%rip), %rax
 4894      000000
 4895 352b 488B95A8 		movq	-2904(%rbp), %rdx
 4895      F4FFFF
 4896 3532 BE000000 		movl	$.LC115, %esi
 4896      00
 4897 3537 4889C7   		movq	%rax, %rdi
 4898 353a B8000000 		movl	$0, %eax
 4898      00
 4899 353f E8000000 		call	fprintf
 4899      00
1044:main.c        **** 		FAIL(FLP_ARGS, cleanup);
 4900              		.loc 1 1044 0
 4901 3544 C785B8F2 		movl	$12, -3400(%rbp)
 4901      FFFF0C00 
 4901      0000
 4902 354e E9CD4800 		jmp	.L230
 4902      00
 4903              	.L232:
1045:main.c        **** 	}
1046:main.c        **** 
1047:main.c        **** 	fStatus = flInitialise(0, &error);
 4904              		.loc 1 1047 0
 4905 3553 488D85E8 		leaq	-3096(%rbp), %rax
 4905      F3FFFF
 4906 355a 4889C6   		movq	%rax, %rsi
 4907 355d BF000000 		movl	$0, %edi
 4907      00
 4908 3562 E8000000 		call	flInitialise
 4908      00
 4909 3567 8985BCF2 		movl	%eax, -3396(%rbp)
 4909      FFFF
1048:main.c        **** 	CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 4910              		.loc 1 1048 0
 4911 356d 83BDBCF2 		cmpl	$0, -3396(%rbp)
 4911      FFFF00
 4912 3574 740F     		je	.L233
 4913              		.loc 1 1048 0 is_stmt 0 discriminator 1
 4914 3576 C785B8F2 		movl	$1, -3400(%rbp)
 4914      FFFF0100 
 4914      0000
 4915 3580 E99B4800 		jmp	.L230
 4915      00
 4916              	.L233:
1049:main.c        **** 
1050:main.c        **** 	vp = vpOpt->sval[0];
 4917              		.loc 1 1050 0 is_stmt 1
 4918 3585 488B8528 		movq	-3032(%rbp), %rax
 4918      F4FFFF
 4919 358c 488B4068 		movq	104(%rax), %rax
 4920 3590 488B00   		movq	(%rax), %rax
 4921 3593 488985B8 		movq	%rax, -2888(%rbp)
 4921      F4FFFF
1051:main.c        **** 
1052:main.c        **** 	printf("Attempting to open connection to FPGALink device %s...\n", vp);
 4922              		.loc 1 1052 0
 4923 359a 488B85B8 		movq	-2888(%rbp), %rax
 4923      F4FFFF
 4924 35a1 4889C6   		movq	%rax, %rsi
 4925 35a4 BF000000 		movl	$.LC116, %edi
 4925      00
 4926 35a9 B8000000 		movl	$0, %eax
 4926      00
 4927 35ae E8000000 		call	printf
 4927      00
1053:main.c        **** 	fStatus = flOpen(vp, &handle, NULL);
 4928              		.loc 1 1053 0
 4929 35b3 488D8DE0 		leaq	-3104(%rbp), %rcx
 4929      F3FFFF
 4930 35ba 488B85B8 		movq	-2888(%rbp), %rax
 4930      F4FFFF
 4931 35c1 BA000000 		movl	$0, %edx
 4931      00
 4932 35c6 4889CE   		movq	%rcx, %rsi
 4933 35c9 4889C7   		movq	%rax, %rdi
 4934 35cc E8000000 		call	flOpen
 4934      00
 4935 35d1 8985BCF2 		movl	%eax, -3396(%rbp)
 4935      FFFF
1054:main.c        **** 	if ( fStatus ) {
 4936              		.loc 1 1054 0
 4937 35d7 83BDBCF2 		cmpl	$0, -3396(%rbp)
 4937      FFFF00
 4938 35de 0F842502 		je	.L234
 4938      0000
1055:main.c        **** 		if ( ivpOpt->count ) {
 4939              		.loc 1 1055 0
 4940 35e4 488B8520 		movq	-3040(%rbp), %rax
 4940      F4FFFF
 4941 35eb 8B4060   		movl	96(%rax), %eax
 4942 35ee 85C0     		testl	%eax, %eax
 4943 35f0 0F84E401 		je	.L235
 4943      0000
 4944              	.LBB44:
1056:main.c        **** 			int count = 60;
 4945              		.loc 1 1056 0
 4946 35f6 C785C4F2 		movl	$60, -3388(%rbp)
 4946      FFFF3C00 
 4946      0000
1057:main.c        **** 			uint8 flag;
1058:main.c        **** 			ivp = ivpOpt->sval[0];
 4947              		.loc 1 1058 0
 4948 3600 488B8520 		movq	-3040(%rbp), %rax
 4948      F4FFFF
 4949 3607 488B4068 		movq	104(%rax), %rax
 4950 360b 488B00   		movq	(%rax), %rax
 4951 360e 488985B0 		movq	%rax, -2896(%rbp)
 4951      F4FFFF
1059:main.c        **** 			printf("Loading firmware into %s...\n", ivp);
 4952              		.loc 1 1059 0
 4953 3615 488B85B0 		movq	-2896(%rbp), %rax
 4953      F4FFFF
 4954 361c 4889C6   		movq	%rax, %rsi
 4955 361f BF000000 		movl	$.LC117, %edi
 4955      00
 4956 3624 B8000000 		movl	$0, %eax
 4956      00
 4957 3629 E8000000 		call	printf
 4957      00
1060:main.c        **** 			if ( fwOpt->count ) {
 4958              		.loc 1 1060 0
 4959 362e 488B8530 		movq	-3024(%rbp), %rax
 4959      F4FFFF
 4960 3635 8B4060   		movl	96(%rax), %eax
 4961 3638 85C0     		testl	%eax, %eax
 4962 363a 742F     		je	.L236
1061:main.c        **** 				fStatus = flLoadCustomFirmware(ivp, fwOpt->sval[0], &error);
 4963              		.loc 1 1061 0
 4964 363c 488B8530 		movq	-3024(%rbp), %rax
 4964      F4FFFF
 4965 3643 488B4068 		movq	104(%rax), %rax
 4966 3647 488B08   		movq	(%rax), %rcx
 4967 364a 488D95E8 		leaq	-3096(%rbp), %rdx
 4967      F3FFFF
 4968 3651 488B85B0 		movq	-2896(%rbp), %rax
 4968      F4FFFF
 4969 3658 4889CE   		movq	%rcx, %rsi
 4970 365b 4889C7   		movq	%rax, %rdi
 4971 365e E8000000 		call	flLoadCustomFirmware
 4971      00
 4972 3663 8985BCF2 		movl	%eax, -3396(%rbp)
 4972      FFFF
 4973 3669 EB26     		jmp	.L237
 4974              	.L236:
1062:main.c        **** 			} else {
1063:main.c        **** 				fStatus = flLoadStandardFirmware(ivp, vp, &error);
 4975              		.loc 1 1063 0
 4976 366b 488D95E8 		leaq	-3096(%rbp), %rdx
 4976      F3FFFF
 4977 3672 488B8DB8 		movq	-2888(%rbp), %rcx
 4977      F4FFFF
 4978 3679 488B85B0 		movq	-2896(%rbp), %rax
 4978      F4FFFF
 4979 3680 4889CE   		movq	%rcx, %rsi
 4980 3683 4889C7   		movq	%rax, %rdi
 4981 3686 E8000000 		call	flLoadStandardFirmware
 4981      00
 4982 368b 8985BCF2 		movl	%eax, -3396(%rbp)
 4982      FFFF
 4983              	.L237:
1064:main.c        **** 			}
1065:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 4984              		.loc 1 1065 0
 4985 3691 83BDBCF2 		cmpl	$0, -3396(%rbp)
 4985      FFFF00
 4986 3698 740F     		je	.L238
 4987              		.loc 1 1065 0 is_stmt 0 discriminator 1
 4988 369a C785B8F2 		movl	$1, -3400(%rbp)
 4988      FFFF0100 
 4988      0000
 4989 36a4 E9774700 		jmp	.L230
 4989      00
 4990              	.L238:
1066:main.c        **** 			
1067:main.c        **** 			printf("Awaiting renumeration");
 4991              		.loc 1 1067 0 is_stmt 1
 4992 36a9 BF000000 		movl	$.LC118, %edi
 4992      00
 4993 36ae B8000000 		movl	$0, %eax
 4993      00
 4994 36b3 E8000000 		call	printf
 4994      00
1068:main.c        **** 			flSleep(1000);
 4995              		.loc 1 1068 0
 4996 36b8 BFE80300 		movl	$1000, %edi
 4996      00
 4997 36bd E8000000 		call	flSleep
 4997      00
 4998              	.L242:
1069:main.c        **** 			do {
1070:main.c        **** 				printf(".");
 4999              		.loc 1 1070 0
 5000 36c2 BF2E0000 		movl	$46, %edi
 5000      00
 5001 36c7 E8000000 		call	putchar
 5001      00
1071:main.c        **** 				fflush(stdout);
 5002              		.loc 1 1071 0
 5003 36cc 488B0500 		movq	stdout(%rip), %rax
 5003      000000
 5004 36d3 4889C7   		movq	%rax, %rdi
 5005 36d6 E8000000 		call	fflush
 5005      00
1072:main.c        **** 				fStatus = flIsDeviceAvailable(vp, &flag, &error);
 5006              		.loc 1 1072 0
 5007 36db 488D95E8 		leaq	-3096(%rbp), %rdx
 5007      F3FFFF
 5008 36e2 488D8D10 		leaq	-3056(%rbp), %rcx
 5008      F4FFFF
 5009 36e9 488B85B8 		movq	-2888(%rbp), %rax
 5009      F4FFFF
 5010 36f0 4889CE   		movq	%rcx, %rsi
 5011 36f3 4889C7   		movq	%rax, %rdi
 5012 36f6 E8000000 		call	flIsDeviceAvailable
 5012      00
 5013 36fb 8985BCF2 		movl	%eax, -3396(%rbp)
 5013      FFFF
1073:main.c        **** 				CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5014              		.loc 1 1073 0
 5015 3701 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5015      FFFF00
 5016 3708 740F     		je	.L240
 5017              		.loc 1 1073 0 is_stmt 0 discriminator 1
 5018 370a C785B8F2 		movl	$1, -3400(%rbp)
 5018      FFFF0100 
 5018      0000
 5019 3714 E9074700 		jmp	.L230
 5019      00
 5020              	.L240:
1074:main.c        **** 				flSleep(250);
 5021              		.loc 1 1074 0 is_stmt 1
 5022 3719 BFFA0000 		movl	$250, %edi
 5022      00
 5023 371e E8000000 		call	flSleep
 5023      00
1075:main.c        **** 				count--;
 5024              		.loc 1 1075 0
 5025 3723 83ADC4F2 		subl	$1, -3388(%rbp)
 5025      FFFF01
1076:main.c        **** 			} while ( !flag && count );
 5026              		.loc 1 1076 0
 5027 372a 0FB68510 		movzbl	-3056(%rbp), %eax
 5027      F4FFFF
 5028 3731 84C0     		testb	%al, %al
 5029 3733 7509     		jne	.L241
 5030              		.loc 1 1076 0 is_stmt 0 discriminator 1
 5031 3735 83BDC4F2 		cmpl	$0, -3388(%rbp)
 5031      FFFF00
 5032 373c 7584     		jne	.L242
 5033              	.L241:
1077:main.c        **** 			printf("\n");
 5034              		.loc 1 1077 0 is_stmt 1
 5035 373e BF0A0000 		movl	$10, %edi
 5035      00
 5036 3743 E8000000 		call	putchar
 5036      00
1078:main.c        **** 			if ( !flag ) {
 5037              		.loc 1 1078 0
 5038 3748 0FB68510 		movzbl	-3056(%rbp), %eax
 5038      F4FFFF
 5039 374f 84C0     		testb	%al, %al
 5040 3751 752F     		jne	.L243
1079:main.c        **** 				fprintf(stderr, "FPGALink device did not renumerate properly as %s\n", vp);
 5041              		.loc 1 1079 0
 5042 3753 488B0500 		movq	stderr(%rip), %rax
 5042      000000
 5043 375a 488B95B8 		movq	-2888(%rbp), %rdx
 5043      F4FFFF
 5044 3761 BE000000 		movl	$.LC119, %esi
 5044      00
 5045 3766 4889C7   		movq	%rax, %rdi
 5046 3769 B8000000 		movl	$0, %eax
 5046      00
 5047 376e E8000000 		call	fprintf
 5047      00
1080:main.c        **** 				FAIL(FLP_LIBERR, cleanup);
 5048              		.loc 1 1080 0
 5049 3773 C785B8F2 		movl	$1, -3400(%rbp)
 5049      FFFF0100 
 5049      0000
 5050 377d E99E4600 		jmp	.L230
 5050      00
 5051              	.L243:
1081:main.c        **** 			}
1082:main.c        **** 
1083:main.c        **** 			printf("Attempting to open connection to FPGLink device %s again...\n", vp);
 5052              		.loc 1 1083 0
 5053 3782 488B85B8 		movq	-2888(%rbp), %rax
 5053      F4FFFF
 5054 3789 4889C6   		movq	%rax, %rsi
 5055 378c BF000000 		movl	$.LC120, %edi
 5055      00
 5056 3791 B8000000 		movl	$0, %eax
 5056      00
 5057 3796 E8000000 		call	printf
 5057      00
1084:main.c        **** 			fStatus = flOpen(vp, &handle, &error);
 5058              		.loc 1 1084 0
 5059 379b 488D95E8 		leaq	-3096(%rbp), %rdx
 5059      F3FFFF
 5060 37a2 488D8DE0 		leaq	-3104(%rbp), %rcx
 5060      F3FFFF
 5061 37a9 488B85B8 		movq	-2888(%rbp), %rax
 5061      F4FFFF
 5062 37b0 4889CE   		movq	%rcx, %rsi
 5063 37b3 4889C7   		movq	%rax, %rdi
 5064 37b6 E8000000 		call	flOpen
 5064      00
 5065 37bb 8985BCF2 		movl	%eax, -3396(%rbp)
 5065      FFFF
1085:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5066              		.loc 1 1085 0
 5067 37c1 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5067      FFFF00
 5068 37c8 743F     		je	.L234
 5069              		.loc 1 1085 0 is_stmt 0 discriminator 1
 5070 37ca C785B8F2 		movl	$1, -3400(%rbp)
 5070      FFFF0100 
 5070      0000
 5071 37d4 90       		nop
 5072 37d5 E9464600 		jmp	.L230
 5072      00
 5073              	.L235:
 5074              	.LBE44:
1086:main.c        **** 		} else {
1087:main.c        **** 			fprintf(stderr, "Could not open FPGALink device at %s and no initial VID:PID was supplied\n", vp
 5075              		.loc 1 1087 0 is_stmt 1
 5076 37da 488B0500 		movq	stderr(%rip), %rax
 5076      000000
 5077 37e1 488B95B8 		movq	-2888(%rbp), %rdx
 5077      F4FFFF
 5078 37e8 BE000000 		movl	$.LC121, %esi
 5078      00
 5079 37ed 4889C7   		movq	%rax, %rdi
 5080 37f0 B8000000 		movl	$0, %eax
 5080      00
 5081 37f5 E8000000 		call	fprintf
 5081      00
1088:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 5082              		.loc 1 1088 0
 5083 37fa C785B8F2 		movl	$12, -3400(%rbp)
 5083      FFFF0C00 
 5083      0000
 5084 3804 E9174600 		jmp	.L230
 5084      00
 5085              	.L234:
1089:main.c        **** 		}
1090:main.c        **** 	}
1091:main.c        **** 
1092:main.c        **** 	printf(
 5086              		.loc 1 1092 0
 5087 3809 488B85E0 		movq	-3104(%rbp), %rax
 5087      F3FFFF
 5088 3810 4889C7   		movq	%rax, %rdi
 5089 3813 E8000000 		call	flGetFirmwareVersion
 5089      00
 5090 3818 89C3     		movl	%eax, %ebx
1093:main.c        **** 		"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
1094:main.c        **** 		vp, flGetFirmwareID(handle), flGetFirmwareVersion(handle)
 5091              		.loc 1 1094 0
 5092 381a 488B85E0 		movq	-3104(%rbp), %rax
 5092      F3FFFF
 5093 3821 4889C7   		movq	%rax, %rdi
 5094 3824 E8000000 		call	flGetFirmwareID
 5094      00
1092:main.c        **** 		"Connected to FPGALink device %s (firmwareID: 0x%04X, firmwareVersion: 0x%08X)\n",
 5095              		.loc 1 1092 0
 5096 3829 0FB7D0   		movzwl	%ax, %edx
 5097 382c 488B85B8 		movq	-2888(%rbp), %rax
 5097      F4FFFF
 5098 3833 89D9     		movl	%ebx, %ecx
 5099 3835 4889C6   		movq	%rax, %rsi
 5100 3838 BF000000 		movl	$.LC122, %edi
 5100      00
 5101 383d B8000000 		movl	$0, %eax
 5101      00
 5102 3842 E8000000 		call	printf
 5102      00
1095:main.c        **** 		);
1096:main.c        **** 
1097:main.c        **** 	if ( eepromOpt->count ) {
 5103              		.loc 1 1097 0
 5104 3847 488B8590 		movq	-2928(%rbp), %rax
 5104      F4FFFF
 5105 384e 8B4060   		movl	96(%rax), %eax
 5106 3851 85C0     		testl	%eax, %eax
 5107 3853 0F84B600 		je	.L245
 5107      0000
1098:main.c        **** 		if ( !strcmp("std", eepromOpt->sval[0]) ) {
 5108              		.loc 1 1098 0
 5109 3859 488B8590 		movq	-2928(%rbp), %rax
 5109      F4FFFF
 5110 3860 488B4068 		movq	104(%rax), %rax
 5111 3864 488B00   		movq	(%rax), %rax
 5112 3867 4889C6   		movq	%rax, %rsi
 5113 386a BF000000 		movl	$.LC123, %edi
 5113      00
 5114 386f E8000000 		call	strcmp
 5114      00
 5115 3874 85C0     		testl	%eax, %eax
 5116 3876 7532     		jne	.L246
1099:main.c        **** 			printf("Writing the standard FPGALink firmware to the FX2's EEPROM...\n");
 5117              		.loc 1 1099 0
 5118 3878 BF000000 		movl	$.LC124, %edi
 5118      00
 5119 387d E8000000 		call	puts
 5119      00
1100:main.c        **** 			fStatus = flFlashStandardFirmware(handle, vp, &error);
 5120              		.loc 1 1100 0
 5121 3882 488B85E0 		movq	-3104(%rbp), %rax
 5121      F3FFFF
 5122 3889 488D95E8 		leaq	-3096(%rbp), %rdx
 5122      F3FFFF
 5123 3890 488B8DB8 		movq	-2888(%rbp), %rcx
 5123      F4FFFF
 5124 3897 4889CE   		movq	%rcx, %rsi
 5125 389a 4889C7   		movq	%rax, %rdi
 5126 389d E8000000 		call	flFlashStandardFirmware
 5126      00
 5127 38a2 8985BCF2 		movl	%eax, -3396(%rbp)
 5127      FFFF
 5128 38a8 EB4D     		jmp	.L247
 5129              	.L246:
1101:main.c        **** 		} else {
1102:main.c        **** 			printf("Writing custom FPGALink firmware from %s to the FX2's EEPROM...\n", eepromOpt->sval[0]);
 5130              		.loc 1 1102 0
 5131 38aa 488B8590 		movq	-2928(%rbp), %rax
 5131      F4FFFF
 5132 38b1 488B4068 		movq	104(%rax), %rax
 5133 38b5 488B00   		movq	(%rax), %rax
 5134 38b8 4889C6   		movq	%rax, %rsi
 5135 38bb BF000000 		movl	$.LC125, %edi
 5135      00
 5136 38c0 B8000000 		movl	$0, %eax
 5136      00
 5137 38c5 E8000000 		call	printf
 5137      00
1103:main.c        **** 			fStatus = flFlashCustomFirmware(handle, eepromOpt->sval[0], &error);
 5138              		.loc 1 1103 0
 5139 38ca 488B8590 		movq	-2928(%rbp), %rax
 5139      F4FFFF
 5140 38d1 488B4068 		movq	104(%rax), %rax
 5141 38d5 488B08   		movq	(%rax), %rcx
 5142 38d8 488B85E0 		movq	-3104(%rbp), %rax
 5142      F3FFFF
 5143 38df 488D95E8 		leaq	-3096(%rbp), %rdx
 5143      F3FFFF
 5144 38e6 4889CE   		movq	%rcx, %rsi
 5145 38e9 4889C7   		movq	%rax, %rdi
 5146 38ec E8000000 		call	flFlashCustomFirmware
 5146      00
 5147 38f1 8985BCF2 		movl	%eax, -3396(%rbp)
 5147      FFFF
 5148              	.L247:
1104:main.c        **** 		}
1105:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5149              		.loc 1 1105 0
 5150 38f7 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5150      FFFF00
 5151 38fe 740F     		je	.L245
 5152              		.loc 1 1105 0 is_stmt 0 discriminator 1
 5153 3900 C785B8F2 		movl	$1, -3400(%rbp)
 5153      FFFF0100 
 5153      0000
 5154 390a E9114500 		jmp	.L230
 5154      00
 5155              	.L245:
1106:main.c        **** 	}
1107:main.c        **** 
1108:main.c        **** 	if ( backupOpt->count ) {
 5156              		.loc 1 1108 0 is_stmt 1
 5157 390f 488B8598 		movq	-2920(%rbp), %rax
 5157      F4FFFF
 5158 3916 8B4060   		movl	96(%rax), %eax
 5159 3919 85C0     		testl	%eax, %eax
 5160 391b 0F84DA00 		je	.L248
 5160      0000
 5161              	.LBB45:
1109:main.c        **** 		const char *fileName;
1110:main.c        **** 		const uint32 kbitSize = strtoul(backupOpt->sval[0], (char**)&fileName, 0);
 5162              		.loc 1 1110 0
 5163 3921 488B8598 		movq	-2920(%rbp), %rax
 5163      F4FFFF
 5164 3928 488B4068 		movq	104(%rax), %rax
 5165 392c 488B00   		movq	(%rax), %rax
 5166 392f 488D8D10 		leaq	-3056(%rbp), %rcx
 5166      F4FFFF
 5167 3936 BA000000 		movl	$0, %edx
 5167      00
 5168 393b 4889CE   		movq	%rcx, %rsi
 5169 393e 4889C7   		movq	%rax, %rdi
 5170 3941 E8000000 		call	strtoul
 5170      00
 5171 3946 8985A4F3 		movl	%eax, -3164(%rbp)
 5171      FFFF
1111:main.c        **** 		if ( *fileName != ':' ) {
 5172              		.loc 1 1111 0
 5173 394c 488B8510 		movq	-3056(%rbp), %rax
 5173      F4FFFF
 5174 3953 0FB600   		movzbl	(%rax), %eax
 5175 3956 3C3A     		cmpb	$58, %al
 5176 3958 742F     		je	.L249
1112:main.c        **** 			fprintf(stderr, "%s: invalid argument to option --backup=<kbitSize:fw.iic>\n", progName);
 5177              		.loc 1 1112 0
 5178 395a 488B0500 		movq	stderr(%rip), %rax
 5178      000000
 5179 3961 488B95A8 		movq	-2904(%rbp), %rdx
 5179      F4FFFF
 5180 3968 BE000000 		movl	$.LC126, %esi
 5180      00
 5181 396d 4889C7   		movq	%rax, %rdi
 5182 3970 B8000000 		movl	$0, %eax
 5182      00
 5183 3975 E8000000 		call	fprintf
 5183      00
1113:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 5184              		.loc 1 1113 0
 5185 397a C785B8F2 		movl	$12, -3400(%rbp)
 5185      FFFF0C00 
 5185      0000
 5186 3984 E9974400 		jmp	.L230
 5186      00
 5187              	.L249:
1114:main.c        **** 		}
1115:main.c        **** 		fileName++;
 5188              		.loc 1 1115 0
 5189 3989 488B8510 		movq	-3056(%rbp), %rax
 5189      F4FFFF
 5190 3990 4883C001 		addq	$1, %rax
 5191 3994 48898510 		movq	%rax, -3056(%rbp)
 5191      F4FFFF
1116:main.c        **** 		printf("Saving a backup of %d kbit from the FX2's EEPROM to %s...\n", kbitSize, fileName);
 5192              		.loc 1 1116 0
 5193 399b 488B9510 		movq	-3056(%rbp), %rdx
 5193      F4FFFF
 5194 39a2 8B85A4F3 		movl	-3164(%rbp), %eax
 5194      FFFF
 5195 39a8 89C6     		movl	%eax, %esi
 5196 39aa BF000000 		movl	$.LC127, %edi
 5196      00
 5197 39af B8000000 		movl	$0, %eax
 5197      00
 5198 39b4 E8000000 		call	printf
 5198      00
1117:main.c        **** 		fStatus = flSaveFirmware(handle, kbitSize, fileName, &error);
 5199              		.loc 1 1117 0
 5200 39b9 488B9510 		movq	-3056(%rbp), %rdx
 5200      F4FFFF
 5201 39c0 488B85E0 		movq	-3104(%rbp), %rax
 5201      F3FFFF
 5202 39c7 488D8DE8 		leaq	-3096(%rbp), %rcx
 5202      F3FFFF
 5203 39ce 8BB5A4F3 		movl	-3164(%rbp), %esi
 5203      FFFF
 5204 39d4 4889C7   		movq	%rax, %rdi
 5205 39d7 E8000000 		call	flSaveFirmware
 5205      00
 5206 39dc 8985BCF2 		movl	%eax, -3396(%rbp)
 5206      FFFF
1118:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5207              		.loc 1 1118 0
 5208 39e2 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5208      FFFF00
 5209 39e9 7410     		je	.L248
 5210              		.loc 1 1118 0 is_stmt 0 discriminator 1
 5211 39eb C785B8F2 		movl	$1, -3400(%rbp)
 5211      FFFF0100 
 5211      0000
 5212 39f5 90       		nop
 5213 39f6 E9254400 		jmp	.L230
 5213      00
 5214              	.L248:
 5215              	.LBE45:
1119:main.c        **** 	}
1120:main.c        **** 
1121:main.c        **** 	if ( rstOpt->count ) {
 5216              		.loc 1 1121 0 is_stmt 1
 5217 39fb 488B8578 		movq	-2952(%rbp), %rax
 5217      F4FFFF
 5218 3a02 8B4060   		movl	96(%rax), %eax
 5219 3a05 85C0     		testl	%eax, %eax
 5220 3a07 7437     		je	.L252
1122:main.c        **** 		// Reset the bulk endpoints (only needed in some virtualised environments)
1123:main.c        **** 		fStatus = flResetToggle(handle, &error);
 5221              		.loc 1 1123 0
 5222 3a09 488B85E0 		movq	-3104(%rbp), %rax
 5222      F3FFFF
 5223 3a10 488D95E8 		leaq	-3096(%rbp), %rdx
 5223      F3FFFF
 5224 3a17 4889D6   		movq	%rdx, %rsi
 5225 3a1a 4889C7   		movq	%rax, %rdi
 5226 3a1d E8000000 		call	flResetToggle
 5226      00
 5227 3a22 8985BCF2 		movl	%eax, -3396(%rbp)
 5227      FFFF
1124:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5228              		.loc 1 1124 0
 5229 3a28 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5229      FFFF00
 5230 3a2f 740F     		je	.L252
 5231              		.loc 1 1124 0 is_stmt 0 discriminator 1
 5232 3a31 C785B8F2 		movl	$1, -3400(%rbp)
 5232      FFFF0100 
 5232      0000
 5233 3a3b E9E04300 		jmp	.L230
 5233      00
 5234              	.L252:
1125:main.c        **** 	}
1126:main.c        **** 
1127:main.c        **** 	if ( conOpt->count ) {
 5235              		.loc 1 1127 0 is_stmt 1
 5236 3a40 488B8550 		movq	-2992(%rbp), %rax
 5236      F4FFFF
 5237 3a47 8B4060   		movl	96(%rax), %eax
 5238 3a4a 85C0     		testl	%eax, %eax
 5239 3a4c 7413     		je	.L253
1128:main.c        **** 		conduit = (uint8)conOpt->ival[0];
 5240              		.loc 1 1128 0
 5241 3a4e 488B8550 		movq	-2992(%rbp), %rax
 5241      F4FFFF
 5242 3a55 488B4068 		movq	104(%rax), %rax
 5243 3a59 8B00     		movl	(%rax), %eax
 5244 3a5b 8885ABF2 		movb	%al, -3413(%rbp)
 5244      FFFF
 5245              	.L253:
1129:main.c        **** 	}
1130:main.c        **** 
1131:main.c        **** 	isNeroCapable = flIsNeroCapable(handle);
 5246              		.loc 1 1131 0
 5247 3a61 488B85E0 		movq	-3104(%rbp), %rax
 5247      F3FFFF
 5248 3a68 4889C7   		movq	%rax, %rdi
 5249 3a6b E8000000 		call	flIsNeroCapable
 5249      00
 5250 3a70 84C0     		testb	%al, %al
 5251 3a72 0F95C0   		setne	%al
 5252 3a75 8885ADF2 		movb	%al, -3411(%rbp)
 5252      FFFF
1132:main.c        **** 	isCommCapable = flIsCommCapable(handle, conduit);
 5253              		.loc 1 1132 0
 5254 3a7b 0FB695AB 		movzbl	-3413(%rbp), %edx
 5254      F2FFFF
 5255 3a82 488B85E0 		movq	-3104(%rbp), %rax
 5255      F3FFFF
 5256 3a89 89D6     		movl	%edx, %esi
 5257 3a8b 4889C7   		movq	%rax, %rdi
 5258 3a8e E8000000 		call	flIsCommCapable
 5258      00
 5259 3a93 84C0     		testb	%al, %al
 5260 3a95 0F95C0   		setne	%al
 5261 3a98 8885AEF2 		movb	%al, -3410(%rbp)
 5261      FFFF
1133:main.c        **** 
1134:main.c        **** 	if ( portOpt->count ) {
 5262              		.loc 1 1134 0
 5263 3a9e 488B8538 		movq	-3016(%rbp), %rax
 5263      F4FFFF
 5264 3aa5 8B4060   		movl	96(%rax), %eax
 5265 3aa8 85C0     		testl	%eax, %eax
 5266 3aaa 0F843C02 		je	.L254
 5266      0000
 5267              	.LBB46:
1135:main.c        **** 		uint32 readState;
1136:main.c        **** 		char hex[9];
1137:main.c        **** 		const uint8 *p = (const uint8 *)hex;
 5268              		.loc 1 1137 0
 5269 3ab0 488D45D0 		leaq	-48(%rbp), %rax
 5270 3ab4 488985C0 		movq	%rax, -2880(%rbp)
 5270      F4FFFF
1138:main.c        **** 		printf("Configuring ports...\n");
 5271              		.loc 1 1138 0
 5272 3abb BF000000 		movl	$.LC128, %edi
 5272      00
 5273 3ac0 E8000000 		call	puts
 5273      00
1139:main.c        **** 		fStatus = flMultiBitPortAccess(handle, portOpt->sval[0], &readState, &error);
 5274              		.loc 1 1139 0
 5275 3ac5 488B8538 		movq	-3016(%rbp), %rax
 5275      F4FFFF
 5276 3acc 488B4068 		movq	104(%rax), %rax
 5277 3ad0 488B30   		movq	(%rax), %rsi
 5278 3ad3 488B85E0 		movq	-3104(%rbp), %rax
 5278      F3FFFF
 5279 3ada 488D8DE8 		leaq	-3096(%rbp), %rcx
 5279      F3FFFF
 5280 3ae1 488D9510 		leaq	-3056(%rbp), %rdx
 5280      F4FFFF
 5281 3ae8 4889C7   		movq	%rax, %rdi
 5282 3aeb E8000000 		call	flMultiBitPortAccess
 5282      00
 5283 3af0 8985BCF2 		movl	%eax, -3396(%rbp)
 5283      FFFF
1140:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5284              		.loc 1 1140 0
 5285 3af6 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5285      FFFF00
 5286 3afd 740F     		je	.L255
 5287              		.loc 1 1140 0 is_stmt 0 discriminator 1
 5288 3aff C785B8F2 		movl	$1, -3400(%rbp)
 5288      FFFF0100 
 5288      0000
 5289 3b09 E9124300 		jmp	.L230
 5289      00
 5290              	.L255:
1141:main.c        **** 		sprintf(hex, "%08X", readState);
 5291              		.loc 1 1141 0 is_stmt 1
 5292 3b0e 8B9510F4 		movl	-3056(%rbp), %edx
 5292      FFFF
 5293 3b14 488D45D0 		leaq	-48(%rbp), %rax
 5294 3b18 BE000000 		movl	$.LC129, %esi
 5294      00
 5295 3b1d 4889C7   		movq	%rax, %rdi
 5296 3b20 B8000000 		movl	$0, %eax
 5296      00
 5297 3b25 E8000000 		call	sprintf
 5297      00
1142:main.c        **** 		printf("Readback:   28   24   20   16    12    8    4    0\n          %s", nibbles[*p++ - '0']);
 5298              		.loc 1 1142 0
 5299 3b2a 488B85C0 		movq	-2880(%rbp), %rax
 5299      F4FFFF
 5300 3b31 488D5001 		leaq	1(%rax), %rdx
 5301 3b35 488995C0 		movq	%rdx, -2880(%rbp)
 5301      F4FFFF
 5302 3b3c 0FB600   		movzbl	(%rax), %eax
 5303 3b3f 0FB6C0   		movzbl	%al, %eax
 5304 3b42 83E830   		subl	$48, %eax
 5305 3b45 4898     		cltq
 5306 3b47 488B04C5 		movq	nibbles(,%rax,8), %rax
 5306      00000000 
 5307 3b4f 4889C6   		movq	%rax, %rsi
 5308 3b52 BF000000 		movl	$.LC130, %edi
 5308      00
 5309 3b57 B8000000 		movl	$0, %eax
 5309      00
 5310 3b5c E8000000 		call	printf
 5310      00
1143:main.c        **** 		printf(" %s", nibbles[*p++ - '0']);
 5311              		.loc 1 1143 0
 5312 3b61 488B85C0 		movq	-2880(%rbp), %rax
 5312      F4FFFF
 5313 3b68 488D5001 		leaq	1(%rax), %rdx
 5314 3b6c 488995C0 		movq	%rdx, -2880(%rbp)
 5314      F4FFFF
 5315 3b73 0FB600   		movzbl	(%rax), %eax
 5316 3b76 0FB6C0   		movzbl	%al, %eax
 5317 3b79 83E830   		subl	$48, %eax
 5318 3b7c 4898     		cltq
 5319 3b7e 488B04C5 		movq	nibbles(,%rax,8), %rax
 5319      00000000 
 5320 3b86 4889C6   		movq	%rax, %rsi
 5321 3b89 BF000000 		movl	$.LC131, %edi
 5321      00
 5322 3b8e B8000000 		movl	$0, %eax
 5322      00
 5323 3b93 E8000000 		call	printf
 5323      00
1144:main.c        **** 		printf(" %s", nibbles[*p++ - '0']);
 5324              		.loc 1 1144 0
 5325 3b98 488B85C0 		movq	-2880(%rbp), %rax
 5325      F4FFFF
 5326 3b9f 488D5001 		leaq	1(%rax), %rdx
 5327 3ba3 488995C0 		movq	%rdx, -2880(%rbp)
 5327      F4FFFF
 5328 3baa 0FB600   		movzbl	(%rax), %eax
 5329 3bad 0FB6C0   		movzbl	%al, %eax
 5330 3bb0 83E830   		subl	$48, %eax
 5331 3bb3 4898     		cltq
 5332 3bb5 488B04C5 		movq	nibbles(,%rax,8), %rax
 5332      00000000 
 5333 3bbd 4889C6   		movq	%rax, %rsi
 5334 3bc0 BF000000 		movl	$.LC131, %edi
 5334      00
 5335 3bc5 B8000000 		movl	$0, %eax
 5335      00
 5336 3bca E8000000 		call	printf
 5336      00
1145:main.c        **** 		printf(" %s", nibbles[*p++ - '0']);
 5337              		.loc 1 1145 0
 5338 3bcf 488B85C0 		movq	-2880(%rbp), %rax
 5338      F4FFFF
 5339 3bd6 488D5001 		leaq	1(%rax), %rdx
 5340 3bda 488995C0 		movq	%rdx, -2880(%rbp)
 5340      F4FFFF
 5341 3be1 0FB600   		movzbl	(%rax), %eax
 5342 3be4 0FB6C0   		movzbl	%al, %eax
 5343 3be7 83E830   		subl	$48, %eax
 5344 3bea 4898     		cltq
 5345 3bec 488B04C5 		movq	nibbles(,%rax,8), %rax
 5345      00000000 
 5346 3bf4 4889C6   		movq	%rax, %rsi
 5347 3bf7 BF000000 		movl	$.LC131, %edi
 5347      00
 5348 3bfc B8000000 		movl	$0, %eax
 5348      00
 5349 3c01 E8000000 		call	printf
 5349      00
1146:main.c        **** 		printf("  %s", nibbles[*p++ - '0']);
 5350              		.loc 1 1146 0
 5351 3c06 488B85C0 		movq	-2880(%rbp), %rax
 5351      F4FFFF
 5352 3c0d 488D5001 		leaq	1(%rax), %rdx
 5353 3c11 488995C0 		movq	%rdx, -2880(%rbp)
 5353      F4FFFF
 5354 3c18 0FB600   		movzbl	(%rax), %eax
 5355 3c1b 0FB6C0   		movzbl	%al, %eax
 5356 3c1e 83E830   		subl	$48, %eax
 5357 3c21 4898     		cltq
 5358 3c23 488B04C5 		movq	nibbles(,%rax,8), %rax
 5358      00000000 
 5359 3c2b 4889C6   		movq	%rax, %rsi
 5360 3c2e BF000000 		movl	$.LC132, %edi
 5360      00
 5361 3c33 B8000000 		movl	$0, %eax
 5361      00
 5362 3c38 E8000000 		call	printf
 5362      00
1147:main.c        **** 		printf(" %s", nibbles[*p++ - '0']);
 5363              		.loc 1 1147 0
 5364 3c3d 488B85C0 		movq	-2880(%rbp), %rax
 5364      F4FFFF
 5365 3c44 488D5001 		leaq	1(%rax), %rdx
 5366 3c48 488995C0 		movq	%rdx, -2880(%rbp)
 5366      F4FFFF
 5367 3c4f 0FB600   		movzbl	(%rax), %eax
 5368 3c52 0FB6C0   		movzbl	%al, %eax
 5369 3c55 83E830   		subl	$48, %eax
 5370 3c58 4898     		cltq
 5371 3c5a 488B04C5 		movq	nibbles(,%rax,8), %rax
 5371      00000000 
 5372 3c62 4889C6   		movq	%rax, %rsi
 5373 3c65 BF000000 		movl	$.LC131, %edi
 5373      00
 5374 3c6a B8000000 		movl	$0, %eax
 5374      00
 5375 3c6f E8000000 		call	printf
 5375      00
1148:main.c        **** 		printf(" %s", nibbles[*p++ - '0']);
 5376              		.loc 1 1148 0
 5377 3c74 488B85C0 		movq	-2880(%rbp), %rax
 5377      F4FFFF
 5378 3c7b 488D5001 		leaq	1(%rax), %rdx
 5379 3c7f 488995C0 		movq	%rdx, -2880(%rbp)
 5379      F4FFFF
 5380 3c86 0FB600   		movzbl	(%rax), %eax
 5381 3c89 0FB6C0   		movzbl	%al, %eax
 5382 3c8c 83E830   		subl	$48, %eax
 5383 3c8f 4898     		cltq
 5384 3c91 488B04C5 		movq	nibbles(,%rax,8), %rax
 5384      00000000 
 5385 3c99 4889C6   		movq	%rax, %rsi
 5386 3c9c BF000000 		movl	$.LC131, %edi
 5386      00
 5387 3ca1 B8000000 		movl	$0, %eax
 5387      00
 5388 3ca6 E8000000 		call	printf
 5388      00
1149:main.c        **** 		printf(" %s\n", nibbles[*p++ - '0']);
 5389              		.loc 1 1149 0
 5390 3cab 488B85C0 		movq	-2880(%rbp), %rax
 5390      F4FFFF
 5391 3cb2 488D5001 		leaq	1(%rax), %rdx
 5392 3cb6 488995C0 		movq	%rdx, -2880(%rbp)
 5392      F4FFFF
 5393 3cbd 0FB600   		movzbl	(%rax), %eax
 5394 3cc0 0FB6C0   		movzbl	%al, %eax
 5395 3cc3 83E830   		subl	$48, %eax
 5396 3cc6 4898     		cltq
 5397 3cc8 488B04C5 		movq	nibbles(,%rax,8), %rax
 5397      00000000 
 5398 3cd0 4889C6   		movq	%rax, %rsi
 5399 3cd3 BF000000 		movl	$.LC133, %edi
 5399      00
 5400 3cd8 B8000000 		movl	$0, %eax
 5400      00
 5401 3cdd E8000000 		call	printf
 5401      00
1150:main.c        **** 		flSleep(100);
 5402              		.loc 1 1150 0
 5403 3ce2 BF640000 		movl	$100, %edi
 5403      00
 5404 3ce7 E8000000 		call	flSleep
 5404      00
 5405              	.L254:
 5406              	.LBE46:
1151:main.c        **** 	}
1152:main.c        **** 
1153:main.c        **** 	if ( queryOpt->count ) {
 5407              		.loc 1 1153 0
 5408 3cec 488B8540 		movq	-3008(%rbp), %rax
 5408      F4FFFF
 5409 3cf3 8B4060   		movl	96(%rax), %eax
 5410 3cf6 85C0     		testl	%eax, %eax
 5411 3cf8 0F844D01 		je	.L256
 5411      0000
1154:main.c        **** 		if ( isNeroCapable ) {
 5412              		.loc 1 1154 0
 5413 3cfe 80BDADF2 		cmpb	$0, -3411(%rbp)
 5413      FFFF00
 5414 3d05 0F841101 		je	.L257
 5414      0000
1155:main.c        **** 			fStatus = flSelectConduit(handle, 0x00, &error);
 5415              		.loc 1 1155 0
 5416 3d0b 488B85E0 		movq	-3104(%rbp), %rax
 5416      F3FFFF
 5417 3d12 488D95E8 		leaq	-3096(%rbp), %rdx
 5417      F3FFFF
 5418 3d19 BE000000 		movl	$0, %esi
 5418      00
 5419 3d1e 4889C7   		movq	%rax, %rdi
 5420 3d21 E8000000 		call	flSelectConduit
 5420      00
 5421 3d26 8985BCF2 		movl	%eax, -3396(%rbp)
 5421      FFFF
1156:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5422              		.loc 1 1156 0
 5423 3d2c 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5423      FFFF00
 5424 3d33 740F     		je	.L258
 5425              		.loc 1 1156 0 is_stmt 0 discriminator 1
 5426 3d35 C785B8F2 		movl	$1, -3400(%rbp)
 5426      FFFF0100 
 5426      0000
 5427 3d3f E9DC4000 		jmp	.L230
 5427      00
 5428              	.L258:
1157:main.c        **** 			fStatus = jtagScanChain(handle, queryOpt->sval[0], &numDevices, scanChain, 16, &error);
 5429              		.loc 1 1157 0 is_stmt 1
 5430 3d44 488B8540 		movq	-3008(%rbp), %rax
 5430      F4FFFF
 5431 3d4b 488B4068 		movq	104(%rax), %rax
 5432 3d4f 488B30   		movq	(%rax), %rsi
 5433 3d52 488B85E0 		movq	-3104(%rbp), %rax
 5433      F3FFFF
 5434 3d59 488DBDE8 		leaq	-3096(%rbp), %rdi
 5434      F3FFFF
 5435 3d60 488D8D90 		leaq	-2672(%rbp), %rcx
 5435      F5FFFF
 5436 3d67 488D95B0 		leaq	-3408(%rbp), %rdx
 5436      F2FFFF
 5437 3d6e 4989F9   		movq	%rdi, %r9
 5438 3d71 41B81000 		movl	$16, %r8d
 5438      0000
 5439 3d77 4889C7   		movq	%rax, %rdi
 5440 3d7a E8000000 		call	jtagScanChain
 5440      00
 5441 3d7f 8985BCF2 		movl	%eax, -3396(%rbp)
 5441      FFFF
1158:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5442              		.loc 1 1158 0
 5443 3d85 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5443      FFFF00
 5444 3d8c 740F     		je	.L259
 5445              		.loc 1 1158 0 is_stmt 0 discriminator 1
 5446 3d8e C785B8F2 		movl	$1, -3400(%rbp)
 5446      FFFF0100 
 5446      0000
 5447 3d98 E9834000 		jmp	.L230
 5447      00
 5448              	.L259:
1159:main.c        **** 			if ( numDevices ) {
 5449              		.loc 1 1159 0 is_stmt 1
 5450 3d9d 8B85B0F2 		movl	-3408(%rbp), %eax
 5450      FFFF
 5451 3da3 85C0     		testl	%eax, %eax
 5452 3da5 745A     		je	.L260
1160:main.c        **** 				printf("The FPGALink device at %s scanned its JTAG chain, yielding:\n", vp);
 5453              		.loc 1 1160 0
 5454 3da7 488B85B8 		movq	-2888(%rbp), %rax
 5454      F4FFFF
 5455 3dae 4889C6   		movq	%rax, %rsi
 5456 3db1 BF000000 		movl	$.LC134, %edi
 5456      00
 5457 3db6 B8000000 		movl	$0, %eax
 5457      00
 5458 3dbb E8000000 		call	printf
 5458      00
1161:main.c        **** 				for ( i = 0; i < numDevices; i++ ) {
 5459              		.loc 1 1161 0
 5460 3dc0 C785C0F2 		movl	$0, -3392(%rbp)
 5460      FFFF0000 
 5460      0000
 5461 3dca EB25     		jmp	.L261
 5462              	.L262:
1162:main.c        **** 					printf("  0x%08X\n", scanChain[i]);
 5463              		.loc 1 1162 0 discriminator 3
 5464 3dcc 8B85C0F2 		movl	-3392(%rbp), %eax
 5464      FFFF
 5465 3dd2 8B848590 		movl	-2672(%rbp,%rax,4), %eax
 5465      F5FFFF
 5466 3dd9 89C6     		movl	%eax, %esi
 5467 3ddb BF000000 		movl	$.LC135, %edi
 5467      00
 5468 3de0 B8000000 		movl	$0, %eax
 5468      00
 5469 3de5 E8000000 		call	printf
 5469      00
1161:main.c        **** 				for ( i = 0; i < numDevices; i++ ) {
 5470              		.loc 1 1161 0 discriminator 3
 5471 3dea 8385C0F2 		addl	$1, -3392(%rbp)
 5471      FFFF01
 5472              	.L261:
1161:main.c        **** 				for ( i = 0; i < numDevices; i++ ) {
 5473              		.loc 1 1161 0 is_stmt 0 discriminator 1
 5474 3df1 8B85B0F2 		movl	-3408(%rbp), %eax
 5474      FFFF
 5475 3df7 3985C0F2 		cmpl	%eax, -3392(%rbp)
 5475      FFFF
 5476 3dfd 72CD     		jb	.L262
 5477 3dff EB4A     		jmp	.L256
 5478              	.L260:
1163:main.c        **** 				}
1164:main.c        **** 			} else {
1165:main.c        **** 				printf("The FPGALink device at %s scanned its JTAG chain but did not find any attached devices\
 5479              		.loc 1 1165 0 is_stmt 1
 5480 3e01 488B85B8 		movq	-2888(%rbp), %rax
 5480      F4FFFF
 5481 3e08 4889C6   		movq	%rax, %rsi
 5482 3e0b BF000000 		movl	$.LC136, %edi
 5482      00
 5483 3e10 B8000000 		movl	$0, %eax
 5483      00
 5484 3e15 E8000000 		call	printf
 5484      00
 5485 3e1a EB2F     		jmp	.L256
 5486              	.L257:
1166:main.c        **** 			}
1167:main.c        **** 		} else {
1168:main.c        **** 			fprintf(stderr, "JTAG chain scan requested but FPGALink device at %s does not support NeroProg\n
 5487              		.loc 1 1168 0
 5488 3e1c 488B0500 		movq	stderr(%rip), %rax
 5488      000000
 5489 3e23 488B95B8 		movq	-2888(%rbp), %rdx
 5489      F4FFFF
 5490 3e2a BE000000 		movl	$.LC137, %esi
 5490      00
 5491 3e2f 4889C7   		movq	%rax, %rdi
 5492 3e32 B8000000 		movl	$0, %eax
 5492      00
 5493 3e37 E8000000 		call	fprintf
 5493      00
1169:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 5494              		.loc 1 1169 0
 5495 3e3c C785B8F2 		movl	$12, -3400(%rbp)
 5495      FFFF0C00 
 5495      0000
 5496 3e46 E9D53F00 		jmp	.L230
 5496      00
 5497              	.L256:
1170:main.c        **** 		}
1171:main.c        **** 	}
1172:main.c        **** 
1173:main.c        **** 	if ( progOpt->count ) {
 5498              		.loc 1 1173 0
 5499 3e4b 488B8548 		movq	-3000(%rbp), %rax
 5499      F4FFFF
 5500 3e52 8B4060   		movl	96(%rax), %eax
 5501 3e55 85C0     		testl	%eax, %eax
 5502 3e57 0F84C900 		je	.L264
 5502      0000
1174:main.c        **** 		printf("Programming device...\n");
 5503              		.loc 1 1174 0
 5504 3e5d BF000000 		movl	$.LC138, %edi
 5504      00
 5505 3e62 E8000000 		call	puts
 5505      00
1175:main.c        **** 		if ( isNeroCapable ) {
 5506              		.loc 1 1175 0
 5507 3e67 80BDADF2 		cmpb	$0, -3411(%rbp)
 5507      FFFF00
 5508 3e6e 0F848300 		je	.L265
 5508      0000
1176:main.c        **** 			fStatus = flSelectConduit(handle, 0x00, &error);
 5509              		.loc 1 1176 0
 5510 3e74 488B85E0 		movq	-3104(%rbp), %rax
 5510      F3FFFF
 5511 3e7b 488D95E8 		leaq	-3096(%rbp), %rdx
 5511      F3FFFF
 5512 3e82 BE000000 		movl	$0, %esi
 5512      00
 5513 3e87 4889C7   		movq	%rax, %rdi
 5514 3e8a E8000000 		call	flSelectConduit
 5514      00
 5515 3e8f 8985BCF2 		movl	%eax, -3396(%rbp)
 5515      FFFF
1177:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5516              		.loc 1 1177 0
 5517 3e95 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5517      FFFF00
 5518 3e9c 740F     		je	.L266
 5519              		.loc 1 1177 0 is_stmt 0 discriminator 1
 5520 3e9e C785B8F2 		movl	$1, -3400(%rbp)
 5520      FFFF0100 
 5520      0000
 5521 3ea8 E9733F00 		jmp	.L230
 5521      00
 5522              	.L266:
1178:main.c        **** 			fStatus = flProgram(handle, progOpt->sval[0], NULL, &error);
 5523              		.loc 1 1178 0 is_stmt 1
 5524 3ead 488B8548 		movq	-3000(%rbp), %rax
 5524      F4FFFF
 5525 3eb4 488B4068 		movq	104(%rax), %rax
 5526 3eb8 488B30   		movq	(%rax), %rsi
 5527 3ebb 488B85E0 		movq	-3104(%rbp), %rax
 5527      F3FFFF
 5528 3ec2 488D95E8 		leaq	-3096(%rbp), %rdx
 5528      F3FFFF
 5529 3ec9 4889D1   		movq	%rdx, %rcx
 5530 3ecc BA000000 		movl	$0, %edx
 5530      00
 5531 3ed1 4889C7   		movq	%rax, %rdi
 5532 3ed4 E8000000 		call	flProgram
 5532      00
 5533 3ed9 8985BCF2 		movl	%eax, -3396(%rbp)
 5533      FFFF
1179:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5534              		.loc 1 1179 0
 5535 3edf 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5535      FFFF00
 5536 3ee6 743E     		je	.L264
 5537              		.loc 1 1179 0 is_stmt 0 discriminator 1
 5538 3ee8 C785B8F2 		movl	$1, -3400(%rbp)
 5538      FFFF0100 
 5538      0000
 5539 3ef2 E9293F00 		jmp	.L230
 5539      00
 5540              	.L265:
1180:main.c        **** 		} else {
1181:main.c        **** 			fprintf(stderr, "Program operation requested but device at %s does not support NeroProg\n", vp);
 5541              		.loc 1 1181 0 is_stmt 1
 5542 3ef7 488B0500 		movq	stderr(%rip), %rax
 5542      000000
 5543 3efe 488B95B8 		movq	-2888(%rbp), %rdx
 5543      F4FFFF
 5544 3f05 BE000000 		movl	$.LC139, %esi
 5544      00
 5545 3f0a 4889C7   		movq	%rax, %rdi
 5546 3f0d B8000000 		movl	$0, %eax
 5546      00
 5547 3f12 E8000000 		call	fprintf
 5547      00
1182:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 5548              		.loc 1 1182 0
 5549 3f17 C785B8F2 		movl	$12, -3400(%rbp)
 5549      FFFF0C00 
 5549      0000
 5550 3f21 E9FA3E00 		jmp	.L230
 5550      00
 5551              	.L264:
1183:main.c        **** 		}
1184:main.c        **** 	}
1185:main.c        **** 
1186:main.c        **** 	if ( benOpt->count ) {
 5552              		.loc 1 1186 0
 5553 3f26 488B8570 		movq	-2960(%rbp), %rax
 5553      F4FFFF
 5554 3f2d 8B4060   		movl	96(%rax), %eax
 5555 3f30 85C0     		testl	%eax, %eax
 5556 3f32 7407     		je	.L267
1187:main.c        **** 		enableBenchmarking = true;
 5557              		.loc 1 1187 0
 5558 3f34 C6050000 		movb	$1, enableBenchmarking(%rip)
 5558      000001
 5559              	.L267:
1188:main.c        **** 	}
1189:main.c        **** 	
1190:main.c        **** 	if ( actOpt->count ) {
 5560              		.loc 1 1190 0
 5561 3f3b 488B8558 		movq	-2984(%rbp), %rax
 5561      F4FFFF
 5562 3f42 8B4060   		movl	96(%rax), %eax
 5563 3f45 85C0     		testl	%eax, %eax
 5564 3f47 0F845201 		je	.L268
 5564      0000
1191:main.c        **** 		printf("Executing CommFPGA actions on FPGALink device %s...\n", vp);
 5565              		.loc 1 1191 0
 5566 3f4d 488B85B8 		movq	-2888(%rbp), %rax
 5566      F4FFFF
 5567 3f54 4889C6   		movq	%rax, %rsi
 5568 3f57 BF000000 		movl	$.LC140, %edi
 5568      00
 5569 3f5c B8000000 		movl	$0, %eax
 5569      00
 5570 3f61 E8000000 		call	printf
 5570      00
1192:main.c        **** 		if ( isCommCapable ) {
 5571              		.loc 1 1192 0
 5572 3f66 80BDAEF2 		cmpb	$0, -3410(%rbp)
 5572      FFFF00
 5573 3f6d 0F84FD00 		je	.L269
 5573      0000
 5574              	.LBB47:
1193:main.c        **** 			uint8 isRunning;
1194:main.c        **** 			fStatus = flSelectConduit(handle, conduit, &error);
 5575              		.loc 1 1194 0
 5576 3f73 0FB68DAB 		movzbl	-3413(%rbp), %ecx
 5576      F2FFFF
 5577 3f7a 488B85E0 		movq	-3104(%rbp), %rax
 5577      F3FFFF
 5578 3f81 488D95E8 		leaq	-3096(%rbp), %rdx
 5578      F3FFFF
 5579 3f88 89CE     		movl	%ecx, %esi
 5580 3f8a 4889C7   		movq	%rax, %rdi
 5581 3f8d E8000000 		call	flSelectConduit
 5581      00
 5582 3f92 8985BCF2 		movl	%eax, -3396(%rbp)
 5582      FFFF
1195:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5583              		.loc 1 1195 0
 5584 3f98 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5584      FFFF00
 5585 3f9f 740F     		je	.L270
 5586              		.loc 1 1195 0 is_stmt 0 discriminator 1
 5587 3fa1 C785B8F2 		movl	$1, -3400(%rbp)
 5587      FFFF0100 
 5587      0000
 5588 3fab E9703E00 		jmp	.L230
 5588      00
 5589              	.L270:
1196:main.c        **** 			fStatus = flIsFPGARunning(handle, &isRunning, &error);
 5590              		.loc 1 1196 0 is_stmt 1
 5591 3fb0 488B85E0 		movq	-3104(%rbp), %rax
 5591      F3FFFF
 5592 3fb7 488D95E8 		leaq	-3096(%rbp), %rdx
 5592      F3FFFF
 5593 3fbe 488D8D10 		leaq	-3056(%rbp), %rcx
 5593      F4FFFF
 5594 3fc5 4889CE   		movq	%rcx, %rsi
 5595 3fc8 4889C7   		movq	%rax, %rdi
 5596 3fcb E8000000 		call	flIsFPGARunning
 5596      00
 5597 3fd0 8985BCF2 		movl	%eax, -3396(%rbp)
 5597      FFFF
1197:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5598              		.loc 1 1197 0
 5599 3fd6 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5599      FFFF00
 5600 3fdd 740F     		je	.L272
 5601              		.loc 1 1197 0 is_stmt 0 discriminator 1
 5602 3fdf C785B8F2 		movl	$1, -3400(%rbp)
 5602      FFFF0100 
 5602      0000
 5603 3fe9 E9323E00 		jmp	.L230
 5603      00
 5604              	.L272:
1198:main.c        **** 			if ( isRunning ) {
 5605              		.loc 1 1198 0 is_stmt 1
 5606 3fee 0FB68510 		movzbl	-3056(%rbp), %eax
 5606      F4FFFF
 5607 3ff5 84C0     		testb	%al, %al
 5608 3ff7 7447     		je	.L273
1199:main.c        **** 				pStatus = parseLine(handle, actOpt->sval[0], &error);
 5609              		.loc 1 1199 0
 5610 3ff9 488B8558 		movq	-2984(%rbp), %rax
 5610      F4FFFF
 5611 4000 488B4068 		movq	104(%rax), %rax
 5612 4004 488B08   		movq	(%rax), %rcx
 5613 4007 488B85E0 		movq	-3104(%rbp), %rax
 5613      F3FFFF
 5614 400e 488D95E8 		leaq	-3096(%rbp), %rdx
 5614      F3FFFF
 5615 4015 4889CE   		movq	%rcx, %rsi
 5616 4018 4889C7   		movq	%rax, %rdi
 5617 401b E88EDFFF 		call	parseLine
 5617      FF
 5618 4020 8985A8F3 		movl	%eax, -3160(%rbp)
 5618      FFFF
1200:main.c        **** 				CHECK_STATUS(pStatus, pStatus, cleanup);
 5619              		.loc 1 1200 0
 5620 4026 83BDA8F3 		cmpl	$0, -3160(%rbp)
 5620      FFFF00
 5621 402d 7470     		je	.L268
 5622              		.loc 1 1200 0 is_stmt 0 discriminator 1
 5623 402f 8B85A8F3 		movl	-3160(%rbp), %eax
 5623      FFFF
 5624 4035 8985B8F2 		movl	%eax, -3400(%rbp)
 5624      FFFF
 5625 403b E9E03D00 		jmp	.L230
 5625      00
 5626              	.L273:
1201:main.c        **** 			} else {
1202:main.c        **** 				fprintf(stderr, "The FPGALink device at %s is not ready to talk - did you forget --program?\n",
 5627              		.loc 1 1202 0 is_stmt 1
 5628 4040 488B0500 		movq	stderr(%rip), %rax
 5628      000000
 5629 4047 488B95B8 		movq	-2888(%rbp), %rdx
 5629      F4FFFF
 5630 404e BE000000 		movl	$.LC141, %esi
 5630      00
 5631 4053 4889C7   		movq	%rax, %rdi
 5632 4056 B8000000 		movl	$0, %eax
 5632      00
 5633 405b E8000000 		call	fprintf
 5633      00
1203:main.c        **** 				FAIL(FLP_ARGS, cleanup);
 5634              		.loc 1 1203 0
 5635 4060 C785B8F2 		movl	$12, -3400(%rbp)
 5635      FFFF0C00 
 5635      0000
 5636 406a 90       		nop
 5637 406b E9B03D00 		jmp	.L230
 5637      00
 5638              	.L269:
 5639              	.LBE47:
1204:main.c        **** 			}
1205:main.c        **** 		} else {
1206:main.c        **** 			fprintf(stderr, "Action requested but device at %s does not support CommFPGA\n", vp);
 5640              		.loc 1 1206 0
 5641 4070 488B0500 		movq	stderr(%rip), %rax
 5641      000000
 5642 4077 488B95B8 		movq	-2888(%rbp), %rdx
 5642      F4FFFF
 5643 407e BE000000 		movl	$.LC142, %esi
 5643      00
 5644 4083 4889C7   		movq	%rax, %rdi
 5645 4086 B8000000 		movl	$0, %eax
 5645      00
 5646 408b E8000000 		call	fprintf
 5646      00
1207:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 5647              		.loc 1 1207 0
 5648 4090 C785B8F2 		movl	$12, -3400(%rbp)
 5648      FFFF0C00 
 5648      0000
 5649 409a E9813D00 		jmp	.L230
 5649      00
 5650              	.L268:
1208:main.c        **** 		}
1209:main.c        **** 	}
1210:main.c        **** 
1211:main.c        **** 	if ( dumpOpt->count ) {
 5651              		.loc 1 1211 0
 5652 409f 488B8580 		movq	-2944(%rbp), %rax
 5652      F4FFFF
 5653 40a6 8B4060   		movl	96(%rax), %eax
 5654 40a9 85C0     		testl	%eax, %eax
 5655 40ab 0F84D002 		je	.L275
 5655      0000
 5656              	.LBB48:
1212:main.c        **** 		const char *fileName;
1213:main.c        **** 		unsigned long chan = strtoul(dumpOpt->sval[0], (char**)&fileName, 10);
 5657              		.loc 1 1213 0
 5658 40b1 488B8580 		movq	-2944(%rbp), %rax
 5658      F4FFFF
 5659 40b8 488B4068 		movq	104(%rax), %rax
 5660 40bc 488B00   		movq	(%rax), %rax
 5661 40bf 488D8D08 		leaq	-3064(%rbp), %rcx
 5661      F4FFFF
 5662 40c6 BA0A0000 		movl	$10, %edx
 5662      00
 5663 40cb 4889CE   		movq	%rcx, %rsi
 5664 40ce 4889C7   		movq	%rax, %rdi
 5665 40d1 E8000000 		call	strtoul
 5665      00
 5666 40d6 488985C8 		movq	%rax, -2872(%rbp)
 5666      F4FFFF
1214:main.c        **** 		FILE *file = NULL;
 5667              		.loc 1 1214 0
 5668 40dd 48C785D0 		movq	$0, -2864(%rbp)
 5668      F4FFFF00 
 5668      000000
1215:main.c        **** 		const uint8 *recvData;
1216:main.c        **** 		uint32 actualLength;
1217:main.c        **** 		if ( *fileName != ':' ) {
 5669              		.loc 1 1217 0
 5670 40e8 488B8508 		movq	-3064(%rbp), %rax
 5670      F4FFFF
 5671 40ef 0FB600   		movzbl	(%rax), %eax
 5672 40f2 3C3A     		cmpb	$58, %al
 5673 40f4 742F     		je	.L276
1218:main.c        **** 			fprintf(stderr, "%s: invalid argument to option -l|--dumploop=<ch:file.bin>\n", progName);
 5674              		.loc 1 1218 0
 5675 40f6 488B0500 		movq	stderr(%rip), %rax
 5675      000000
 5676 40fd 488B95A8 		movq	-2904(%rbp), %rdx
 5676      F4FFFF
 5677 4104 BE000000 		movl	$.LC143, %esi
 5677      00
 5678 4109 4889C7   		movq	%rax, %rdi
 5679 410c B8000000 		movl	$0, %eax
 5679      00
 5680 4111 E8000000 		call	fprintf
 5680      00
1219:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 5681              		.loc 1 1219 0
 5682 4116 C785B8F2 		movl	$12, -3400(%rbp)
 5682      FFFF0C00 
 5682      0000
 5683 4120 E9FB3C00 		jmp	.L230
 5683      00
 5684              	.L276:
1220:main.c        **** 		}
1221:main.c        **** 		fileName++;
 5685              		.loc 1 1221 0
 5686 4125 488B8508 		movq	-3064(%rbp), %rax
 5686      F4FFFF
 5687 412c 4883C001 		addq	$1, %rax
 5688 4130 48898508 		movq	%rax, -3064(%rbp)
 5688      F4FFFF
1222:main.c        **** 		printf("Copying from channel %lu to %s", chan, fileName);
 5689              		.loc 1 1222 0
 5690 4137 488B9508 		movq	-3064(%rbp), %rdx
 5690      F4FFFF
 5691 413e 488B85C8 		movq	-2872(%rbp), %rax
 5691      F4FFFF
 5692 4145 4889C6   		movq	%rax, %rsi
 5693 4148 BF000000 		movl	$.LC144, %edi
 5693      00
 5694 414d B8000000 		movl	$0, %eax
 5694      00
 5695 4152 E8000000 		call	printf
 5695      00
1223:main.c        **** 		file = fopen(fileName, "wb");
 5696              		.loc 1 1223 0
 5697 4157 488B8508 		movq	-3064(%rbp), %rax
 5697      F4FFFF
 5698 415e BE000000 		movl	$.LC28, %esi
 5698      00
 5699 4163 4889C7   		movq	%rax, %rdi
 5700 4166 E8000000 		call	fopen
 5700      00
 5701 416b 488985D0 		movq	%rax, -2864(%rbp)
 5701      F4FFFF
1224:main.c        **** 		CHECK_STATUS(!file, FLP_CANNOT_SAVE, cleanup);
 5702              		.loc 1 1224 0
 5703 4172 4883BDD0 		cmpq	$0, -2864(%rbp)
 5703      F4FFFF00 
 5704 417a 750F     		jne	.L278
 5705              		.loc 1 1224 0 is_stmt 0 discriminator 1
 5706 417c C785B8F2 		movl	$11, -3400(%rbp)
 5706      FFFF0B00 
 5706      0000
 5707 4186 E9953C00 		jmp	.L230
 5707      00
 5708              	.L278:
1225:main.c        **** 		sigRegisterHandler();
 5709              		.loc 1 1225 0 is_stmt 1
 5710 418b E8000000 		call	sigRegisterHandler
 5710      00
1226:main.c        **** 		fStatus = flSelectConduit(handle, conduit, &error);
 5711              		.loc 1 1226 0
 5712 4190 0FB68DAB 		movzbl	-3413(%rbp), %ecx
 5712      F2FFFF
 5713 4197 488B85E0 		movq	-3104(%rbp), %rax
 5713      F3FFFF
 5714 419e 488D95E8 		leaq	-3096(%rbp), %rdx
 5714      F3FFFF
 5715 41a5 89CE     		movl	%ecx, %esi
 5716 41a7 4889C7   		movq	%rax, %rdi
 5717 41aa E8000000 		call	flSelectConduit
 5717      00
 5718 41af 8985BCF2 		movl	%eax, -3396(%rbp)
 5718      FFFF
1227:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5719              		.loc 1 1227 0
 5720 41b5 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5720      FFFF00
 5721 41bc 740F     		je	.L279
 5722              		.loc 1 1227 0 is_stmt 0 discriminator 1
 5723 41be C785B8F2 		movl	$1, -3400(%rbp)
 5723      FFFF0100 
 5723      0000
 5724 41c8 E9533C00 		jmp	.L230
 5724      00
 5725              	.L279:
1228:main.c        **** 		fStatus = flReadChannelAsyncSubmit(handle, (uint8)chan, 22528, NULL, &error);
 5726              		.loc 1 1228 0 is_stmt 1
 5727 41cd 488B85C8 		movq	-2872(%rbp), %rax
 5727      F4FFFF
 5728 41d4 0FB6F0   		movzbl	%al, %esi
 5729 41d7 488B85E0 		movq	-3104(%rbp), %rax
 5729      F3FFFF
 5730 41de 488D95E8 		leaq	-3096(%rbp), %rdx
 5730      F3FFFF
 5731 41e5 4989D0   		movq	%rdx, %r8
 5732 41e8 B9000000 		movl	$0, %ecx
 5732      00
 5733 41ed BA005800 		movl	$22528, %edx
 5733      00
 5734 41f2 4889C7   		movq	%rax, %rdi
 5735 41f5 E8000000 		call	flReadChannelAsyncSubmit
 5735      00
 5736 41fa 8985BCF2 		movl	%eax, -3396(%rbp)
 5736      FFFF
1229:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5737              		.loc 1 1229 0
 5738 4200 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5738      FFFF00
 5739 4207 740F     		je	.L280
 5740              		.loc 1 1229 0 is_stmt 0 discriminator 1
 5741 4209 C785B8F2 		movl	$1, -3400(%rbp)
 5741      FFFF0100 
 5741      0000
 5742 4213 E9083C00 		jmp	.L230
 5742      00
 5743              	.L280:
1230:main.c        **** 		do {
1231:main.c        **** 			fStatus = flReadChannelAsyncSubmit(handle, (uint8)chan, 22528, NULL, &error);
 5744              		.loc 1 1231 0 is_stmt 1
 5745 4218 488B85C8 		movq	-2872(%rbp), %rax
 5745      F4FFFF
 5746 421f 0FB6F0   		movzbl	%al, %esi
 5747 4222 488B85E0 		movq	-3104(%rbp), %rax
 5747      F3FFFF
 5748 4229 488D95E8 		leaq	-3096(%rbp), %rdx
 5748      F3FFFF
 5749 4230 4989D0   		movq	%rdx, %r8
 5750 4233 B9000000 		movl	$0, %ecx
 5750      00
 5751 4238 BA005800 		movl	$22528, %edx
 5751      00
 5752 423d 4889C7   		movq	%rax, %rdi
 5753 4240 E8000000 		call	flReadChannelAsyncSubmit
 5753      00
 5754 4245 8985BCF2 		movl	%eax, -3396(%rbp)
 5754      FFFF
1232:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5755              		.loc 1 1232 0
 5756 424b 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5756      FFFF00
 5757 4252 740F     		je	.L281
 5758              		.loc 1 1232 0 is_stmt 0 discriminator 1
 5759 4254 C785B8F2 		movl	$1, -3400(%rbp)
 5759      FFFF0100 
 5759      0000
 5760 425e E9BD3B00 		jmp	.L230
 5760      00
 5761              	.L281:
1233:main.c        **** 			fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 5762              		.loc 1 1233 0 is_stmt 1
 5763 4263 488B85E0 		movq	-3104(%rbp), %rax
 5763      F3FFFF
 5764 426a 488DBDE8 		leaq	-3096(%rbp), %rdi
 5764      F3FFFF
 5765 4271 488D8D00 		leaq	-3072(%rbp), %rcx
 5765      F4FFFF
 5766 4278 488D9500 		leaq	-3072(%rbp), %rdx
 5766      F4FFFF
 5767 427f 488DB510 		leaq	-3056(%rbp), %rsi
 5767      F4FFFF
 5768 4286 4989F8   		movq	%rdi, %r8
 5769 4289 4889C7   		movq	%rax, %rdi
 5770 428c E8000000 		call	flReadChannelAsyncAwait
 5770      00
 5771 4291 8985BCF2 		movl	%eax, -3396(%rbp)
 5771      FFFF
1234:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5772              		.loc 1 1234 0
 5773 4297 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5773      FFFF00
 5774 429e 740F     		je	.L282
 5775              		.loc 1 1234 0 is_stmt 0 discriminator 1
 5776 42a0 C785B8F2 		movl	$1, -3400(%rbp)
 5776      FFFF0100 
 5776      0000
 5777 42aa E9713B00 		jmp	.L230
 5777      00
 5778              	.L282:
1235:main.c        **** 			fwrite(recvData, 1, actualLength, file);
 5779              		.loc 1 1235 0 is_stmt 1
 5780 42af 8B8500F4 		movl	-3072(%rbp), %eax
 5780      FFFF
 5781 42b5 89C6     		movl	%eax, %esi
 5782 42b7 488B8510 		movq	-3056(%rbp), %rax
 5782      F4FFFF
 5783 42be 488B95D0 		movq	-2864(%rbp), %rdx
 5783      F4FFFF
 5784 42c5 4889D1   		movq	%rdx, %rcx
 5785 42c8 4889F2   		movq	%rsi, %rdx
 5786 42cb BE010000 		movl	$1, %esi
 5786      00
 5787 42d0 4889C7   		movq	%rax, %rdi
 5788 42d3 E8000000 		call	fwrite
 5788      00
1236:main.c        **** 			printf(".");
 5789              		.loc 1 1236 0
 5790 42d8 BF2E0000 		movl	$46, %edi
 5790      00
 5791 42dd E8000000 		call	putchar
 5791      00
1237:main.c        **** 		} while ( !sigIsRaised() );
 5792              		.loc 1 1237 0
 5793 42e2 E8000000 		call	sigIsRaised
 5793      00
 5794 42e7 83F001   		xorl	$1, %eax
 5795 42ea 84C0     		testb	%al, %al
 5796 42ec 0F8526FF 		jne	.L280
 5796      FFFF
1238:main.c        **** 		printf("\nCaught SIGINT, quitting...\n");
 5797              		.loc 1 1238 0
 5798 42f2 BF000000 		movl	$.LC145, %edi
 5798      00
 5799 42f7 E8000000 		call	puts
 5799      00
1239:main.c        **** 		fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 5800              		.loc 1 1239 0
 5801 42fc 488B85E0 		movq	-3104(%rbp), %rax
 5801      F3FFFF
 5802 4303 488DBDE8 		leaq	-3096(%rbp), %rdi
 5802      F3FFFF
 5803 430a 488D8D00 		leaq	-3072(%rbp), %rcx
 5803      F4FFFF
 5804 4311 488D9500 		leaq	-3072(%rbp), %rdx
 5804      F4FFFF
 5805 4318 488DB510 		leaq	-3056(%rbp), %rsi
 5805      F4FFFF
 5806 431f 4989F8   		movq	%rdi, %r8
 5807 4322 4889C7   		movq	%rax, %rdi
 5808 4325 E8000000 		call	flReadChannelAsyncAwait
 5808      00
 5809 432a 8985BCF2 		movl	%eax, -3396(%rbp)
 5809      FFFF
1240:main.c        **** 		CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5810              		.loc 1 1240 0
 5811 4330 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5811      FFFF00
 5812 4337 7410     		je	.L283
 5813              		.loc 1 1240 0 is_stmt 0 discriminator 1
 5814 4339 C785B8F2 		movl	$1, -3400(%rbp)
 5814      FFFF0100 
 5814      0000
 5815 4343 90       		nop
 5816 4344 E9D73A00 		jmp	.L230
 5816      00
 5817              	.L283:
1241:main.c        **** 		fwrite(recvData, 1, actualLength, file);
 5818              		.loc 1 1241 0 is_stmt 1
 5819 4349 8B8500F4 		movl	-3072(%rbp), %eax
 5819      FFFF
 5820 434f 89C6     		movl	%eax, %esi
 5821 4351 488B8510 		movq	-3056(%rbp), %rax
 5821      F4FFFF
 5822 4358 488B95D0 		movq	-2864(%rbp), %rdx
 5822      F4FFFF
 5823 435f 4889D1   		movq	%rdx, %rcx
 5824 4362 4889F2   		movq	%rsi, %rdx
 5825 4365 BE010000 		movl	$1, %esi
 5825      00
 5826 436a 4889C7   		movq	%rax, %rdi
 5827 436d E8000000 		call	fwrite
 5827      00
1242:main.c        **** 		fclose(file);
 5828              		.loc 1 1242 0
 5829 4372 488B85D0 		movq	-2864(%rbp), %rax
 5829      F4FFFF
 5830 4379 4889C7   		movq	%rax, %rdi
 5831 437c E8000000 		call	fclose
 5831      00
 5832              	.L275:
 5833              	.LBE48:
1243:main.c        **** 	}
1244:main.c        **** 
1245:main.c        **** 	if ( shellOpt->count ) 
 5834              		.loc 1 1245 0
 5835 4381 488B8568 		movq	-2968(%rbp), %rax
 5835      F4FFFF
 5836 4388 8B4060   		movl	96(%rax), %eax
 5837 438b 85C0     		testl	%eax, %eax
 5838 438d 0F84CB01 		je	.L284
 5838      0000
1246:main.c        **** 	{
1247:main.c        **** 		printf("\nEntering CommFPGA command-line mode:\n");
 5839              		.loc 1 1247 0
 5840 4393 BF000000 		movl	$.LC146, %edi
 5840      00
 5841 4398 E8000000 		call	puts
 5841      00
1248:main.c        **** 		if ( isCommCapable ) {
 5842              		.loc 1 1248 0
 5843 439d 80BDAEF2 		cmpb	$0, -3410(%rbp)
 5843      FFFF00
 5844 43a4 0F848501 		je	.L285
 5844      0000
 5845              	.LBB49:
1249:main.c        **** 			uint8 isRunning;
1250:main.c        **** 			fStatus = flSelectConduit(handle, conduit, &error);
 5846              		.loc 1 1250 0
 5847 43aa 0FB68DAB 		movzbl	-3413(%rbp), %ecx
 5847      F2FFFF
 5848 43b1 488B85E0 		movq	-3104(%rbp), %rax
 5848      F3FFFF
 5849 43b8 488D95E8 		leaq	-3096(%rbp), %rdx
 5849      F3FFFF
 5850 43bf 89CE     		movl	%ecx, %esi
 5851 43c1 4889C7   		movq	%rax, %rdi
 5852 43c4 E8000000 		call	flSelectConduit
 5852      00
 5853 43c9 8985BCF2 		movl	%eax, -3396(%rbp)
 5853      FFFF
1251:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5854              		.loc 1 1251 0
 5855 43cf 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5855      FFFF00
 5856 43d6 740F     		je	.L286
 5857              		.loc 1 1251 0 is_stmt 0 discriminator 1
 5858 43d8 C785B8F2 		movl	$1, -3400(%rbp)
 5858      FFFF0100 
 5858      0000
 5859 43e2 E9393A00 		jmp	.L230
 5859      00
 5860              	.L286:
1252:main.c        **** 			fStatus = flIsFPGARunning(handle, &isRunning, &error);
 5861              		.loc 1 1252 0 is_stmt 1
 5862 43e7 488B85E0 		movq	-3104(%rbp), %rax
 5862      F3FFFF
 5863 43ee 488D95E8 		leaq	-3096(%rbp), %rdx
 5863      F3FFFF
 5864 43f5 488D8D10 		leaq	-3056(%rbp), %rcx
 5864      F4FFFF
 5865 43fc 4889CE   		movq	%rcx, %rsi
 5866 43ff 4889C7   		movq	%rax, %rdi
 5867 4402 E8000000 		call	flIsFPGARunning
 5867      00
 5868 4407 8985BCF2 		movl	%eax, -3396(%rbp)
 5868      FFFF
1253:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5869              		.loc 1 1253 0
 5870 440d 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5870      FFFF00
 5871 4414 740F     		je	.L288
 5872              		.loc 1 1253 0 is_stmt 0 discriminator 1
 5873 4416 C785B8F2 		movl	$1, -3400(%rbp)
 5873      FFFF0100 
 5873      0000
 5874 4420 E9FB3900 		jmp	.L230
 5874      00
 5875              	.L288:
1254:main.c        **** 			if ( isRunning ) {
 5876              		.loc 1 1254 0 is_stmt 1
 5877 4425 0FB68510 		movzbl	-3056(%rbp), %eax
 5877      F4FFFF
 5878 442c 84C0     		testb	%al, %al
 5879 442e 0F84CB00 		je	.L289
 5879      0000
 5880              	.L291:
1255:main.c        **** 				do {
1256:main.c        **** 					do {
1257:main.c        **** 						line = readline("> ");
 5881              		.loc 1 1257 0 discriminator 2
 5882 4434 BF000000 		movl	$.LC147, %edi
 5882      00
 5883 4439 E8000000 		call	readline
 5883      00
 5884 443e 48898518 		movq	%rax, -3048(%rbp)
 5884      F4FFFF
1258:main.c        **** 					} while ( line && !line[0] );
 5885              		.loc 1 1258 0 discriminator 2
 5886 4445 4883BD18 		cmpq	$0, -3048(%rbp)
 5886      F4FFFF00 
 5887 444d 740E     		je	.L290
 5888              		.loc 1 1258 0 is_stmt 0 discriminator 1
 5889 444f 488B8518 		movq	-3048(%rbp), %rax
 5889      F4FFFF
 5890 4456 0FB600   		movzbl	(%rax), %eax
 5891 4459 84C0     		testb	%al, %al
 5892 445b 74D7     		je	.L291
 5893              	.L290:
1259:main.c        **** 					if ( line && line[0] && line[0] != 'q' ) {
 5894              		.loc 1 1259 0 is_stmt 1
 5895 445d 4883BD18 		cmpq	$0, -3048(%rbp)
 5895      F4FFFF00 
 5896 4465 747A     		je	.L292
 5897              		.loc 1 1259 0 is_stmt 0 discriminator 1
 5898 4467 488B8518 		movq	-3048(%rbp), %rax
 5898      F4FFFF
 5899 446e 0FB600   		movzbl	(%rax), %eax
 5900 4471 84C0     		testb	%al, %al
 5901 4473 746C     		je	.L292
 5902              		.loc 1 1259 0 discriminator 2
 5903 4475 488B8518 		movq	-3048(%rbp), %rax
 5903      F4FFFF
 5904 447c 0FB600   		movzbl	(%rax), %eax
 5905 447f 3C71     		cmpb	$113, %al
 5906 4481 745E     		je	.L292
1260:main.c        **** 						add_history(line);
 5907              		.loc 1 1260 0 is_stmt 1
 5908 4483 488B8518 		movq	-3048(%rbp), %rax
 5908      F4FFFF
 5909 448a 4889C7   		movq	%rax, %rdi
 5910 448d E8000000 		call	add_history
 5910      00
1261:main.c        **** 						pStatus = parseLine(handle, line, &error);
 5911              		.loc 1 1261 0
 5912 4492 488B85E0 		movq	-3104(%rbp), %rax
 5912      F3FFFF
 5913 4499 488D95E8 		leaq	-3096(%rbp), %rdx
 5913      F3FFFF
 5914 44a0 488B8D18 		movq	-3048(%rbp), %rcx
 5914      F4FFFF
 5915 44a7 4889CE   		movq	%rcx, %rsi
 5916 44aa 4889C7   		movq	%rax, %rdi
 5917 44ad E8FCDAFF 		call	parseLine
 5917      FF
 5918 44b2 8985A8F3 		movl	%eax, -3160(%rbp)
 5918      FFFF
1262:main.c        **** 						CHECK_STATUS(pStatus, pStatus, cleanup);
 5919              		.loc 1 1262 0
 5920 44b8 83BDA8F3 		cmpl	$0, -3160(%rbp)
 5920      FFFF00
 5921 44bf 7411     		je	.L293
 5922              		.loc 1 1262 0 is_stmt 0 discriminator 1
 5923 44c1 8B85A8F3 		movl	-3160(%rbp), %eax
 5923      FFFF
 5924 44c7 8985B8F2 		movl	%eax, -3400(%rbp)
 5924      FFFF
 5925 44cd E94E3900 		jmp	.L230
 5925      00
 5926              	.L293:
1263:main.c        **** 						free((void*)line);
 5927              		.loc 1 1263 0 is_stmt 1
 5928 44d2 488B8518 		movq	-3048(%rbp), %rax
 5928      F4FFFF
 5929 44d9 4889C7   		movq	%rax, %rdi
 5930 44dc E8000000 		call	free
 5930      00
 5931              	.L292:
1264:main.c        **** 					}
1265:main.c        **** 				} while ( line && line[0] != 'q' );
 5932              		.loc 1 1265 0
 5933 44e1 4883BD18 		cmpq	$0, -3048(%rbp)
 5933      F4FFFF00 
 5934 44e9 7473     		je	.L284
 5935              		.loc 1 1265 0 is_stmt 0 discriminator 1
 5936 44eb 488B8518 		movq	-3048(%rbp), %rax
 5936      F4FFFF
 5937 44f2 0FB600   		movzbl	(%rax), %eax
 5938 44f5 3C71     		cmpb	$113, %al
 5939 44f7 0F8537FF 		jne	.L291
 5939      FFFF
 5940 44fd EB5F     		jmp	.L284
 5941              	.L289:
1266:main.c        **** 			} else {
1267:main.c        **** 				fprintf(stderr, "The FPGALink device at %s is not ready to talk - did you forget --xsvf?\n", vp
 5942              		.loc 1 1267 0 is_stmt 1
 5943 44ff 488B0500 		movq	stderr(%rip), %rax
 5943      000000
 5944 4506 488B95B8 		movq	-2888(%rbp), %rdx
 5944      F4FFFF
 5945 450d BE000000 		movl	$.LC148, %esi
 5945      00
 5946 4512 4889C7   		movq	%rax, %rdi
 5947 4515 B8000000 		movl	$0, %eax
 5947      00
 5948 451a E8000000 		call	fprintf
 5948      00
1268:main.c        **** 				FAIL(FLP_ARGS, cleanup);
 5949              		.loc 1 1268 0
 5950 451f C785B8F2 		movl	$12, -3400(%rbp)
 5950      FFFF0C00 
 5950      0000
 5951 4529 90       		nop
 5952 452a E9F13800 		jmp	.L230
 5952      00
 5953              	.L285:
 5954              	.LBE49:
1269:main.c        **** 			}
1270:main.c        **** 		} else {
1271:main.c        **** 			fprintf(stderr, "Shell requested but device at %s does not support CommFPGA\n", vp);
 5955              		.loc 1 1271 0
 5956 452f 488B0500 		movq	stderr(%rip), %rax
 5956      000000
 5957 4536 488B95B8 		movq	-2888(%rbp), %rdx
 5957      F4FFFF
 5958 453d BE000000 		movl	$.LC149, %esi
 5958      00
 5959 4542 4889C7   		movq	%rax, %rdi
 5960 4545 B8000000 		movl	$0, %eax
 5960      00
 5961 454a E8000000 		call	fprintf
 5961      00
1272:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 5962              		.loc 1 1272 0
 5963 454f C785B8F2 		movl	$12, -3400(%rbp)
 5963      FFFF0C00 
 5963      0000
 5964 4559 E9C23800 		jmp	.L230
 5964      00
 5965              	.L284:
1273:main.c        **** 		}
1274:main.c        **** 	}
1275:main.c        **** 
1276:main.c        **** ///////////////////////////////////////////////////////////////////////////////////////////////////
1277:main.c        **** ///////////////////////////////////////////////////////////////////////////////////////////////////
1278:main.c        **** 	if (doworkOpt->count) 
 5966              		.loc 1 1278 0
 5967 455e 488B8560 		movq	-2976(%rbp), %rax
 5967      F4FFFF
 5968 4565 8B4060   		movl	96(%rax), %eax
 5969 4568 85C0     		testl	%eax, %eax
 5970 456a 0F84B038 		je	.L230
 5970      0000
1279:main.c        **** 	{
1280:main.c        **** 		//printf("%s\n", "Hello ");
1281:main.c        **** 		//int my_read_channel = 0;
1282:main.c        **** 		//uint8 my_write_channel = 0x01;
1283:main.c        **** 		//uint32 my_time_out = 0x00000002;
1284:main.c        **** 		//uint32 my_count = 0x0004;
1285:main.c        **** 		//uint32 *buf;
1286:main.c        **** 		// uint8 buf[4];
1287:main.c        **** 		// uint8 Ack1[4]={221,221,221,221};
1288:main.c        **** 		// uint8 Ack2[4]={187,187,187,187};
1289:main.c        **** 		//printf("%s\n", "Helloghjkl ");
1290:main.c        **** 		if ( isCommCapable ) 
 5971              		.loc 1 1290 0
 5972 4570 80BDAEF2 		cmpb	$0, -3410(%rbp)
 5972      FFFF00
 5973 4577 0F847838 		je	.L295
 5973      0000
 5974              	.LBB50:
1291:main.c        **** 		{
1292:main.c        **** 			uint8 isRunning;
1293:main.c        **** 			fStatus = flSelectConduit(handle, conduit, &error);
 5975              		.loc 1 1293 0
 5976 457d 0FB68DAB 		movzbl	-3413(%rbp), %ecx
 5976      F2FFFF
 5977 4584 488B85E0 		movq	-3104(%rbp), %rax
 5977      F3FFFF
 5978 458b 488D95E8 		leaq	-3096(%rbp), %rdx
 5978      F3FFFF
 5979 4592 89CE     		movl	%ecx, %esi
 5980 4594 4889C7   		movq	%rax, %rdi
 5981 4597 E8000000 		call	flSelectConduit
 5981      00
 5982 459c 8985BCF2 		movl	%eax, -3396(%rbp)
 5982      FFFF
1294:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5983              		.loc 1 1294 0
 5984 45a2 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5984      FFFF00
 5985 45a9 740F     		je	.L296
 5986              		.loc 1 1294 0 is_stmt 0 discriminator 1
 5987 45ab C785B8F2 		movl	$1, -3400(%rbp)
 5987      FFFF0100 
 5987      0000
 5988 45b5 E9663800 		jmp	.L230
 5988      00
 5989              	.L296:
1295:main.c        **** 			fStatus = flIsFPGARunning(handle, &isRunning, &error);
 5990              		.loc 1 1295 0 is_stmt 1
 5991 45ba 488B85E0 		movq	-3104(%rbp), %rax
 5991      F3FFFF
 5992 45c1 488D95E8 		leaq	-3096(%rbp), %rdx
 5992      F3FFFF
 5993 45c8 488D8DA8 		leaq	-3416(%rbp), %rcx
 5993      F2FFFF
 5994 45cf 4889CE   		movq	%rcx, %rsi
 5995 45d2 4889C7   		movq	%rax, %rdi
 5996 45d5 E8000000 		call	flIsFPGARunning
 5996      00
 5997 45da 8985BCF2 		movl	%eax, -3396(%rbp)
 5997      FFFF
1296:main.c        **** 			CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 5998              		.loc 1 1296 0
 5999 45e0 83BDBCF2 		cmpl	$0, -3396(%rbp)
 5999      FFFF00
 6000 45e7 740F     		je	.L298
 6001              		.loc 1 1296 0 is_stmt 0 discriminator 1
 6002 45e9 C785B8F2 		movl	$1, -3400(%rbp)
 6002      FFFF0100 
 6002      0000
 6003 45f3 E9283800 		jmp	.L230
 6003      00
 6004              	.L298:
1297:main.c        **** 			uint8 *recvData;
1298:main.c        **** 			recvData = malloc(8);
 6005              		.loc 1 1298 0 is_stmt 1
 6006 45f8 BF080000 		movl	$8, %edi
 6006      00
 6007 45fd E8000000 		call	malloc
 6007      00
 6008 4602 488985F0 		movq	%rax, -3088(%rbp)
 6008      F3FFFF
1299:main.c        **** 			uint32 actualLength;
1300:main.c        **** 			if ( isRunning ) 
 6009              		.loc 1 1300 0
 6010 4609 0FB685A8 		movzbl	-3416(%rbp), %eax
 6010      F2FFFF
 6011 4610 84C0     		testb	%al, %al
 6012 4612 0F84B037 		je	.L299
 6012      0000
 6013              	.LBB51:
1301:main.c        **** 			{
1302:main.c        **** 				int K[32] = {0,1,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0};
 6014              		.loc 1 1302 0
 6015 4618 C785D0F5 		movl	$0, -2608(%rbp)
 6015      FFFF0000 
 6015      0000
 6016 4622 C785D4F5 		movl	$1, -2604(%rbp)
 6016      FFFF0100 
 6016      0000
 6017 462c C785D8F5 		movl	$0, -2600(%rbp)
 6017      FFFF0000 
 6017      0000
 6018 4636 C785DCF5 		movl	$0, -2596(%rbp)
 6018      FFFF0000 
 6018      0000
 6019 4640 C785E0F5 		movl	$1, -2592(%rbp)
 6019      FFFF0100 
 6019      0000
 6020 464a C785E4F5 		movl	$1, -2588(%rbp)
 6020      FFFF0100 
 6020      0000
 6021 4654 C785E8F5 		movl	$1, -2584(%rbp)
 6021      FFFF0100 
 6021      0000
 6022 465e C785ECF5 		movl	$1, -2580(%rbp)
 6022      FFFF0100 
 6022      0000
 6023 4668 C785F0F5 		movl	$1, -2576(%rbp)
 6023      FFFF0100 
 6023      0000
 6024 4672 C785F4F5 		movl	$1, -2572(%rbp)
 6024      FFFF0100 
 6024      0000
 6025 467c C785F8F5 		movl	$1, -2568(%rbp)
 6025      FFFF0100 
 6025      0000
 6026 4686 C785FCF5 		movl	$1, -2564(%rbp)
 6026      FFFF0100 
 6026      0000
 6027 4690 C78500F6 		movl	$0, -2560(%rbp)
 6027      FFFF0000 
 6027      0000
 6028 469a C78504F6 		movl	$0, -2556(%rbp)
 6028      FFFF0000 
 6028      0000
 6029 46a4 C78508F6 		movl	$0, -2552(%rbp)
 6029      FFFF0000 
 6029      0000
 6030 46ae C7850CF6 		movl	$0, -2548(%rbp)
 6030      FFFF0000 
 6030      0000
 6031 46b8 C78510F6 		movl	$0, -2544(%rbp)
 6031      FFFF0000 
 6031      0000
 6032 46c2 C78514F6 		movl	$0, -2540(%rbp)
 6032      FFFF0000 
 6032      0000
 6033 46cc C78518F6 		movl	$1, -2536(%rbp)
 6033      FFFF0100 
 6033      0000
 6034 46d6 C7851CF6 		movl	$1, -2532(%rbp)
 6034      FFFF0100 
 6034      0000
 6035 46e0 C78520F6 		movl	$1, -2528(%rbp)
 6035      FFFF0100 
 6035      0000
 6036 46ea C78524F6 		movl	$0, -2524(%rbp)
 6036      FFFF0000 
 6036      0000
 6037 46f4 C78528F6 		movl	$1, -2520(%rbp)
 6037      FFFF0100 
 6037      0000
 6038 46fe C7852CF6 		movl	$0, -2516(%rbp)
 6038      FFFF0000 
 6038      0000
 6039 4708 C78530F6 		movl	$1, -2512(%rbp)
 6039      FFFF0100 
 6039      0000
 6040 4712 C78534F6 		movl	$0, -2508(%rbp)
 6040      FFFF0000 
 6040      0000
 6041 471c C78538F6 		movl	$1, -2504(%rbp)
 6041      FFFF0100 
 6041      0000
 6042 4726 C7853CF6 		movl	$1, -2500(%rbp)
 6042      FFFF0100 
 6042      0000
 6043 4730 C78540F6 		movl	$1, -2496(%rbp)
 6043      FFFF0100 
 6043      0000
 6044 473a C78544F6 		movl	$0, -2492(%rbp)
 6044      FFFF0000 
 6044      0000
 6045 4744 C78548F6 		movl	$1, -2488(%rbp)
 6045      FFFF0100 
 6045      0000
 6046 474e C7854CF6 		movl	$0, -2484(%rbp)
 6046      FFFF0000 
 6046      0000
1303:main.c        **** 				int ack1[32] = {0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1};
 6047              		.loc 1 1303 0
 6048 4758 C78550F6 		movl	$0, -2480(%rbp)
 6048      FFFF0000 
 6048      0000
 6049 4762 C78554F6 		movl	$1, -2476(%rbp)
 6049      FFFF0100 
 6049      0000
 6050 476c C78558F6 		movl	$0, -2472(%rbp)
 6050      FFFF0000 
 6050      0000
 6051 4776 C7855CF6 		movl	$1, -2468(%rbp)
 6051      FFFF0100 
 6051      0000
 6052 4780 C78560F6 		movl	$0, -2464(%rbp)
 6052      FFFF0000 
 6052      0000
 6053 478a C78564F6 		movl	$1, -2460(%rbp)
 6053      FFFF0100 
 6053      0000
 6054 4794 C78568F6 		movl	$0, -2456(%rbp)
 6054      FFFF0000 
 6054      0000
 6055 479e C7856CF6 		movl	$1, -2452(%rbp)
 6055      FFFF0100 
 6055      0000
 6056 47a8 C78570F6 		movl	$0, -2448(%rbp)
 6056      FFFF0000 
 6056      0000
 6057 47b2 C78574F6 		movl	$1, -2444(%rbp)
 6057      FFFF0100 
 6057      0000
 6058 47bc C78578F6 		movl	$0, -2440(%rbp)
 6058      FFFF0000 
 6058      0000
 6059 47c6 C7857CF6 		movl	$1, -2436(%rbp)
 6059      FFFF0100 
 6059      0000
 6060 47d0 C78580F6 		movl	$0, -2432(%rbp)
 6060      FFFF0000 
 6060      0000
 6061 47da C78584F6 		movl	$1, -2428(%rbp)
 6061      FFFF0100 
 6061      0000
 6062 47e4 C78588F6 		movl	$0, -2424(%rbp)
 6062      FFFF0000 
 6062      0000
 6063 47ee C7858CF6 		movl	$1, -2420(%rbp)
 6063      FFFF0100 
 6063      0000
 6064 47f8 C78590F6 		movl	$0, -2416(%rbp)
 6064      FFFF0000 
 6064      0000
 6065 4802 C78594F6 		movl	$1, -2412(%rbp)
 6065      FFFF0100 
 6065      0000
 6066 480c C78598F6 		movl	$0, -2408(%rbp)
 6066      FFFF0000 
 6066      0000
 6067 4816 C7859CF6 		movl	$1, -2404(%rbp)
 6067      FFFF0100 
 6067      0000
 6068 4820 C785A0F6 		movl	$0, -2400(%rbp)
 6068      FFFF0000 
 6068      0000
 6069 482a C785A4F6 		movl	$1, -2396(%rbp)
 6069      FFFF0100 
 6069      0000
 6070 4834 C785A8F6 		movl	$0, -2392(%rbp)
 6070      FFFF0000 
 6070      0000
 6071 483e C785ACF6 		movl	$1, -2388(%rbp)
 6071      FFFF0100 
 6071      0000
 6072 4848 C785B0F6 		movl	$0, -2384(%rbp)
 6072      FFFF0000 
 6072      0000
 6073 4852 C785B4F6 		movl	$1, -2380(%rbp)
 6073      FFFF0100 
 6073      0000
 6074 485c C785B8F6 		movl	$0, -2376(%rbp)
 6074      FFFF0000 
 6074      0000
 6075 4866 C785BCF6 		movl	$1, -2372(%rbp)
 6075      FFFF0100 
 6075      0000
 6076 4870 C785C0F6 		movl	$0, -2368(%rbp)
 6076      FFFF0000 
 6076      0000
 6077 487a C785C4F6 		movl	$1, -2364(%rbp)
 6077      FFFF0100 
 6077      0000
 6078 4884 C785C8F6 		movl	$0, -2360(%rbp)
 6078      FFFF0000 
 6078      0000
 6079 488e C785CCF6 		movl	$1, -2356(%rbp)
 6079      FFFF0100 
 6079      0000
1304:main.c        **** 				int ack2[32] = {0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1};
 6080              		.loc 1 1304 0
 6081 4898 C785D0F6 		movl	$0, -2352(%rbp)
 6081      FFFF0000 
 6081      0000
 6082 48a2 C785D4F6 		movl	$0, -2348(%rbp)
 6082      FFFF0000 
 6082      0000
 6083 48ac C785D8F6 		movl	$1, -2344(%rbp)
 6083      FFFF0100 
 6083      0000
 6084 48b6 C785DCF6 		movl	$1, -2340(%rbp)
 6084      FFFF0100 
 6084      0000
 6085 48c0 C785E0F6 		movl	$0, -2336(%rbp)
 6085      FFFF0000 
 6085      0000
 6086 48ca C785E4F6 		movl	$0, -2332(%rbp)
 6086      FFFF0000 
 6086      0000
 6087 48d4 C785E8F6 		movl	$1, -2328(%rbp)
 6087      FFFF0100 
 6087      0000
 6088 48de C785ECF6 		movl	$1, -2324(%rbp)
 6088      FFFF0100 
 6088      0000
 6089 48e8 C785F0F6 		movl	$0, -2320(%rbp)
 6089      FFFF0000 
 6089      0000
 6090 48f2 C785F4F6 		movl	$0, -2316(%rbp)
 6090      FFFF0000 
 6090      0000
 6091 48fc C785F8F6 		movl	$1, -2312(%rbp)
 6091      FFFF0100 
 6091      0000
 6092 4906 C785FCF6 		movl	$1, -2308(%rbp)
 6092      FFFF0100 
 6092      0000
 6093 4910 C78500F7 		movl	$0, -2304(%rbp)
 6093      FFFF0000 
 6093      0000
 6094 491a C78504F7 		movl	$0, -2300(%rbp)
 6094      FFFF0000 
 6094      0000
 6095 4924 C78508F7 		movl	$1, -2296(%rbp)
 6095      FFFF0100 
 6095      0000
 6096 492e C7850CF7 		movl	$1, -2292(%rbp)
 6096      FFFF0100 
 6096      0000
 6097 4938 C78510F7 		movl	$0, -2288(%rbp)
 6097      FFFF0000 
 6097      0000
 6098 4942 C78514F7 		movl	$0, -2284(%rbp)
 6098      FFFF0000 
 6098      0000
 6099 494c C78518F7 		movl	$1, -2280(%rbp)
 6099      FFFF0100 
 6099      0000
 6100 4956 C7851CF7 		movl	$1, -2276(%rbp)
 6100      FFFF0100 
 6100      0000
 6101 4960 C78520F7 		movl	$0, -2272(%rbp)
 6101      FFFF0000 
 6101      0000
 6102 496a C78524F7 		movl	$0, -2268(%rbp)
 6102      FFFF0000 
 6102      0000
 6103 4974 C78528F7 		movl	$1, -2264(%rbp)
 6103      FFFF0100 
 6103      0000
 6104 497e C7852CF7 		movl	$1, -2260(%rbp)
 6104      FFFF0100 
 6104      0000
 6105 4988 C78530F7 		movl	$0, -2256(%rbp)
 6105      FFFF0000 
 6105      0000
 6106 4992 C78534F7 		movl	$0, -2252(%rbp)
 6106      FFFF0000 
 6106      0000
 6107 499c C78538F7 		movl	$1, -2248(%rbp)
 6107      FFFF0100 
 6107      0000
 6108 49a6 C7853CF7 		movl	$1, -2244(%rbp)
 6108      FFFF0100 
 6108      0000
 6109 49b0 C78540F7 		movl	$0, -2240(%rbp)
 6109      FFFF0000 
 6109      0000
 6110 49ba C78544F7 		movl	$0, -2236(%rbp)
 6110      FFFF0000 
 6110      0000
 6111 49c4 C78548F7 		movl	$1, -2232(%rbp)
 6111      FFFF0100 
 6111      0000
 6112 49ce C7854CF7 		movl	$1, -2228(%rbp)
 6112      FFFF0100 
 6112      0000
1305:main.c        **** 				int reset_bytes[8] = {0,0,0,1,1,0,0,0};
 6113              		.loc 1 1305 0
 6114 49d8 C785F0F4 		movl	$0, -2832(%rbp)
 6114      FFFF0000 
 6114      0000
 6115 49e2 C785F4F4 		movl	$0, -2828(%rbp)
 6115      FFFF0000 
 6115      0000
 6116 49ec C785F8F4 		movl	$0, -2824(%rbp)
 6116      FFFF0000 
 6116      0000
 6117 49f6 C785FCF4 		movl	$1, -2820(%rbp)
 6117      FFFF0100 
 6117      0000
 6118 4a00 C78500F5 		movl	$1, -2816(%rbp)
 6118      FFFF0100 
 6118      0000
 6119 4a0a C78504F5 		movl	$0, -2812(%rbp)
 6119      FFFF0000 
 6119      0000
 6120 4a14 C78508F5 		movl	$0, -2808(%rbp)
 6120      FFFF0000 
 6120      0000
 6121 4a1e C7850CF5 		movl	$0, -2804(%rbp)
 6121      FFFF0000 
 6121      0000
1306:main.c        **** 				int reset_int = bitArrayToInt(reset_bytes,8);
 6122              		.loc 1 1306 0
 6123 4a28 488D85F0 		leaq	-2832(%rbp), %rax
 6123      F4FFFF
 6124 4a2f BE080000 		movl	$8, %esi
 6124      00
 6125 4a34 4889C7   		movq	%rax, %rdi
 6126 4a37 E8000000 		call	bitArrayToInt
 6126      00
 6127 4a3c 8985ACF3 		movl	%eax, -3156(%rbp)
 6127      FFFF
1307:main.c        **** 				uint8 reset = (uint8)reset_int;
 6128              		.loc 1 1307 0
 6129 4a42 8B85ACF3 		movl	-3156(%rbp), %eax
 6129      FFFF
 6130 4a48 8885AFF2 		movb	%al, -3409(%rbp)
 6130      FFFF
1308:main.c        **** 				int del = 1000;
 6131              		.loc 1 1308 0
 6132 4a4e C785B0F3 		movl	$1000, -3152(%rbp)
 6132      FFFFE803 
 6132      0000
 6133              	.LBB52:
1309:main.c        **** 				for (int k = 0; k < 64; ++k)
 6134              		.loc 1 1309 0
 6135 4a58 C785C8F2 		movl	$0, -3384(%rbp)
 6135      FFFF0000 
 6135      0000
 6136 4a62 E9523300 		jmp	.L300
 6136      00
 6137              	.L511:
 6138              	.LBB53:
1310:main.c        **** 				{	printf("%s","Channel = " );
 6139              		.loc 1 1310 0
 6140 4a67 BE000000 		movl	$.LC150, %esi
 6140      00
 6141 4a6c BF000000 		movl	$.LC151, %edi
 6141      00
 6142 4a71 B8000000 		movl	$0, %eax
 6142      00
 6143 4a76 E8000000 		call	printf
 6143      00
1311:main.c        **** 					printf("%d\n",2*k );
 6144              		.loc 1 1311 0
 6145 4a7b 8B85C8F2 		movl	-3384(%rbp), %eax
 6145      FFFF
 6146 4a81 01C0     		addl	%eax, %eax
 6147 4a83 89C6     		movl	%eax, %esi
 6148 4a85 BF000000 		movl	$.LC152, %edi
 6148      00
 6149 4a8a B8000000 		movl	$0, %eax
 6149      00
 6150 4a8f E8000000 		call	printf
 6150      00
1312:main.c        **** 					uint8 get_encrypted_coord[4];
1313:main.c        **** 					printf("%s\n", "----------------------H2.1 started----------------------- ");
 6151              		.loc 1 1313 0
 6152 4a94 BF000000 		movl	$.LC153, %edi
 6152      00
 6153 4a99 E8000000 		call	puts
 6153      00
1314:main.c        **** 					printf("%s\n", "Waiting for encrypted co_ordinates");
 6154              		.loc 1 1314 0
 6155 4a9e BF000000 		movl	$.LC154, %edi
 6155      00
 6156 4aa3 E8000000 		call	puts
 6156      00
1315:main.c        **** 
1316:main.c        **** 					delay(del * 1000);
 6157              		.loc 1 1316 0
 6158 4aa8 8B85B0F3 		movl	-3152(%rbp), %eax
 6158      FFFF
 6159 4aae 69C0E803 		imull	$1000, %eax, %eax
 6159      0000
 6160 4ab4 89C7     		movl	%eax, %edi
 6161 4ab6 E8000000 		call	delay
 6161      00
1317:main.c        **** 					fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &get_encrypted_coord[0], &error);
 6162              		.loc 1 1317 0
 6163 4abb 8B85C8F2 		movl	-3384(%rbp), %eax
 6163      FFFF
 6164 4ac1 01C0     		addl	%eax, %eax
 6165 4ac3 0FB6F0   		movzbl	%al, %esi
 6166 4ac6 488B85E0 		movq	-3104(%rbp), %rax
 6166      F3FFFF
 6167 4acd 488D8DE8 		leaq	-3096(%rbp), %rcx
 6167      F3FFFF
 6168 4ad4 488D9560 		leaq	-160(%rbp), %rdx
 6168      FFFFFF
 6169 4adb 4989C8   		movq	%rcx, %r8
 6170 4ade 4889D1   		movq	%rdx, %rcx
 6171 4ae1 BA010000 		movl	$1, %edx
 6171      00
 6172 4ae6 4889C7   		movq	%rax, %rdi
 6173 4ae9 E8000000 		call	flReadChannelAsyncSubmit
 6173      00
 6174 4aee 8985BCF2 		movl	%eax, -3396(%rbp)
 6174      FFFF
1318:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6175              		.loc 1 1318 0
 6176 4af4 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6176      FFFF00
 6177 4afb 740F     		je	.L301
 6178              		.loc 1 1318 0 is_stmt 0 discriminator 1
 6179 4afd C785B8F2 		movl	$1, -3400(%rbp)
 6179      FFFF0100 
 6179      0000
 6180 4b07 E9143300 		jmp	.L230
 6180      00
 6181              	.L301:
1319:main.c        **** 					fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 6182              		.loc 1 1319 0 is_stmt 1
 6183 4b0c 488B85E0 		movq	-3104(%rbp), %rax
 6183      F3FFFF
 6184 4b13 488DBDE8 		leaq	-3096(%rbp), %rdi
 6184      F3FFFF
 6185 4b1a 488D8DB4 		leaq	-3404(%rbp), %rcx
 6185      F2FFFF
 6186 4b21 488D95B4 		leaq	-3404(%rbp), %rdx
 6186      F2FFFF
 6187 4b28 488DB5F0 		leaq	-3088(%rbp), %rsi
 6187      F3FFFF
 6188 4b2f 4989F8   		movq	%rdi, %r8
 6189 4b32 4889C7   		movq	%rax, %rdi
 6190 4b35 E8000000 		call	flReadChannelAsyncAwait
 6190      00
 6191 4b3a 8985BCF2 		movl	%eax, -3396(%rbp)
 6191      FFFF
1320:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6192              		.loc 1 1320 0
 6193 4b40 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6193      FFFF00
 6194 4b47 740F     		je	.L303
 6195              		.loc 1 1320 0 is_stmt 0 discriminator 1
 6196 4b49 C785B8F2 		movl	$1, -3400(%rbp)
 6196      FFFF0100 
 6196      0000
 6197 4b53 E9C83200 		jmp	.L230
 6197      00
 6198              	.L303:
1321:main.c        **** 					if(get_encrypted_coord[0] == reset) 
 6199              		.loc 1 1321 0 is_stmt 1
 6200 4b58 0FB68560 		movzbl	-160(%rbp), %eax
 6200      FFFFFF
 6201 4b5f 3A85AFF2 		cmpb	-3409(%rbp), %al
 6201      FFFF
 6202 4b65 7516     		jne	.L304
1322:main.c        **** 						{
1323:main.c        **** 							k--; 
 6203              		.loc 1 1323 0
 6204 4b67 83ADC8F2 		subl	$1, -3384(%rbp)
 6204      FFFF01
1324:main.c        **** 							printf("%s\n", "-------------------------RESET------------------------");
 6205              		.loc 1 1324 0
 6206 4b6e BF000000 		movl	$.LC155, %edi
 6206      00
 6207 4b73 E8000000 		call	puts
 6207      00
1325:main.c        **** 							continue;
 6208              		.loc 1 1325 0
 6209 4b78 E9353200 		jmp	.L305
 6209      00
 6210              	.L304:
1326:main.c        **** 						}
1327:main.c        **** 					delay(del);
 6211              		.loc 1 1327 0
 6212 4b7d 8B85B0F3 		movl	-3152(%rbp), %eax
 6212      FFFF
 6213 4b83 89C7     		movl	%eax, %edi
 6214 4b85 E8000000 		call	delay
 6214      00
1328:main.c        **** 					fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &get_encrypted_coord[1], &error);
 6215              		.loc 1 1328 0
 6216 4b8a 8B85C8F2 		movl	-3384(%rbp), %eax
 6216      FFFF
 6217 4b90 01C0     		addl	%eax, %eax
 6218 4b92 0FB6F0   		movzbl	%al, %esi
 6219 4b95 488B85E0 		movq	-3104(%rbp), %rax
 6219      F3FFFF
 6220 4b9c 488D8DE8 		leaq	-3096(%rbp), %rcx
 6220      F3FFFF
 6221 4ba3 488D9560 		leaq	-160(%rbp), %rdx
 6221      FFFFFF
 6222 4baa 4883C201 		addq	$1, %rdx
 6223 4bae 4989C8   		movq	%rcx, %r8
 6224 4bb1 4889D1   		movq	%rdx, %rcx
 6225 4bb4 BA010000 		movl	$1, %edx
 6225      00
 6226 4bb9 4889C7   		movq	%rax, %rdi
 6227 4bbc E8000000 		call	flReadChannelAsyncSubmit
 6227      00
 6228 4bc1 8985BCF2 		movl	%eax, -3396(%rbp)
 6228      FFFF
1329:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6229              		.loc 1 1329 0
 6230 4bc7 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6230      FFFF00
 6231 4bce 740F     		je	.L306
 6232              		.loc 1 1329 0 is_stmt 0 discriminator 1
 6233 4bd0 C785B8F2 		movl	$1, -3400(%rbp)
 6233      FFFF0100 
 6233      0000
 6234 4bda E9413200 		jmp	.L230
 6234      00
 6235              	.L306:
1330:main.c        **** 					fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 6236              		.loc 1 1330 0 is_stmt 1
 6237 4bdf 488B85E0 		movq	-3104(%rbp), %rax
 6237      F3FFFF
 6238 4be6 488DBDE8 		leaq	-3096(%rbp), %rdi
 6238      F3FFFF
 6239 4bed 488D8DB4 		leaq	-3404(%rbp), %rcx
 6239      F2FFFF
 6240 4bf4 488D95B4 		leaq	-3404(%rbp), %rdx
 6240      F2FFFF
 6241 4bfb 488DB5F0 		leaq	-3088(%rbp), %rsi
 6241      F3FFFF
 6242 4c02 4989F8   		movq	%rdi, %r8
 6243 4c05 4889C7   		movq	%rax, %rdi
 6244 4c08 E8000000 		call	flReadChannelAsyncAwait
 6244      00
 6245 4c0d 8985BCF2 		movl	%eax, -3396(%rbp)
 6245      FFFF
1331:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6246              		.loc 1 1331 0
 6247 4c13 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6247      FFFF00
 6248 4c1a 740F     		je	.L307
 6249              		.loc 1 1331 0 is_stmt 0 discriminator 1
 6250 4c1c C785B8F2 		movl	$1, -3400(%rbp)
 6250      FFFF0100 
 6250      0000
 6251 4c26 E9F53100 		jmp	.L230
 6251      00
 6252              	.L307:
1332:main.c        **** 					if(get_encrypted_coord[1] == reset) 
 6253              		.loc 1 1332 0 is_stmt 1
 6254 4c2b 0FB68561 		movzbl	-159(%rbp), %eax
 6254      FFFFFF
 6255 4c32 3A85AFF2 		cmpb	-3409(%rbp), %al
 6255      FFFF
 6256 4c38 7516     		jne	.L308
1333:main.c        **** 						{
1334:main.c        **** 							k--; 
 6257              		.loc 1 1334 0
 6258 4c3a 83ADC8F2 		subl	$1, -3384(%rbp)
 6258      FFFF01
1335:main.c        **** 							printf("%s\n", "-------------------------RESET------------------------");							
 6259              		.loc 1 1335 0
 6260 4c41 BF000000 		movl	$.LC155, %edi
 6260      00
 6261 4c46 E8000000 		call	puts
 6261      00
1336:main.c        **** 							continue;
 6262              		.loc 1 1336 0
 6263 4c4b E9623100 		jmp	.L305
 6263      00
 6264              	.L308:
1337:main.c        **** 						}
1338:main.c        **** 					delay(del);
 6265              		.loc 1 1338 0
 6266 4c50 8B85B0F3 		movl	-3152(%rbp), %eax
 6266      FFFF
 6267 4c56 89C7     		movl	%eax, %edi
 6268 4c58 E8000000 		call	delay
 6268      00
1339:main.c        **** 					fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &get_encrypted_coord[2], &error);
 6269              		.loc 1 1339 0
 6270 4c5d 8B85C8F2 		movl	-3384(%rbp), %eax
 6270      FFFF
 6271 4c63 01C0     		addl	%eax, %eax
 6272 4c65 0FB6F0   		movzbl	%al, %esi
 6273 4c68 488B85E0 		movq	-3104(%rbp), %rax
 6273      F3FFFF
 6274 4c6f 488D8DE8 		leaq	-3096(%rbp), %rcx
 6274      F3FFFF
 6275 4c76 488D9560 		leaq	-160(%rbp), %rdx
 6275      FFFFFF
 6276 4c7d 4883C202 		addq	$2, %rdx
 6277 4c81 4989C8   		movq	%rcx, %r8
 6278 4c84 4889D1   		movq	%rdx, %rcx
 6279 4c87 BA010000 		movl	$1, %edx
 6279      00
 6280 4c8c 4889C7   		movq	%rax, %rdi
 6281 4c8f E8000000 		call	flReadChannelAsyncSubmit
 6281      00
 6282 4c94 8985BCF2 		movl	%eax, -3396(%rbp)
 6282      FFFF
1340:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6283              		.loc 1 1340 0
 6284 4c9a 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6284      FFFF00
 6285 4ca1 740F     		je	.L309
 6286              		.loc 1 1340 0 is_stmt 0 discriminator 1
 6287 4ca3 C785B8F2 		movl	$1, -3400(%rbp)
 6287      FFFF0100 
 6287      0000
 6288 4cad E96E3100 		jmp	.L230
 6288      00
 6289              	.L309:
1341:main.c        **** 					fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 6290              		.loc 1 1341 0 is_stmt 1
 6291 4cb2 488B85E0 		movq	-3104(%rbp), %rax
 6291      F3FFFF
 6292 4cb9 488DBDE8 		leaq	-3096(%rbp), %rdi
 6292      F3FFFF
 6293 4cc0 488D8DB4 		leaq	-3404(%rbp), %rcx
 6293      F2FFFF
 6294 4cc7 488D95B4 		leaq	-3404(%rbp), %rdx
 6294      F2FFFF
 6295 4cce 488DB5F0 		leaq	-3088(%rbp), %rsi
 6295      F3FFFF
 6296 4cd5 4989F8   		movq	%rdi, %r8
 6297 4cd8 4889C7   		movq	%rax, %rdi
 6298 4cdb E8000000 		call	flReadChannelAsyncAwait
 6298      00
 6299 4ce0 8985BCF2 		movl	%eax, -3396(%rbp)
 6299      FFFF
1342:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6300              		.loc 1 1342 0
 6301 4ce6 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6301      FFFF00
 6302 4ced 740F     		je	.L310
 6303              		.loc 1 1342 0 is_stmt 0 discriminator 1
 6304 4cef C785B8F2 		movl	$1, -3400(%rbp)
 6304      FFFF0100 
 6304      0000
 6305 4cf9 E9223100 		jmp	.L230
 6305      00
 6306              	.L310:
1343:main.c        **** 					if(get_encrypted_coord[2] == reset) 
 6307              		.loc 1 1343 0 is_stmt 1
 6308 4cfe 0FB68562 		movzbl	-158(%rbp), %eax
 6308      FFFFFF
 6309 4d05 3A85AFF2 		cmpb	-3409(%rbp), %al
 6309      FFFF
 6310 4d0b 7516     		jne	.L311
1344:main.c        **** 						{
1345:main.c        **** 							k--; 
 6311              		.loc 1 1345 0
 6312 4d0d 83ADC8F2 		subl	$1, -3384(%rbp)
 6312      FFFF01
1346:main.c        **** 							printf("%s\n", "-------------------------RESET------------------------");							
 6313              		.loc 1 1346 0
 6314 4d14 BF000000 		movl	$.LC155, %edi
 6314      00
 6315 4d19 E8000000 		call	puts
 6315      00
1347:main.c        **** 							continue;
 6316              		.loc 1 1347 0
 6317 4d1e E98F3000 		jmp	.L305
 6317      00
 6318              	.L311:
1348:main.c        **** 						}
1349:main.c        **** 					delay(del);
 6319              		.loc 1 1349 0
 6320 4d23 8B85B0F3 		movl	-3152(%rbp), %eax
 6320      FFFF
 6321 4d29 89C7     		movl	%eax, %edi
 6322 4d2b E8000000 		call	delay
 6322      00
1350:main.c        **** 					fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &get_encrypted_coord[3], &error);
 6323              		.loc 1 1350 0
 6324 4d30 8B85C8F2 		movl	-3384(%rbp), %eax
 6324      FFFF
 6325 4d36 01C0     		addl	%eax, %eax
 6326 4d38 0FB6F0   		movzbl	%al, %esi
 6327 4d3b 488B85E0 		movq	-3104(%rbp), %rax
 6327      F3FFFF
 6328 4d42 488D8DE8 		leaq	-3096(%rbp), %rcx
 6328      F3FFFF
 6329 4d49 488D9560 		leaq	-160(%rbp), %rdx
 6329      FFFFFF
 6330 4d50 4883C203 		addq	$3, %rdx
 6331 4d54 4989C8   		movq	%rcx, %r8
 6332 4d57 4889D1   		movq	%rdx, %rcx
 6333 4d5a BA010000 		movl	$1, %edx
 6333      00
 6334 4d5f 4889C7   		movq	%rax, %rdi
 6335 4d62 E8000000 		call	flReadChannelAsyncSubmit
 6335      00
 6336 4d67 8985BCF2 		movl	%eax, -3396(%rbp)
 6336      FFFF
1351:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6337              		.loc 1 1351 0
 6338 4d6d 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6338      FFFF00
 6339 4d74 740F     		je	.L312
 6340              		.loc 1 1351 0 is_stmt 0 discriminator 1
 6341 4d76 C785B8F2 		movl	$1, -3400(%rbp)
 6341      FFFF0100 
 6341      0000
 6342 4d80 E99B3000 		jmp	.L230
 6342      00
 6343              	.L312:
1352:main.c        **** 					fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 6344              		.loc 1 1352 0 is_stmt 1
 6345 4d85 488B85E0 		movq	-3104(%rbp), %rax
 6345      F3FFFF
 6346 4d8c 488DBDE8 		leaq	-3096(%rbp), %rdi
 6346      F3FFFF
 6347 4d93 488D8DB4 		leaq	-3404(%rbp), %rcx
 6347      F2FFFF
 6348 4d9a 488D95B4 		leaq	-3404(%rbp), %rdx
 6348      F2FFFF
 6349 4da1 488DB5F0 		leaq	-3088(%rbp), %rsi
 6349      F3FFFF
 6350 4da8 4989F8   		movq	%rdi, %r8
 6351 4dab 4889C7   		movq	%rax, %rdi
 6352 4dae E8000000 		call	flReadChannelAsyncAwait
 6352      00
 6353 4db3 8985BCF2 		movl	%eax, -3396(%rbp)
 6353      FFFF
1353:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6354              		.loc 1 1353 0
 6355 4db9 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6355      FFFF00
 6356 4dc0 740F     		je	.L313
 6357              		.loc 1 1353 0 is_stmt 0 discriminator 1
 6358 4dc2 C785B8F2 		movl	$1, -3400(%rbp)
 6358      FFFF0100 
 6358      0000
 6359 4dcc E94F3000 		jmp	.L230
 6359      00
 6360              	.L313:
1354:main.c        **** 					if(get_encrypted_coord[3] == reset) 
 6361              		.loc 1 1354 0 is_stmt 1
 6362 4dd1 0FB68563 		movzbl	-157(%rbp), %eax
 6362      FFFFFF
 6363 4dd8 3A85AFF2 		cmpb	-3409(%rbp), %al
 6363      FFFF
 6364 4dde 7516     		jne	.L314
1355:main.c        **** 						{
1356:main.c        **** 							k--; 
 6365              		.loc 1 1356 0
 6366 4de0 83ADC8F2 		subl	$1, -3384(%rbp)
 6366      FFFF01
1357:main.c        **** 							printf("%s\n", "-------------------------RESET------------------------");
 6367              		.loc 1 1357 0
 6368 4de7 BF000000 		movl	$.LC155, %edi
 6368      00
 6369 4dec E8000000 		call	puts
 6369      00
1358:main.c        **** 							continue;
 6370              		.loc 1 1358 0
 6371 4df1 E9BC2F00 		jmp	.L305
 6371      00
 6372              	.L314:
1359:main.c        **** 						}
1360:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6373              		.loc 1 1360 0
 6374 4df6 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6374      FFFF00
 6375 4dfd 740F     		je	.L315
 6376              		.loc 1 1360 0 is_stmt 0 discriminator 1
 6377 4dff C785B8F2 		movl	$1, -3400(%rbp)
 6377      FFFF0100 
 6377      0000
 6378 4e09 E9123000 		jmp	.L230
 6378      00
 6379              	.L315:
1361:main.c        **** 
1362:main.c        **** 					printf("%s\n", "Got the encrypted co_ordinates, they are as in uint8 form --");
 6380              		.loc 1 1362 0 is_stmt 1
 6381 4e0e BF000000 		movl	$.LC156, %edi
 6381      00
 6382 4e13 E8000000 		call	puts
 6382      00
 6383              	.LBB54:
1363:main.c        **** 					for (int i = 0; i < 4; ++i)
 6384              		.loc 1 1363 0
 6385 4e18 C785CCF2 		movl	$0, -3380(%rbp)
 6385      FFFF0000 
 6385      0000
 6386 4e22 EB2B     		jmp	.L316
 6387              	.L317:
1364:main.c        **** 					{
1365:main.c        **** 						printf("%d ", get_encrypted_coord[i]);
 6388              		.loc 1 1365 0 discriminator 3
 6389 4e24 8B85CCF2 		movl	-3380(%rbp), %eax
 6389      FFFF
 6390 4e2a 4898     		cltq
 6391 4e2c 0FB68405 		movzbl	-160(%rbp,%rax), %eax
 6391      60FFFFFF 
 6392 4e34 0FB6C0   		movzbl	%al, %eax
 6393 4e37 89C6     		movl	%eax, %esi
 6394 4e39 BF000000 		movl	$.LC10, %edi
 6394      00
 6395 4e3e B8000000 		movl	$0, %eax
 6395      00
 6396 4e43 E8000000 		call	printf
 6396      00
1363:main.c        **** 					for (int i = 0; i < 4; ++i)
 6397              		.loc 1 1363 0 discriminator 3
 6398 4e48 8385CCF2 		addl	$1, -3380(%rbp)
 6398      FFFF01
 6399              	.L316:
1363:main.c        **** 					for (int i = 0; i < 4; ++i)
 6400              		.loc 1 1363 0 is_stmt 0 discriminator 1
 6401 4e4f 83BDCCF2 		cmpl	$3, -3380(%rbp)
 6401      FFFF03
 6402 4e56 7ECC     		jle	.L317
 6403              	.LBE54:
1366:main.c        **** 					}
1367:main.c        **** 					printf("\n");
 6404              		.loc 1 1367 0 is_stmt 1
 6405 4e58 BF0A0000 		movl	$10, %edi
 6405      00
 6406 4e5d E8000000 		call	putchar
 6406      00
1368:main.c        **** 					int encrypted_pos[32];
1369:main.c        **** 					uint8ToBin(get_encrypted_coord, encrypted_pos);
 6407              		.loc 1 1369 0
 6408 4e62 488D9550 		leaq	-2224(%rbp), %rdx
 6408      F7FFFF
 6409 4e69 488D8560 		leaq	-160(%rbp), %rax
 6409      FFFFFF
 6410 4e70 4889D6   		movq	%rdx, %rsi
 6411 4e73 4889C7   		movq	%rax, %rdi
 6412 4e76 E8000000 		call	uint8ToBin
 6412      00
1370:main.c        **** 					printf("%s\n", "encrypted_pos is converted to binary");
 6413              		.loc 1 1370 0
 6414 4e7b BF000000 		movl	$.LC157, %edi
 6414      00
 6415 4e80 E8000000 		call	puts
 6415      00
1371:main.c        **** 					printf("%s\n", "The encrypted_pos are as --");
 6416              		.loc 1 1371 0
 6417 4e85 BF000000 		movl	$.LC158, %edi
 6417      00
 6418 4e8a E8000000 		call	puts
 6418      00
 6419              	.LBB55:
1372:main.c        **** 					for (int i = 0; i < 32; ++i)
 6420              		.loc 1 1372 0
 6421 4e8f C785D0F2 		movl	$0, -3376(%rbp)
 6421      FFFF0000 
 6421      0000
 6422 4e99 EB27     		jmp	.L318
 6423              	.L319:
1373:main.c        **** 					{
1374:main.c        **** 						printf("%d ", encrypted_pos[i]);
 6424              		.loc 1 1374 0 discriminator 3
 6425 4e9b 8B85D0F2 		movl	-3376(%rbp), %eax
 6425      FFFF
 6426 4ea1 4898     		cltq
 6427 4ea3 8B848550 		movl	-2224(%rbp,%rax,4), %eax
 6427      F7FFFF
 6428 4eaa 89C6     		movl	%eax, %esi
 6429 4eac BF000000 		movl	$.LC10, %edi
 6429      00
 6430 4eb1 B8000000 		movl	$0, %eax
 6430      00
 6431 4eb6 E8000000 		call	printf
 6431      00
1372:main.c        **** 					for (int i = 0; i < 32; ++i)
 6432              		.loc 1 1372 0 discriminator 3
 6433 4ebb 8385D0F2 		addl	$1, -3376(%rbp)
 6433      FFFF01
 6434              	.L318:
1372:main.c        **** 					for (int i = 0; i < 32; ++i)
 6435              		.loc 1 1372 0 is_stmt 0 discriminator 1
 6436 4ec2 83BDD0F2 		cmpl	$31, -3376(%rbp)
 6436      FFFF1F
 6437 4ec9 7ED0     		jle	.L319
 6438              	.LBE55:
1375:main.c        **** 					}
1376:main.c        **** 					printf("\n");
 6439              		.loc 1 1376 0 is_stmt 1
 6440 4ecb BF0A0000 		movl	$10, %edi
 6440      00
 6441 4ed0 E8000000 		call	putchar
 6441      00
1377:main.c        **** 					int decrypted_pos[32];
1378:main.c        **** 					decrypter(encrypted_pos, K, decrypted_pos);
 6442              		.loc 1 1378 0
 6443 4ed5 488D95D0 		leaq	-2096(%rbp), %rdx
 6443      F7FFFF
 6444 4edc 488D8DD0 		leaq	-2608(%rbp), %rcx
 6444      F5FFFF
 6445 4ee3 488D8550 		leaq	-2224(%rbp), %rax
 6445      F7FFFF
 6446 4eea 4889CE   		movq	%rcx, %rsi
 6447 4eed 4889C7   		movq	%rax, %rdi
 6448 4ef0 E8000000 		call	decrypter
 6448      00
1379:main.c        **** 					printf("%s\n", "The decrypted pos in binary form are as --");
 6449              		.loc 1 1379 0
 6450 4ef5 BF000000 		movl	$.LC159, %edi
 6450      00
 6451 4efa E8000000 		call	puts
 6451      00
 6452              	.LBB56:
1380:main.c        **** 					for (int i = 0; i < 32; ++i)
 6453              		.loc 1 1380 0
 6454 4eff C785D4F2 		movl	$0, -3372(%rbp)
 6454      FFFF0000 
 6454      0000
 6455 4f09 EB27     		jmp	.L320
 6456              	.L321:
1381:main.c        **** 					{
1382:main.c        **** 						printf("%d ", decrypted_pos[i]);
 6457              		.loc 1 1382 0 discriminator 3
 6458 4f0b 8B85D4F2 		movl	-3372(%rbp), %eax
 6458      FFFF
 6459 4f11 4898     		cltq
 6460 4f13 8B8485D0 		movl	-2096(%rbp,%rax,4), %eax
 6460      F7FFFF
 6461 4f1a 89C6     		movl	%eax, %esi
 6462 4f1c BF000000 		movl	$.LC10, %edi
 6462      00
 6463 4f21 B8000000 		movl	$0, %eax
 6463      00
 6464 4f26 E8000000 		call	printf
 6464      00
1380:main.c        **** 					for (int i = 0; i < 32; ++i)
 6465              		.loc 1 1380 0 discriminator 3
 6466 4f2b 8385D4F2 		addl	$1, -3372(%rbp)
 6466      FFFF01
 6467              	.L320:
1380:main.c        **** 					for (int i = 0; i < 32; ++i)
 6468              		.loc 1 1380 0 is_stmt 0 discriminator 1
 6469 4f32 83BDD4F2 		cmpl	$31, -3372(%rbp)
 6469      FFFF1F
 6470 4f39 7ED0     		jle	.L321
 6471              	.LBE56:
1383:main.c        **** 					}
1384:main.c        **** 					printf("\n");
 6472              		.loc 1 1384 0 is_stmt 1
 6473 4f3b BF0A0000 		movl	$10, %edi
 6473      00
 6474 4f40 E8000000 		call	putchar
 6474      00
1385:main.c        **** 					printf("%s\n", "----------------------H2.1 ended----------------------- ");
 6475              		.loc 1 1385 0
 6476 4f45 BF000000 		movl	$.LC160, %edi
 6476      00
 6477 4f4a E8000000 		call	puts
 6477      00
1386:main.c        **** 					printf("%s\n", "----------------------H2.2 started----------------------- ");
 6478              		.loc 1 1386 0
 6479 4f4f BF000000 		movl	$.LC161, %edi
 6479      00
 6480 4f54 E8000000 		call	puts
 6480      00
1387:main.c        **** 					
1388:main.c        **** 					int encrypted_pos2[32];
1389:main.c        **** 					encrypter(decrypted_pos, K, encrypted_pos2);
 6481              		.loc 1 1389 0
 6482 4f59 488D9550 		leaq	-1968(%rbp), %rdx
 6482      F8FFFF
 6483 4f60 488D8DD0 		leaq	-2608(%rbp), %rcx
 6483      F5FFFF
 6484 4f67 488D85D0 		leaq	-2096(%rbp), %rax
 6484      F7FFFF
 6485 4f6e 4889CE   		movq	%rcx, %rsi
 6486 4f71 4889C7   		movq	%rax, %rdi
 6487 4f74 E8000000 		call	encrypter
 6487      00
1390:main.c        **** 					printf("%s\n", "The co_ordinates are re-encrypted in binary form");
 6488              		.loc 1 1390 0
 6489 4f79 BF000000 		movl	$.LC162, %edi
 6489      00
 6490 4f7e E8000000 		call	puts
 6490      00
1391:main.c        **** 					printf("%s\n", "The re-encrypted co_ords are as follows");
 6491              		.loc 1 1391 0
 6492 4f83 BF000000 		movl	$.LC163, %edi
 6492      00
 6493 4f88 E8000000 		call	puts
 6493      00
 6494              	.LBB57:
1392:main.c        **** 					for (int i = 0; i < 32; ++i)
 6495              		.loc 1 1392 0
 6496 4f8d C785D8F2 		movl	$0, -3368(%rbp)
 6496      FFFF0000 
 6496      0000
 6497 4f97 EB27     		jmp	.L322
 6498              	.L323:
1393:main.c        **** 					{
1394:main.c        **** 						printf("%d ", encrypted_pos2[i]);
 6499              		.loc 1 1394 0 discriminator 3
 6500 4f99 8B85D8F2 		movl	-3368(%rbp), %eax
 6500      FFFF
 6501 4f9f 4898     		cltq
 6502 4fa1 8B848550 		movl	-1968(%rbp,%rax,4), %eax
 6502      F8FFFF
 6503 4fa8 89C6     		movl	%eax, %esi
 6504 4faa BF000000 		movl	$.LC10, %edi
 6504      00
 6505 4faf B8000000 		movl	$0, %eax
 6505      00
 6506 4fb4 E8000000 		call	printf
 6506      00
1392:main.c        **** 					for (int i = 0; i < 32; ++i)
 6507              		.loc 1 1392 0 discriminator 3
 6508 4fb9 8385D8F2 		addl	$1, -3368(%rbp)
 6508      FFFF01
 6509              	.L322:
1392:main.c        **** 					for (int i = 0; i < 32; ++i)
 6510              		.loc 1 1392 0 is_stmt 0 discriminator 1
 6511 4fc0 83BDD8F2 		cmpl	$31, -3368(%rbp)
 6511      FFFF1F
 6512 4fc7 7ED0     		jle	.L323
 6513              	.LBE57:
1395:main.c        **** 					}
1396:main.c        **** 					printf("\n");
 6514              		.loc 1 1396 0 is_stmt 1
 6515 4fc9 BF0A0000 		movl	$10, %edi
 6515      00
 6516 4fce E8000000 		call	putchar
 6516      00
1397:main.c        **** 					uint8 send_encrypted_coord[4];
1398:main.c        **** 					printf("%s\n", "Converting the re-encrypted data in binary to uint8 form");
 6517              		.loc 1 1398 0
 6518 4fd3 BF000000 		movl	$.LC164, %edi
 6518      00
 6519 4fd8 E8000000 		call	puts
 6519      00
1399:main.c        **** 					BinTouint8(send_encrypted_coord, encrypted_pos);
 6520              		.loc 1 1399 0
 6521 4fdd 488D9550 		leaq	-2224(%rbp), %rdx
 6521      F7FFFF
 6522 4fe4 488D8570 		leaq	-144(%rbp), %rax
 6522      FFFFFF
 6523 4feb 4889D6   		movq	%rdx, %rsi
 6524 4fee 4889C7   		movq	%rax, %rdi
 6525 4ff1 E8000000 		call	BinTouint8
 6525      00
1400:main.c        **** 					printf("%s\n", "Preparing to send the encrypted co_ordinates ");
 6526              		.loc 1 1400 0
 6527 4ff6 BF000000 		movl	$.LC165, %edi
 6527      00
 6528 4ffb E8000000 		call	puts
 6528      00
1401:main.c        **** 					delay(del);
 6529              		.loc 1 1401 0
 6530 5000 8B85B0F3 		movl	-3152(%rbp), %eax
 6530      FFFF
 6531 5006 89C7     		movl	%eax, %edi
 6532 5008 E8000000 		call	delay
 6532      00
1402:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &send_encrypted_coord[0], &error);
 6533              		.loc 1 1402 0
 6534 500d 8B85C8F2 		movl	-3384(%rbp), %eax
 6534      FFFF
 6535 5013 01C0     		addl	%eax, %eax
 6536 5015 83C001   		addl	$1, %eax
 6537 5018 0FB6F0   		movzbl	%al, %esi
 6538 501b 488B85E0 		movq	-3104(%rbp), %rax
 6538      F3FFFF
 6539 5022 488D8DE8 		leaq	-3096(%rbp), %rcx
 6539      F3FFFF
 6540 5029 488D9570 		leaq	-144(%rbp), %rdx
 6540      FFFFFF
 6541 5030 4989C8   		movq	%rcx, %r8
 6542 5033 4889D1   		movq	%rdx, %rcx
 6543 5036 BA010000 		movl	$1, %edx
 6543      00
 6544 503b 4889C7   		movq	%rax, %rdi
 6545 503e E8000000 		call	flWriteChannel
 6545      00
 6546 5043 8985BCF2 		movl	%eax, -3396(%rbp)
 6546      FFFF
1403:main.c        **** 					delay(del);
 6547              		.loc 1 1403 0
 6548 5049 8B85B0F3 		movl	-3152(%rbp), %eax
 6548      FFFF
 6549 504f 89C7     		movl	%eax, %edi
 6550 5051 E8000000 		call	delay
 6550      00
1404:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &send_encrypted_coord[1], &error);
 6551              		.loc 1 1404 0
 6552 5056 8B85C8F2 		movl	-3384(%rbp), %eax
 6552      FFFF
 6553 505c 01C0     		addl	%eax, %eax
 6554 505e 83C001   		addl	$1, %eax
 6555 5061 0FB6F0   		movzbl	%al, %esi
 6556 5064 488B85E0 		movq	-3104(%rbp), %rax
 6556      F3FFFF
 6557 506b 488D8DE8 		leaq	-3096(%rbp), %rcx
 6557      F3FFFF
 6558 5072 488D9570 		leaq	-144(%rbp), %rdx
 6558      FFFFFF
 6559 5079 4883C201 		addq	$1, %rdx
 6560 507d 4989C8   		movq	%rcx, %r8
 6561 5080 4889D1   		movq	%rdx, %rcx
 6562 5083 BA010000 		movl	$1, %edx
 6562      00
 6563 5088 4889C7   		movq	%rax, %rdi
 6564 508b E8000000 		call	flWriteChannel
 6564      00
 6565 5090 8985BCF2 		movl	%eax, -3396(%rbp)
 6565      FFFF
1405:main.c        **** 					delay(del);
 6566              		.loc 1 1405 0
 6567 5096 8B85B0F3 		movl	-3152(%rbp), %eax
 6567      FFFF
 6568 509c 89C7     		movl	%eax, %edi
 6569 509e E8000000 		call	delay
 6569      00
1406:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &send_encrypted_coord[2], &error);
 6570              		.loc 1 1406 0
 6571 50a3 8B85C8F2 		movl	-3384(%rbp), %eax
 6571      FFFF
 6572 50a9 01C0     		addl	%eax, %eax
 6573 50ab 83C001   		addl	$1, %eax
 6574 50ae 0FB6F0   		movzbl	%al, %esi
 6575 50b1 488B85E0 		movq	-3104(%rbp), %rax
 6575      F3FFFF
 6576 50b8 488D8DE8 		leaq	-3096(%rbp), %rcx
 6576      F3FFFF
 6577 50bf 488D9570 		leaq	-144(%rbp), %rdx
 6577      FFFFFF
 6578 50c6 4883C202 		addq	$2, %rdx
 6579 50ca 4989C8   		movq	%rcx, %r8
 6580 50cd 4889D1   		movq	%rdx, %rcx
 6581 50d0 BA010000 		movl	$1, %edx
 6581      00
 6582 50d5 4889C7   		movq	%rax, %rdi
 6583 50d8 E8000000 		call	flWriteChannel
 6583      00
 6584 50dd 8985BCF2 		movl	%eax, -3396(%rbp)
 6584      FFFF
1407:main.c        **** 					delay(del);
 6585              		.loc 1 1407 0
 6586 50e3 8B85B0F3 		movl	-3152(%rbp), %eax
 6586      FFFF
 6587 50e9 89C7     		movl	%eax, %edi
 6588 50eb E8000000 		call	delay
 6588      00
1408:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &send_encrypted_coord[3], &error);
 6589              		.loc 1 1408 0
 6590 50f0 8B85C8F2 		movl	-3384(%rbp), %eax
 6590      FFFF
 6591 50f6 01C0     		addl	%eax, %eax
 6592 50f8 83C001   		addl	$1, %eax
 6593 50fb 0FB6F0   		movzbl	%al, %esi
 6594 50fe 488B85E0 		movq	-3104(%rbp), %rax
 6594      F3FFFF
 6595 5105 488D8DE8 		leaq	-3096(%rbp), %rcx
 6595      F3FFFF
 6596 510c 488D9570 		leaq	-144(%rbp), %rdx
 6596      FFFFFF
 6597 5113 4883C203 		addq	$3, %rdx
 6598 5117 4989C8   		movq	%rcx, %r8
 6599 511a 4889D1   		movq	%rdx, %rcx
 6600 511d BA010000 		movl	$1, %edx
 6600      00
 6601 5122 4889C7   		movq	%rax, %rdi
 6602 5125 E8000000 		call	flWriteChannel
 6602      00
 6603 512a 8985BCF2 		movl	%eax, -3396(%rbp)
 6603      FFFF
1409:main.c        **** 
1410:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6604              		.loc 1 1410 0
 6605 5130 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6605      FFFF00
 6606 5137 740F     		je	.L324
 6607              		.loc 1 1410 0 is_stmt 0 discriminator 1
 6608 5139 C785B8F2 		movl	$1, -3400(%rbp)
 6608      FFFF0100 
 6608      0000
 6609 5143 E9D82C00 		jmp	.L230
 6609      00
 6610              	.L324:
1411:main.c        **** 					printf("%s\n", "Successfully send the encrypted co_ordinates in uint8 form");
 6611              		.loc 1 1411 0 is_stmt 1
 6612 5148 BF000000 		movl	$.LC166, %edi
 6612      00
 6613 514d E8000000 		call	puts
 6613      00
1412:main.c        **** 
1413:main.c        **** 					printf("%s\n", "----------------------H2.2 ended----------------------- ");
 6614              		.loc 1 1413 0
 6615 5152 BF000000 		movl	$.LC167, %edi
 6615      00
 6616 5157 E8000000 		call	puts
 6616      00
1414:main.c        **** 
1415:main.c        **** 					printf("%s\n", "----------------------H2.3 started----------------------- ");
 6617              		.loc 1 1415 0
 6618 515c BF000000 		movl	$.LC168, %edi
 6618      00
 6619 5161 E8000000 		call	puts
 6619      00
1416:main.c        **** 					printf("%s\n", "Waiting to get Ack1 from the fpga controller");
 6620              		.loc 1 1416 0
 6621 5166 BF000000 		movl	$.LC169, %edi
 6621      00
 6622 516b E8000000 		call	puts
 6622      00
1417:main.c        **** 					uint8 first_ack1_received[4];
1418:main.c        **** 					delay(del);
 6623              		.loc 1 1418 0
 6624 5170 8B85B0F3 		movl	-3152(%rbp), %eax
 6624      FFFF
 6625 5176 89C7     		movl	%eax, %edi
 6626 5178 E8000000 		call	delay
 6626      00
1419:main.c        **** 					fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &first_ack1_received[0], &error);
 6627              		.loc 1 1419 0
 6628 517d 8B85C8F2 		movl	-3384(%rbp), %eax
 6628      FFFF
 6629 5183 01C0     		addl	%eax, %eax
 6630 5185 0FB6F0   		movzbl	%al, %esi
 6631 5188 488B85E0 		movq	-3104(%rbp), %rax
 6631      F3FFFF
 6632 518f 488D8DE8 		leaq	-3096(%rbp), %rcx
 6632      F3FFFF
 6633 5196 488D5580 		leaq	-128(%rbp), %rdx
 6634 519a 4989C8   		movq	%rcx, %r8
 6635 519d 4889D1   		movq	%rdx, %rcx
 6636 51a0 BA010000 		movl	$1, %edx
 6636      00
 6637 51a5 4889C7   		movq	%rax, %rdi
 6638 51a8 E8000000 		call	flReadChannelAsyncSubmit
 6638      00
 6639 51ad 8985BCF2 		movl	%eax, -3396(%rbp)
 6639      FFFF
1420:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6640              		.loc 1 1420 0
 6641 51b3 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6641      FFFF00
 6642 51ba 740F     		je	.L325
 6643              		.loc 1 1420 0 is_stmt 0 discriminator 1
 6644 51bc C785B8F2 		movl	$1, -3400(%rbp)
 6644      FFFF0100 
 6644      0000
 6645 51c6 E9552C00 		jmp	.L230
 6645      00
 6646              	.L325:
1421:main.c        **** 					fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 6647              		.loc 1 1421 0 is_stmt 1
 6648 51cb 488B85E0 		movq	-3104(%rbp), %rax
 6648      F3FFFF
 6649 51d2 488DBDE8 		leaq	-3096(%rbp), %rdi
 6649      F3FFFF
 6650 51d9 488D8DB4 		leaq	-3404(%rbp), %rcx
 6650      F2FFFF
 6651 51e0 488D95B4 		leaq	-3404(%rbp), %rdx
 6651      F2FFFF
 6652 51e7 488DB5F0 		leaq	-3088(%rbp), %rsi
 6652      F3FFFF
 6653 51ee 4989F8   		movq	%rdi, %r8
 6654 51f1 4889C7   		movq	%rax, %rdi
 6655 51f4 E8000000 		call	flReadChannelAsyncAwait
 6655      00
 6656 51f9 8985BCF2 		movl	%eax, -3396(%rbp)
 6656      FFFF
1422:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6657              		.loc 1 1422 0
 6658 51ff 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6658      FFFF00
 6659 5206 740F     		je	.L326
 6660              		.loc 1 1422 0 is_stmt 0 discriminator 1
 6661 5208 C785B8F2 		movl	$1, -3400(%rbp)
 6661      FFFF0100 
 6661      0000
 6662 5212 E9092C00 		jmp	.L230
 6662      00
 6663              	.L326:
1423:main.c        **** 					if(first_ack1_received[0] == reset) 
 6664              		.loc 1 1423 0 is_stmt 1
 6665 5217 0FB64580 		movzbl	-128(%rbp), %eax
 6666 521b 3A85AFF2 		cmpb	-3409(%rbp), %al
 6666      FFFF
 6667 5221 7516     		jne	.L327
1424:main.c        **** 						{
1425:main.c        **** 							k--;
 6668              		.loc 1 1425 0
 6669 5223 83ADC8F2 		subl	$1, -3384(%rbp)
 6669      FFFF01
1426:main.c        **** 							printf("%s\n", "-------------------------RESET------------------------");							 
 6670              		.loc 1 1426 0
 6671 522a BF000000 		movl	$.LC155, %edi
 6671      00
 6672 522f E8000000 		call	puts
 6672      00
1427:main.c        **** 							continue;
 6673              		.loc 1 1427 0
 6674 5234 E9792B00 		jmp	.L305
 6674      00
 6675              	.L327:
1428:main.c        **** 						}
1429:main.c        **** 					delay(del);
 6676              		.loc 1 1429 0
 6677 5239 8B85B0F3 		movl	-3152(%rbp), %eax
 6677      FFFF
 6678 523f 89C7     		movl	%eax, %edi
 6679 5241 E8000000 		call	delay
 6679      00
1430:main.c        **** 					fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &first_ack1_received[1], &error);
 6680              		.loc 1 1430 0
 6681 5246 8B85C8F2 		movl	-3384(%rbp), %eax
 6681      FFFF
 6682 524c 01C0     		addl	%eax, %eax
 6683 524e 0FB6F0   		movzbl	%al, %esi
 6684 5251 488B85E0 		movq	-3104(%rbp), %rax
 6684      F3FFFF
 6685 5258 488D8DE8 		leaq	-3096(%rbp), %rcx
 6685      F3FFFF
 6686 525f 488D5580 		leaq	-128(%rbp), %rdx
 6687 5263 4883C201 		addq	$1, %rdx
 6688 5267 4989C8   		movq	%rcx, %r8
 6689 526a 4889D1   		movq	%rdx, %rcx
 6690 526d BA010000 		movl	$1, %edx
 6690      00
 6691 5272 4889C7   		movq	%rax, %rdi
 6692 5275 E8000000 		call	flReadChannelAsyncSubmit
 6692      00
 6693 527a 8985BCF2 		movl	%eax, -3396(%rbp)
 6693      FFFF
1431:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6694              		.loc 1 1431 0
 6695 5280 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6695      FFFF00
 6696 5287 740F     		je	.L328
 6697              		.loc 1 1431 0 is_stmt 0 discriminator 1
 6698 5289 C785B8F2 		movl	$1, -3400(%rbp)
 6698      FFFF0100 
 6698      0000
 6699 5293 E9882B00 		jmp	.L230
 6699      00
 6700              	.L328:
1432:main.c        **** 					fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 6701              		.loc 1 1432 0 is_stmt 1
 6702 5298 488B85E0 		movq	-3104(%rbp), %rax
 6702      F3FFFF
 6703 529f 488DBDE8 		leaq	-3096(%rbp), %rdi
 6703      F3FFFF
 6704 52a6 488D8DB4 		leaq	-3404(%rbp), %rcx
 6704      F2FFFF
 6705 52ad 488D95B4 		leaq	-3404(%rbp), %rdx
 6705      F2FFFF
 6706 52b4 488DB5F0 		leaq	-3088(%rbp), %rsi
 6706      F3FFFF
 6707 52bb 4989F8   		movq	%rdi, %r8
 6708 52be 4889C7   		movq	%rax, %rdi
 6709 52c1 E8000000 		call	flReadChannelAsyncAwait
 6709      00
 6710 52c6 8985BCF2 		movl	%eax, -3396(%rbp)
 6710      FFFF
1433:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6711              		.loc 1 1433 0
 6712 52cc 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6712      FFFF00
 6713 52d3 740F     		je	.L329
 6714              		.loc 1 1433 0 is_stmt 0 discriminator 1
 6715 52d5 C785B8F2 		movl	$1, -3400(%rbp)
 6715      FFFF0100 
 6715      0000
 6716 52df E93C2B00 		jmp	.L230
 6716      00
 6717              	.L329:
1434:main.c        **** 					if(first_ack1_received[1] == reset) 
 6718              		.loc 1 1434 0 is_stmt 1
 6719 52e4 0FB64581 		movzbl	-127(%rbp), %eax
 6720 52e8 3A85AFF2 		cmpb	-3409(%rbp), %al
 6720      FFFF
 6721 52ee 7516     		jne	.L330
1435:main.c        **** 						{
1436:main.c        **** 							k--; 
 6722              		.loc 1 1436 0
 6723 52f0 83ADC8F2 		subl	$1, -3384(%rbp)
 6723      FFFF01
1437:main.c        **** 							printf("%s\n", "-------------------------RESET------------------------");
 6724              		.loc 1 1437 0
 6725 52f7 BF000000 		movl	$.LC155, %edi
 6725      00
 6726 52fc E8000000 		call	puts
 6726      00
1438:main.c        **** 							continue;
 6727              		.loc 1 1438 0
 6728 5301 E9AC2A00 		jmp	.L305
 6728      00
 6729              	.L330:
1439:main.c        **** 						}
1440:main.c        **** 					delay(del);
 6730              		.loc 1 1440 0
 6731 5306 8B85B0F3 		movl	-3152(%rbp), %eax
 6731      FFFF
 6732 530c 89C7     		movl	%eax, %edi
 6733 530e E8000000 		call	delay
 6733      00
1441:main.c        **** 					fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &first_ack1_received[2], &error);
 6734              		.loc 1 1441 0
 6735 5313 8B85C8F2 		movl	-3384(%rbp), %eax
 6735      FFFF
 6736 5319 01C0     		addl	%eax, %eax
 6737 531b 0FB6F0   		movzbl	%al, %esi
 6738 531e 488B85E0 		movq	-3104(%rbp), %rax
 6738      F3FFFF
 6739 5325 488D8DE8 		leaq	-3096(%rbp), %rcx
 6739      F3FFFF
 6740 532c 488D5580 		leaq	-128(%rbp), %rdx
 6741 5330 4883C202 		addq	$2, %rdx
 6742 5334 4989C8   		movq	%rcx, %r8
 6743 5337 4889D1   		movq	%rdx, %rcx
 6744 533a BA010000 		movl	$1, %edx
 6744      00
 6745 533f 4889C7   		movq	%rax, %rdi
 6746 5342 E8000000 		call	flReadChannelAsyncSubmit
 6746      00
 6747 5347 8985BCF2 		movl	%eax, -3396(%rbp)
 6747      FFFF
1442:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6748              		.loc 1 1442 0
 6749 534d 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6749      FFFF00
 6750 5354 740F     		je	.L331
 6751              		.loc 1 1442 0 is_stmt 0 discriminator 1
 6752 5356 C785B8F2 		movl	$1, -3400(%rbp)
 6752      FFFF0100 
 6752      0000
 6753 5360 E9BB2A00 		jmp	.L230
 6753      00
 6754              	.L331:
1443:main.c        **** 					fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 6755              		.loc 1 1443 0 is_stmt 1
 6756 5365 488B85E0 		movq	-3104(%rbp), %rax
 6756      F3FFFF
 6757 536c 488DBDE8 		leaq	-3096(%rbp), %rdi
 6757      F3FFFF
 6758 5373 488D8DB4 		leaq	-3404(%rbp), %rcx
 6758      F2FFFF
 6759 537a 488D95B4 		leaq	-3404(%rbp), %rdx
 6759      F2FFFF
 6760 5381 488DB5F0 		leaq	-3088(%rbp), %rsi
 6760      F3FFFF
 6761 5388 4989F8   		movq	%rdi, %r8
 6762 538b 4889C7   		movq	%rax, %rdi
 6763 538e E8000000 		call	flReadChannelAsyncAwait
 6763      00
 6764 5393 8985BCF2 		movl	%eax, -3396(%rbp)
 6764      FFFF
1444:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6765              		.loc 1 1444 0
 6766 5399 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6766      FFFF00
 6767 53a0 740F     		je	.L332
 6768              		.loc 1 1444 0 is_stmt 0 discriminator 1
 6769 53a2 C785B8F2 		movl	$1, -3400(%rbp)
 6769      FFFF0100 
 6769      0000
 6770 53ac E96F2A00 		jmp	.L230
 6770      00
 6771              	.L332:
1445:main.c        **** 					if(first_ack1_received[2] == reset) 
 6772              		.loc 1 1445 0 is_stmt 1
 6773 53b1 0FB64582 		movzbl	-126(%rbp), %eax
 6774 53b5 3A85AFF2 		cmpb	-3409(%rbp), %al
 6774      FFFF
 6775 53bb 7516     		jne	.L333
1446:main.c        **** 						{
1447:main.c        **** 							k--; 
 6776              		.loc 1 1447 0
 6777 53bd 83ADC8F2 		subl	$1, -3384(%rbp)
 6777      FFFF01
1448:main.c        **** 							printf("%s\n", "-------------------------RESET------------------------");
 6778              		.loc 1 1448 0
 6779 53c4 BF000000 		movl	$.LC155, %edi
 6779      00
 6780 53c9 E8000000 		call	puts
 6780      00
1449:main.c        **** 							continue;
 6781              		.loc 1 1449 0
 6782 53ce E9DF2900 		jmp	.L305
 6782      00
 6783              	.L333:
1450:main.c        **** 						}
1451:main.c        **** 					delay(del);
 6784              		.loc 1 1451 0
 6785 53d3 8B85B0F3 		movl	-3152(%rbp), %eax
 6785      FFFF
 6786 53d9 89C7     		movl	%eax, %edi
 6787 53db E8000000 		call	delay
 6787      00
1452:main.c        **** 					fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &first_ack1_received[3], &error);
 6788              		.loc 1 1452 0
 6789 53e0 8B85C8F2 		movl	-3384(%rbp), %eax
 6789      FFFF
 6790 53e6 01C0     		addl	%eax, %eax
 6791 53e8 0FB6F0   		movzbl	%al, %esi
 6792 53eb 488B85E0 		movq	-3104(%rbp), %rax
 6792      F3FFFF
 6793 53f2 488D8DE8 		leaq	-3096(%rbp), %rcx
 6793      F3FFFF
 6794 53f9 488D5580 		leaq	-128(%rbp), %rdx
 6795 53fd 4883C203 		addq	$3, %rdx
 6796 5401 4989C8   		movq	%rcx, %r8
 6797 5404 4889D1   		movq	%rdx, %rcx
 6798 5407 BA010000 		movl	$1, %edx
 6798      00
 6799 540c 4889C7   		movq	%rax, %rdi
 6800 540f E8000000 		call	flReadChannelAsyncSubmit
 6800      00
 6801 5414 8985BCF2 		movl	%eax, -3396(%rbp)
 6801      FFFF
1453:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6802              		.loc 1 1453 0
 6803 541a 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6803      FFFF00
 6804 5421 740F     		je	.L334
 6805              		.loc 1 1453 0 is_stmt 0 discriminator 1
 6806 5423 C785B8F2 		movl	$1, -3400(%rbp)
 6806      FFFF0100 
 6806      0000
 6807 542d E9EE2900 		jmp	.L230
 6807      00
 6808              	.L334:
1454:main.c        **** 					fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 6809              		.loc 1 1454 0 is_stmt 1
 6810 5432 488B85E0 		movq	-3104(%rbp), %rax
 6810      F3FFFF
 6811 5439 488DBDE8 		leaq	-3096(%rbp), %rdi
 6811      F3FFFF
 6812 5440 488D8DB4 		leaq	-3404(%rbp), %rcx
 6812      F2FFFF
 6813 5447 488D95B4 		leaq	-3404(%rbp), %rdx
 6813      F2FFFF
 6814 544e 488DB5F0 		leaq	-3088(%rbp), %rsi
 6814      F3FFFF
 6815 5455 4989F8   		movq	%rdi, %r8
 6816 5458 4889C7   		movq	%rax, %rdi
 6817 545b E8000000 		call	flReadChannelAsyncAwait
 6817      00
 6818 5460 8985BCF2 		movl	%eax, -3396(%rbp)
 6818      FFFF
1455:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 6819              		.loc 1 1455 0
 6820 5466 83BDBCF2 		cmpl	$0, -3396(%rbp)
 6820      FFFF00
 6821 546d 740F     		je	.L335
 6822              		.loc 1 1455 0 is_stmt 0 discriminator 1
 6823 546f C785B8F2 		movl	$1, -3400(%rbp)
 6823      FFFF0100 
 6823      0000
 6824 5479 E9A22900 		jmp	.L230
 6824      00
 6825              	.L335:
1456:main.c        **** 					if(first_ack1_received[3] == reset) 
 6826              		.loc 1 1456 0 is_stmt 1
 6827 547e 0FB64583 		movzbl	-125(%rbp), %eax
 6828 5482 3A85AFF2 		cmpb	-3409(%rbp), %al
 6828      FFFF
 6829 5488 7516     		jne	.L336
1457:main.c        **** 						{
1458:main.c        **** 							k--; 
 6830              		.loc 1 1458 0
 6831 548a 83ADC8F2 		subl	$1, -3384(%rbp)
 6831      FFFF01
1459:main.c        **** 							printf("%s\n", "-------------------------RESET------------------------");
 6832              		.loc 1 1459 0
 6833 5491 BF000000 		movl	$.LC155, %edi
 6833      00
 6834 5496 E8000000 		call	puts
 6834      00
1460:main.c        **** 							continue;
 6835              		.loc 1 1460 0
 6836 549b E9122900 		jmp	.L305
 6836      00
 6837              	.L336:
1461:main.c        **** 						}
1462:main.c        **** 					printf("%s\n", "First ack1 received successfully");
 6838              		.loc 1 1462 0
 6839 54a0 BF000000 		movl	$.LC170, %edi
 6839      00
 6840 54a5 E8000000 		call	puts
 6840      00
1463:main.c        **** 					printf("%s\n", "The first ack1 is ----- in uint8 form");
 6841              		.loc 1 1463 0
 6842 54aa BF000000 		movl	$.LC171, %edi
 6842      00
 6843 54af E8000000 		call	puts
 6843      00
 6844              	.LBB58:
1464:main.c        **** 					for (int i = 0; i < 4; ++i)
 6845              		.loc 1 1464 0
 6846 54b4 C785DCF2 		movl	$0, -3364(%rbp)
 6846      FFFF0000 
 6846      0000
 6847 54be EB28     		jmp	.L337
 6848              	.L338:
1465:main.c        **** 					{
1466:main.c        **** 						printf("%d ", first_ack1_received[i]);
 6849              		.loc 1 1466 0 discriminator 3
 6850 54c0 8B85DCF2 		movl	-3364(%rbp), %eax
 6850      FFFF
 6851 54c6 4898     		cltq
 6852 54c8 0FB64405 		movzbl	-128(%rbp,%rax), %eax
 6852      80
 6853 54cd 0FB6C0   		movzbl	%al, %eax
 6854 54d0 89C6     		movl	%eax, %esi
 6855 54d2 BF000000 		movl	$.LC10, %edi
 6855      00
 6856 54d7 B8000000 		movl	$0, %eax
 6856      00
 6857 54dc E8000000 		call	printf
 6857      00
1464:main.c        **** 					for (int i = 0; i < 4; ++i)
 6858              		.loc 1 1464 0 discriminator 3
 6859 54e1 8385DCF2 		addl	$1, -3364(%rbp)
 6859      FFFF01
 6860              	.L337:
1464:main.c        **** 					for (int i = 0; i < 4; ++i)
 6861              		.loc 1 1464 0 is_stmt 0 discriminator 1
 6862 54e8 83BDDCF2 		cmpl	$3, -3364(%rbp)
 6862      FFFF03
 6863 54ef 7ECF     		jle	.L338
 6864              	.LBE58:
1467:main.c        **** 					}
1468:main.c        **** 					printf("\n");
 6865              		.loc 1 1468 0 is_stmt 1
 6866 54f1 BF0A0000 		movl	$10, %edi
 6866      00
 6867 54f6 E8000000 		call	putchar
 6867      00
1469:main.c        **** 					printf("%s\n", "----------------------H2.3 ended----------------------- ");
 6868              		.loc 1 1469 0
 6869 54fb BF000000 		movl	$.LC172, %edi
 6869      00
 6870 5500 E8000000 		call	puts
 6870      00
1470:main.c        **** 					printf("%s\n", "----------------------H2.4 started----------------------- ");
 6871              		.loc 1 1470 0
 6872 5505 BF000000 		movl	$.LC173, %edi
 6872      00
 6873 550a E8000000 		call	puts
 6873      00
1471:main.c        **** 					
1472:main.c        **** 					int encrpyted_ack1[32];
1473:main.c        **** 					printf("%s\n", "Converting encrypted ack1 from uint8 to binary");
 6874              		.loc 1 1473 0
 6875 550f BF000000 		movl	$.LC174, %edi
 6875      00
 6876 5514 E8000000 		call	puts
 6876      00
1474:main.c        **** 					uint8ToBin(first_ack1_received, encrpyted_ack1);
 6877              		.loc 1 1474 0
 6878 5519 488D95D0 		leaq	-1840(%rbp), %rdx
 6878      F8FFFF
 6879 5520 488D4580 		leaq	-128(%rbp), %rax
 6880 5524 4889D6   		movq	%rdx, %rsi
 6881 5527 4889C7   		movq	%rax, %rdi
 6882 552a E8000000 		call	uint8ToBin
 6882      00
1475:main.c        **** 					printf("%s\n", "The encrypted ack1 is as follows in binary form --");
 6883              		.loc 1 1475 0
 6884 552f BF000000 		movl	$.LC175, %edi
 6884      00
 6885 5534 E8000000 		call	puts
 6885      00
 6886              	.LBB59:
1476:main.c        **** 					for (int i = 0; i < 32; ++i)
 6887              		.loc 1 1476 0
 6888 5539 C785E0F2 		movl	$0, -3360(%rbp)
 6888      FFFF0000 
 6888      0000
 6889 5543 EB27     		jmp	.L339
 6890              	.L340:
1477:main.c        **** 					{
1478:main.c        **** 						printf("%d ", encrpyted_ack1[i]);
 6891              		.loc 1 1478 0 discriminator 3
 6892 5545 8B85E0F2 		movl	-3360(%rbp), %eax
 6892      FFFF
 6893 554b 4898     		cltq
 6894 554d 8B8485D0 		movl	-1840(%rbp,%rax,4), %eax
 6894      F8FFFF
 6895 5554 89C6     		movl	%eax, %esi
 6896 5556 BF000000 		movl	$.LC10, %edi
 6896      00
 6897 555b B8000000 		movl	$0, %eax
 6897      00
 6898 5560 E8000000 		call	printf
 6898      00
1476:main.c        **** 					for (int i = 0; i < 32; ++i)
 6899              		.loc 1 1476 0 discriminator 3
 6900 5565 8385E0F2 		addl	$1, -3360(%rbp)
 6900      FFFF01
 6901              	.L339:
1476:main.c        **** 					for (int i = 0; i < 32; ++i)
 6902              		.loc 1 1476 0 is_stmt 0 discriminator 1
 6903 556c 83BDE0F2 		cmpl	$31, -3360(%rbp)
 6903      FFFF1F
 6904 5573 7ED0     		jle	.L340
 6905              	.LBE59:
1479:main.c        **** 					}
1480:main.c        **** 					printf("\n");
 6906              		.loc 1 1480 0 is_stmt 1
 6907 5575 BF0A0000 		movl	$10, %edi
 6907      00
 6908 557a E8000000 		call	putchar
 6908      00
1481:main.c        **** 					int decrypted_ack1[32];
1482:main.c        **** 					decrypter(encrpyted_ack1, K, decrypted_ack1);
 6909              		.loc 1 1482 0
 6910 557f 488D9550 		leaq	-1712(%rbp), %rdx
 6910      F9FFFF
 6911 5586 488D8DD0 		leaq	-2608(%rbp), %rcx
 6911      F5FFFF
 6912 558d 488D85D0 		leaq	-1840(%rbp), %rax
 6912      F8FFFF
 6913 5594 4889CE   		movq	%rcx, %rsi
 6914 5597 4889C7   		movq	%rax, %rdi
 6915 559a E8000000 		call	decrypter
 6915      00
1483:main.c        **** 					printf("%s\n", "The decrypted ack1 in binary is as follows --");
 6916              		.loc 1 1483 0
 6917 559f BF000000 		movl	$.LC176, %edi
 6917      00
 6918 55a4 E8000000 		call	puts
 6918      00
 6919              	.LBB60:
1484:main.c        **** 					for (int i = 0; i < 32; ++i)
 6920              		.loc 1 1484 0
 6921 55a9 C785E4F2 		movl	$0, -3356(%rbp)
 6921      FFFF0000 
 6921      0000
 6922 55b3 EB27     		jmp	.L341
 6923              	.L342:
1485:main.c        **** 					{
1486:main.c        **** 						printf("%d ", decrypted_ack1[i]);
 6924              		.loc 1 1486 0 discriminator 3
 6925 55b5 8B85E4F2 		movl	-3356(%rbp), %eax
 6925      FFFF
 6926 55bb 4898     		cltq
 6927 55bd 8B848550 		movl	-1712(%rbp,%rax,4), %eax
 6927      F9FFFF
 6928 55c4 89C6     		movl	%eax, %esi
 6929 55c6 BF000000 		movl	$.LC10, %edi
 6929      00
 6930 55cb B8000000 		movl	$0, %eax
 6930      00
 6931 55d0 E8000000 		call	printf
 6931      00
1484:main.c        **** 					for (int i = 0; i < 32; ++i)
 6932              		.loc 1 1484 0 discriminator 3
 6933 55d5 8385E4F2 		addl	$1, -3356(%rbp)
 6933      FFFF01
 6934              	.L341:
1484:main.c        **** 					for (int i = 0; i < 32; ++i)
 6935              		.loc 1 1484 0 is_stmt 0 discriminator 1
 6936 55dc 83BDE4F2 		cmpl	$31, -3356(%rbp)
 6936      FFFF1F
 6937 55e3 7ED0     		jle	.L342
 6938              	.LBE60:
1487:main.c        **** 					}
1488:main.c        **** 					printf("\n");
 6939              		.loc 1 1488 0 is_stmt 1
 6940 55e5 BF0A0000 		movl	$10, %edi
 6940      00
 6941 55ea E8000000 		call	putchar
 6941      00
1489:main.c        **** 					printf("%s\n", "Checking if this ack1 is equal to the original ack1 ");
 6942              		.loc 1 1489 0
 6943 55ef BF000000 		movl	$.LC177, %edi
 6943      00
 6944 55f4 E8000000 		call	puts
 6944      00
1490:main.c        **** 
1491:main.c        **** 					int ack_helper = 0;
 6945              		.loc 1 1491 0
 6946 55f9 C785E8F2 		movl	$0, -3352(%rbp)
 6946      FFFF0000 
 6946      0000
 6947              	.LBB61:
1492:main.c        **** 					for(int i=0; i<32; i++)
 6948              		.loc 1 1492 0
 6949 5603 C785ECF2 		movl	$0, -3348(%rbp)
 6949      FFFF0000 
 6949      0000
 6950 560d EB33     		jmp	.L343
 6951              	.L345:
1493:main.c        **** 					{
1494:main.c        **** 						if(decrypted_ack1[i] != ack1[i])
 6952              		.loc 1 1494 0
 6953 560f 8B85ECF2 		movl	-3348(%rbp), %eax
 6953      FFFF
 6954 5615 4898     		cltq
 6955 5617 8B948550 		movl	-1712(%rbp,%rax,4), %edx
 6955      F9FFFF
 6956 561e 8B85ECF2 		movl	-3348(%rbp), %eax
 6956      FFFF
 6957 5624 4898     		cltq
 6958 5626 8B848550 		movl	-2480(%rbp,%rax,4), %eax
 6958      F6FFFF
 6959 562d 39C2     		cmpl	%eax, %edx
 6960 562f 740A     		je	.L344
1495:main.c        **** 						{
1496:main.c        **** 							ack_helper = 1;
 6961              		.loc 1 1496 0
 6962 5631 C785E8F2 		movl	$1, -3352(%rbp)
 6962      FFFF0100 
 6962      0000
 6963              	.L344:
1492:main.c        **** 					{
 6964              		.loc 1 1492 0 discriminator 2
 6965 563b 8385ECF2 		addl	$1, -3348(%rbp)
 6965      FFFF01
 6966              	.L343:
1492:main.c        **** 					{
 6967              		.loc 1 1492 0 is_stmt 0 discriminator 1
 6968 5642 83BDECF2 		cmpl	$31, -3348(%rbp)
 6968      FFFF1F
 6969 5649 7EC4     		jle	.L345
 6970              	.LBE61:
1497:main.c        **** 						}
1498:main.c        **** 					}
1499:main.c        **** 
1500:main.c        **** 					if(ack_helper == 1)
 6971              		.loc 1 1500 0 is_stmt 1
 6972 564b 83BDE8F2 		cmpl	$1, -3352(%rbp)
 6972      FFFF01
 6973 5652 0F85F104 		jne	.L346
 6973      0000
 6974              	.LBB62:
1501:main.c        **** 					{
1502:main.c        **** 						printf("%s\n", "Ack1 received doesn't match with the original one");
 6975              		.loc 1 1502 0
 6976 5658 BF000000 		movl	$.LC178, %edi
 6976      00
 6977 565d E8000000 		call	puts
 6977      00
1503:main.c        **** 						uint8 encrypted_ack1_again[4];
1504:main.c        **** 						delay(1000000);
 6978              		.loc 1 1504 0
 6979 5662 BF40420F 		movl	$1000000, %edi
 6979      00
 6980 5667 E8000000 		call	delay
 6980      00
1505:main.c        **** 						printf("%s\n", "Reading the channel 2i again ");
 6981              		.loc 1 1505 0
 6982 566c BF000000 		movl	$.LC179, %edi
 6982      00
 6983 5671 E8000000 		call	puts
 6983      00
1506:main.c        **** 						delay(del);
 6984              		.loc 1 1506 0
 6985 5676 8B85B0F3 		movl	-3152(%rbp), %eax
 6985      FFFF
 6986 567c 89C7     		movl	%eax, %edi
 6987 567e E8000000 		call	delay
 6987      00
1507:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again[0], &error);
 6988              		.loc 1 1507 0
 6989 5683 8B85C8F2 		movl	-3384(%rbp), %eax
 6989      FFFF
 6990 5689 01C0     		addl	%eax, %eax
 6991 568b 0FB6F0   		movzbl	%al, %esi
 6992 568e 488B85E0 		movq	-3104(%rbp), %rax
 6992      F3FFFF
 6993 5695 488D8DE8 		leaq	-3096(%rbp), %rcx
 6993      F3FFFF
 6994 569c 488D55D0 		leaq	-48(%rbp), %rdx
 6995 56a0 4989C8   		movq	%rcx, %r8
 6996 56a3 4889D1   		movq	%rdx, %rcx
 6997 56a6 BA010000 		movl	$1, %edx
 6997      00
 6998 56ab 4889C7   		movq	%rax, %rdi
 6999 56ae E8000000 		call	flReadChannelAsyncSubmit
 6999      00
 7000 56b3 8985BCF2 		movl	%eax, -3396(%rbp)
 7000      FFFF
1508:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7001              		.loc 1 1508 0
 7002 56b9 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7002      FFFF00
 7003 56c0 740F     		je	.L347
 7004              		.loc 1 1508 0 is_stmt 0 discriminator 1
 7005 56c2 C785B8F2 		movl	$1, -3400(%rbp)
 7005      FFFF0100 
 7005      0000
 7006 56cc E94F2700 		jmp	.L230
 7006      00
 7007              	.L347:
1509:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 7008              		.loc 1 1509 0 is_stmt 1
 7009 56d1 488B85E0 		movq	-3104(%rbp), %rax
 7009      F3FFFF
 7010 56d8 488DBDE8 		leaq	-3096(%rbp), %rdi
 7010      F3FFFF
 7011 56df 488D8DB4 		leaq	-3404(%rbp), %rcx
 7011      F2FFFF
 7012 56e6 488D95B4 		leaq	-3404(%rbp), %rdx
 7012      F2FFFF
 7013 56ed 488DB5F0 		leaq	-3088(%rbp), %rsi
 7013      F3FFFF
 7014 56f4 4989F8   		movq	%rdi, %r8
 7015 56f7 4889C7   		movq	%rax, %rdi
 7016 56fa E8000000 		call	flReadChannelAsyncAwait
 7016      00
 7017 56ff 8985BCF2 		movl	%eax, -3396(%rbp)
 7017      FFFF
1510:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7018              		.loc 1 1510 0
 7019 5705 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7019      FFFF00
 7020 570c 740F     		je	.L349
 7021              		.loc 1 1510 0 is_stmt 0 discriminator 1
 7022 570e C785B8F2 		movl	$1, -3400(%rbp)
 7022      FFFF0100 
 7022      0000
 7023 5718 E9270400 		jmp	.L348
 7023      00
 7024              	.L349:
1511:main.c        **** 						if(encrypted_ack1_again[0] == reset) 
 7025              		.loc 1 1511 0 is_stmt 1
 7026 571d 0FB645D0 		movzbl	-48(%rbp), %eax
 7027 5721 3A85AFF2 		cmpb	-3409(%rbp), %al
 7027      FFFF
 7028 5727 7516     		jne	.L350
1512:main.c        **** 							{
1513:main.c        **** 								k--; 
 7029              		.loc 1 1513 0
 7030 5729 83ADC8F2 		subl	$1, -3384(%rbp)
 7030      FFFF01
1514:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 7031              		.loc 1 1514 0
 7032 5730 BF000000 		movl	$.LC155, %edi
 7032      00
 7033 5735 E8000000 		call	puts
 7033      00
1515:main.c        **** 								continue;
 7034              		.loc 1 1515 0
 7035 573a E9732600 		jmp	.L305
 7035      00
 7036              	.L350:
1516:main.c        **** 							}
1517:main.c        **** 						delay(del);
 7037              		.loc 1 1517 0
 7038 573f 8B85B0F3 		movl	-3152(%rbp), %eax
 7038      FFFF
 7039 5745 89C7     		movl	%eax, %edi
 7040 5747 E8000000 		call	delay
 7040      00
1518:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again[1], &error);
 7041              		.loc 1 1518 0
 7042 574c 8B85C8F2 		movl	-3384(%rbp), %eax
 7042      FFFF
 7043 5752 01C0     		addl	%eax, %eax
 7044 5754 0FB6F0   		movzbl	%al, %esi
 7045 5757 488B85E0 		movq	-3104(%rbp), %rax
 7045      F3FFFF
 7046 575e 488D8DE8 		leaq	-3096(%rbp), %rcx
 7046      F3FFFF
 7047 5765 488D55D0 		leaq	-48(%rbp), %rdx
 7048 5769 4883C201 		addq	$1, %rdx
 7049 576d 4989C8   		movq	%rcx, %r8
 7050 5770 4889D1   		movq	%rdx, %rcx
 7051 5773 BA010000 		movl	$1, %edx
 7051      00
 7052 5778 4889C7   		movq	%rax, %rdi
 7053 577b E8000000 		call	flReadChannelAsyncSubmit
 7053      00
 7054 5780 8985BCF2 		movl	%eax, -3396(%rbp)
 7054      FFFF
1519:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7055              		.loc 1 1519 0
 7056 5786 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7056      FFFF00
 7057 578d 740F     		je	.L352
 7058              		.loc 1 1519 0 is_stmt 0 discriminator 1
 7059 578f C785B8F2 		movl	$1, -3400(%rbp)
 7059      FFFF0100 
 7059      0000
 7060 5799 E9A60300 		jmp	.L348
 7060      00
 7061              	.L352:
1520:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 7062              		.loc 1 1520 0 is_stmt 1
 7063 579e 488B85E0 		movq	-3104(%rbp), %rax
 7063      F3FFFF
 7064 57a5 488DBDE8 		leaq	-3096(%rbp), %rdi
 7064      F3FFFF
 7065 57ac 488D8DB4 		leaq	-3404(%rbp), %rcx
 7065      F2FFFF
 7066 57b3 488D95B4 		leaq	-3404(%rbp), %rdx
 7066      F2FFFF
 7067 57ba 488DB5F0 		leaq	-3088(%rbp), %rsi
 7067      F3FFFF
 7068 57c1 4989F8   		movq	%rdi, %r8
 7069 57c4 4889C7   		movq	%rax, %rdi
 7070 57c7 E8000000 		call	flReadChannelAsyncAwait
 7070      00
 7071 57cc 8985BCF2 		movl	%eax, -3396(%rbp)
 7071      FFFF
1521:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7072              		.loc 1 1521 0
 7073 57d2 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7073      FFFF00
 7074 57d9 740F     		je	.L353
 7075              		.loc 1 1521 0 is_stmt 0 discriminator 1
 7076 57db C785B8F2 		movl	$1, -3400(%rbp)
 7076      FFFF0100 
 7076      0000
 7077 57e5 E95A0300 		jmp	.L348
 7077      00
 7078              	.L353:
1522:main.c        **** 						if(encrypted_ack1_again[1] == reset) 
 7079              		.loc 1 1522 0 is_stmt 1
 7080 57ea 0FB645D1 		movzbl	-47(%rbp), %eax
 7081 57ee 3A85AFF2 		cmpb	-3409(%rbp), %al
 7081      FFFF
 7082 57f4 7516     		jne	.L354
1523:main.c        **** 							{
1524:main.c        **** 								k--; 
 7083              		.loc 1 1524 0
 7084 57f6 83ADC8F2 		subl	$1, -3384(%rbp)
 7084      FFFF01
1525:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 7085              		.loc 1 1525 0
 7086 57fd BF000000 		movl	$.LC155, %edi
 7086      00
 7087 5802 E8000000 		call	puts
 7087      00
1526:main.c        **** 								continue;
 7088              		.loc 1 1526 0
 7089 5807 E9A62500 		jmp	.L305
 7089      00
 7090              	.L354:
1527:main.c        **** 							}
1528:main.c        **** 						delay(del);
 7091              		.loc 1 1528 0
 7092 580c 8B85B0F3 		movl	-3152(%rbp), %eax
 7092      FFFF
 7093 5812 89C7     		movl	%eax, %edi
 7094 5814 E8000000 		call	delay
 7094      00
1529:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again[2], &error);
 7095              		.loc 1 1529 0
 7096 5819 8B85C8F2 		movl	-3384(%rbp), %eax
 7096      FFFF
 7097 581f 01C0     		addl	%eax, %eax
 7098 5821 0FB6F0   		movzbl	%al, %esi
 7099 5824 488B85E0 		movq	-3104(%rbp), %rax
 7099      F3FFFF
 7100 582b 488D8DE8 		leaq	-3096(%rbp), %rcx
 7100      F3FFFF
 7101 5832 488D55D0 		leaq	-48(%rbp), %rdx
 7102 5836 4883C202 		addq	$2, %rdx
 7103 583a 4989C8   		movq	%rcx, %r8
 7104 583d 4889D1   		movq	%rdx, %rcx
 7105 5840 BA010000 		movl	$1, %edx
 7105      00
 7106 5845 4889C7   		movq	%rax, %rdi
 7107 5848 E8000000 		call	flReadChannelAsyncSubmit
 7107      00
 7108 584d 8985BCF2 		movl	%eax, -3396(%rbp)
 7108      FFFF
1530:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7109              		.loc 1 1530 0
 7110 5853 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7110      FFFF00
 7111 585a 740F     		je	.L355
 7112              		.loc 1 1530 0 is_stmt 0 discriminator 1
 7113 585c C785B8F2 		movl	$1, -3400(%rbp)
 7113      FFFF0100 
 7113      0000
 7114 5866 E9D90200 		jmp	.L348
 7114      00
 7115              	.L355:
1531:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 7116              		.loc 1 1531 0 is_stmt 1
 7117 586b 488B85E0 		movq	-3104(%rbp), %rax
 7117      F3FFFF
 7118 5872 488DBDE8 		leaq	-3096(%rbp), %rdi
 7118      F3FFFF
 7119 5879 488D8DB4 		leaq	-3404(%rbp), %rcx
 7119      F2FFFF
 7120 5880 488D95B4 		leaq	-3404(%rbp), %rdx
 7120      F2FFFF
 7121 5887 488DB5F0 		leaq	-3088(%rbp), %rsi
 7121      F3FFFF
 7122 588e 4989F8   		movq	%rdi, %r8
 7123 5891 4889C7   		movq	%rax, %rdi
 7124 5894 E8000000 		call	flReadChannelAsyncAwait
 7124      00
 7125 5899 8985BCF2 		movl	%eax, -3396(%rbp)
 7125      FFFF
1532:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7126              		.loc 1 1532 0
 7127 589f 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7127      FFFF00
 7128 58a6 740F     		je	.L356
 7129              		.loc 1 1532 0 is_stmt 0 discriminator 1
 7130 58a8 C785B8F2 		movl	$1, -3400(%rbp)
 7130      FFFF0100 
 7130      0000
 7131 58b2 E98D0200 		jmp	.L348
 7131      00
 7132              	.L356:
1533:main.c        **** 						if(encrypted_ack1_again[2] == reset) 
 7133              		.loc 1 1533 0 is_stmt 1
 7134 58b7 0FB645D2 		movzbl	-46(%rbp), %eax
 7135 58bb 3A85AFF2 		cmpb	-3409(%rbp), %al
 7135      FFFF
 7136 58c1 7516     		jne	.L357
1534:main.c        **** 							{
1535:main.c        **** 								k--; 
 7137              		.loc 1 1535 0
 7138 58c3 83ADC8F2 		subl	$1, -3384(%rbp)
 7138      FFFF01
1536:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 7139              		.loc 1 1536 0
 7140 58ca BF000000 		movl	$.LC155, %edi
 7140      00
 7141 58cf E8000000 		call	puts
 7141      00
1537:main.c        **** 								continue;
 7142              		.loc 1 1537 0
 7143 58d4 E9D92400 		jmp	.L305
 7143      00
 7144              	.L357:
1538:main.c        **** 							}
1539:main.c        **** 						delay(del);
 7145              		.loc 1 1539 0
 7146 58d9 8B85B0F3 		movl	-3152(%rbp), %eax
 7146      FFFF
 7147 58df 89C7     		movl	%eax, %edi
 7148 58e1 E8000000 		call	delay
 7148      00
1540:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again[3], &error);
 7149              		.loc 1 1540 0
 7150 58e6 8B85C8F2 		movl	-3384(%rbp), %eax
 7150      FFFF
 7151 58ec 01C0     		addl	%eax, %eax
 7152 58ee 0FB6F0   		movzbl	%al, %esi
 7153 58f1 488B85E0 		movq	-3104(%rbp), %rax
 7153      F3FFFF
 7154 58f8 488D8DE8 		leaq	-3096(%rbp), %rcx
 7154      F3FFFF
 7155 58ff 488D55D0 		leaq	-48(%rbp), %rdx
 7156 5903 4883C203 		addq	$3, %rdx
 7157 5907 4989C8   		movq	%rcx, %r8
 7158 590a 4889D1   		movq	%rdx, %rcx
 7159 590d BA010000 		movl	$1, %edx
 7159      00
 7160 5912 4889C7   		movq	%rax, %rdi
 7161 5915 E8000000 		call	flReadChannelAsyncSubmit
 7161      00
 7162 591a 8985BCF2 		movl	%eax, -3396(%rbp)
 7162      FFFF
1541:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7163              		.loc 1 1541 0
 7164 5920 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7164      FFFF00
 7165 5927 740F     		je	.L358
 7166              		.loc 1 1541 0 is_stmt 0 discriminator 1
 7167 5929 C785B8F2 		movl	$1, -3400(%rbp)
 7167      FFFF0100 
 7167      0000
 7168 5933 E90C0200 		jmp	.L348
 7168      00
 7169              	.L358:
1542:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 7170              		.loc 1 1542 0 is_stmt 1
 7171 5938 488B85E0 		movq	-3104(%rbp), %rax
 7171      F3FFFF
 7172 593f 488DBDE8 		leaq	-3096(%rbp), %rdi
 7172      F3FFFF
 7173 5946 488D8DB4 		leaq	-3404(%rbp), %rcx
 7173      F2FFFF
 7174 594d 488D95B4 		leaq	-3404(%rbp), %rdx
 7174      F2FFFF
 7175 5954 488DB5F0 		leaq	-3088(%rbp), %rsi
 7175      F3FFFF
 7176 595b 4989F8   		movq	%rdi, %r8
 7177 595e 4889C7   		movq	%rax, %rdi
 7178 5961 E8000000 		call	flReadChannelAsyncAwait
 7178      00
 7179 5966 8985BCF2 		movl	%eax, -3396(%rbp)
 7179      FFFF
1543:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7180              		.loc 1 1543 0
 7181 596c 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7181      FFFF00
 7182 5973 740F     		je	.L359
 7183              		.loc 1 1543 0 is_stmt 0 discriminator 1
 7184 5975 C785B8F2 		movl	$1, -3400(%rbp)
 7184      FFFF0100 
 7184      0000
 7185 597f E9C00100 		jmp	.L348
 7185      00
 7186              	.L359:
1544:main.c        **** 						if(encrypted_ack1_again[3] == reset) 
 7187              		.loc 1 1544 0 is_stmt 1
 7188 5984 0FB645D3 		movzbl	-45(%rbp), %eax
 7189 5988 3A85AFF2 		cmpb	-3409(%rbp), %al
 7189      FFFF
 7190 598e 7517     		jne	.L360
1545:main.c        **** 							{
1546:main.c        **** 								k--; 
 7191              		.loc 1 1546 0
 7192 5990 83ADC8F2 		subl	$1, -3384(%rbp)
 7192      FFFF01
1547:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 7193              		.loc 1 1547 0
 7194 5997 BF000000 		movl	$.LC155, %edi
 7194      00
 7195 599c E8000000 		call	puts
 7195      00
1548:main.c        **** 								continue;
 7196              		.loc 1 1548 0
 7197 59a1 90       		nop
 7198 59a2 E90B2400 		jmp	.L305
 7198      00
 7199              	.L360:
1549:main.c        **** 							}
1550:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7200              		.loc 1 1550 0
 7201 59a7 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7201      FFFF00
 7202 59ae 740F     		je	.L361
 7203              		.loc 1 1550 0 is_stmt 0 discriminator 1
 7204 59b0 C785B8F2 		movl	$1, -3400(%rbp)
 7204      FFFF0100 
 7204      0000
 7205 59ba E9850100 		jmp	.L348
 7205      00
 7206              	.L361:
1551:main.c        **** 						printf("%s\n", "Get the encrypted ack1 again successfully ---");
 7207              		.loc 1 1551 0 is_stmt 1
 7208 59bf BF000000 		movl	$.LC180, %edi
 7208      00
 7209 59c4 E8000000 		call	puts
 7209      00
 7210              	.LBB63:
1552:main.c        **** 						for (int i = 0; i < 4; ++i)
 7211              		.loc 1 1552 0
 7212 59c9 C785F0F2 		movl	$0, -3344(%rbp)
 7212      FFFF0000 
 7212      0000
 7213 59d3 EB28     		jmp	.L362
 7214              	.L363:
1553:main.c        **** 						{
1554:main.c        **** 							printf("%d ", encrypted_ack1_again[i]);
 7215              		.loc 1 1554 0 discriminator 3
 7216 59d5 8B85F0F2 		movl	-3344(%rbp), %eax
 7216      FFFF
 7217 59db 4898     		cltq
 7218 59dd 0FB64405 		movzbl	-48(%rbp,%rax), %eax
 7218      D0
 7219 59e2 0FB6C0   		movzbl	%al, %eax
 7220 59e5 89C6     		movl	%eax, %esi
 7221 59e7 BF000000 		movl	$.LC10, %edi
 7221      00
 7222 59ec B8000000 		movl	$0, %eax
 7222      00
 7223 59f1 E8000000 		call	printf
 7223      00
1552:main.c        **** 						for (int i = 0; i < 4; ++i)
 7224              		.loc 1 1552 0 discriminator 3
 7225 59f6 8385F0F2 		addl	$1, -3344(%rbp)
 7225      FFFF01
 7226              	.L362:
1552:main.c        **** 						for (int i = 0; i < 4; ++i)
 7227              		.loc 1 1552 0 is_stmt 0 discriminator 1
 7228 59fd 83BDF0F2 		cmpl	$3, -3344(%rbp)
 7228      FFFF03
 7229 5a04 7ECF     		jle	.L363
 7230              	.LBE63:
1555:main.c        **** 						}
1556:main.c        **** 						printf("\n");
 7231              		.loc 1 1556 0 is_stmt 1
 7232 5a06 BF0A0000 		movl	$10, %edi
 7232      00
 7233 5a0b E8000000 		call	putchar
 7233      00
1557:main.c        **** 						int encrypted_ack1_again1[32];
1558:main.c        **** 						printf("%s\n", "Converting encrypted ack1 from uint8 to binary");
 7234              		.loc 1 1558 0
 7235 5a10 BF000000 		movl	$.LC174, %edi
 7235      00
 7236 5a15 E8000000 		call	puts
 7236      00
1559:main.c        **** 						uint8ToBin(encrypted_ack1_again, encrypted_ack1_again1);
 7237              		.loc 1 1559 0
 7238 5a1a 488D9550 		leaq	-688(%rbp), %rdx
 7238      FDFFFF
 7239 5a21 488D45D0 		leaq	-48(%rbp), %rax
 7240 5a25 4889D6   		movq	%rdx, %rsi
 7241 5a28 4889C7   		movq	%rax, %rdi
 7242 5a2b E8000000 		call	uint8ToBin
 7242      00
1560:main.c        **** 						printf("%s\n", "Converted encrypted ack1 to binary and it is as ----");
 7243              		.loc 1 1560 0
 7244 5a30 BF000000 		movl	$.LC181, %edi
 7244      00
 7245 5a35 E8000000 		call	puts
 7245      00
 7246              	.LBB64:
1561:main.c        **** 						for (int i = 0; i < 32; ++i)
 7247              		.loc 1 1561 0
 7248 5a3a C785F4F2 		movl	$0, -3340(%rbp)
 7248      FFFF0000 
 7248      0000
 7249 5a44 EB27     		jmp	.L364
 7250              	.L365:
1562:main.c        **** 						{
1563:main.c        **** 							printf("%d ", encrypted_ack1_again1[i]);
 7251              		.loc 1 1563 0 discriminator 3
 7252 5a46 8B85F4F2 		movl	-3340(%rbp), %eax
 7252      FFFF
 7253 5a4c 4898     		cltq
 7254 5a4e 8B848550 		movl	-688(%rbp,%rax,4), %eax
 7254      FDFFFF
 7255 5a55 89C6     		movl	%eax, %esi
 7256 5a57 BF000000 		movl	$.LC10, %edi
 7256      00
 7257 5a5c B8000000 		movl	$0, %eax
 7257      00
 7258 5a61 E8000000 		call	printf
 7258      00
1561:main.c        **** 						for (int i = 0; i < 32; ++i)
 7259              		.loc 1 1561 0 discriminator 3
 7260 5a66 8385F4F2 		addl	$1, -3340(%rbp)
 7260      FFFF01
 7261              	.L364:
1561:main.c        **** 						for (int i = 0; i < 32; ++i)
 7262              		.loc 1 1561 0 is_stmt 0 discriminator 1
 7263 5a6d 83BDF4F2 		cmpl	$31, -3340(%rbp)
 7263      FFFF1F
 7264 5a74 7ED0     		jle	.L365
 7265              	.LBE64:
1564:main.c        **** 						}
1565:main.c        **** 						printf("\n");
 7266              		.loc 1 1565 0 is_stmt 1
 7267 5a76 BF0A0000 		movl	$10, %edi
 7267      00
 7268 5a7b E8000000 		call	putchar
 7268      00
1566:main.c        **** 						int decrypted_ack1_again1[32];
1567:main.c        **** 						printf("%s\n", "Decrypting the encrypted ack1 ");
 7269              		.loc 1 1567 0
 7270 5a80 BF000000 		movl	$.LC182, %edi
 7270      00
 7271 5a85 E8000000 		call	puts
 7271      00
1568:main.c        **** 						decrypter(encrypted_ack1_again1, K, decrypted_ack1_again1);
 7272              		.loc 1 1568 0
 7273 5a8a 488D9560 		leaq	-416(%rbp), %rdx
 7273      FEFFFF
 7274 5a91 488D8DD0 		leaq	-2608(%rbp), %rcx
 7274      F5FFFF
 7275 5a98 488D8550 		leaq	-688(%rbp), %rax
 7275      FDFFFF
 7276 5a9f 4889CE   		movq	%rcx, %rsi
 7277 5aa2 4889C7   		movq	%rax, %rdi
 7278 5aa5 E8000000 		call	decrypter
 7278      00
1569:main.c        **** 						printf("%s\n", "Ack1 got decrpyted and is as ----");
 7279              		.loc 1 1569 0
 7280 5aaa BF000000 		movl	$.LC183, %edi
 7280      00
 7281 5aaf E8000000 		call	puts
 7281      00
 7282              	.LBB65:
1570:main.c        **** 						for (int i = 0; i < 32; ++i)
 7283              		.loc 1 1570 0
 7284 5ab4 C785F8F2 		movl	$0, -3336(%rbp)
 7284      FFFF0000 
 7284      0000
 7285 5abe EB27     		jmp	.L366
 7286              	.L367:
1571:main.c        **** 						{
1572:main.c        **** 							printf("%d ", decrypted_ack1_again1[i]);
 7287              		.loc 1 1572 0 discriminator 3
 7288 5ac0 8B85F8F2 		movl	-3336(%rbp), %eax
 7288      FFFF
 7289 5ac6 4898     		cltq
 7290 5ac8 8B848560 		movl	-416(%rbp,%rax,4), %eax
 7290      FEFFFF
 7291 5acf 89C6     		movl	%eax, %esi
 7292 5ad1 BF000000 		movl	$.LC10, %edi
 7292      00
 7293 5ad6 B8000000 		movl	$0, %eax
 7293      00
 7294 5adb E8000000 		call	printf
 7294      00
1570:main.c        **** 						for (int i = 0; i < 32; ++i)
 7295              		.loc 1 1570 0 discriminator 3
 7296 5ae0 8385F8F2 		addl	$1, -3336(%rbp)
 7296      FFFF01
 7297              	.L366:
1570:main.c        **** 						for (int i = 0; i < 32; ++i)
 7298              		.loc 1 1570 0 is_stmt 0 discriminator 1
 7299 5ae7 83BDF8F2 		cmpl	$31, -3336(%rbp)
 7299      FFFF1F
 7300 5aee 7ED0     		jle	.L367
 7301              	.LBE65:
1573:main.c        **** 						}
1574:main.c        **** 						printf("\n");
 7302              		.loc 1 1574 0 is_stmt 1
 7303 5af0 BF0A0000 		movl	$10, %edi
 7303      00
 7304 5af5 E8000000 		call	putchar
 7304      00
 7305              	.LBB66:
1575:main.c        **** 						for(int i=0; i<32; i++)
 7306              		.loc 1 1575 0
 7307 5afa C785FCF2 		movl	$0, -3332(%rbp)
 7307      FFFF0000 
 7307      0000
 7308 5b04 EB33     		jmp	.L368
 7309              	.L370:
1576:main.c        **** 						{
1577:main.c        **** 							if(decrypted_ack1_again1[i] != ack1[i])
 7310              		.loc 1 1577 0
 7311 5b06 8B85FCF2 		movl	-3332(%rbp), %eax
 7311      FFFF
 7312 5b0c 4898     		cltq
 7313 5b0e 8B948560 		movl	-416(%rbp,%rax,4), %edx
 7313      FEFFFF
 7314 5b15 8B85FCF2 		movl	-3332(%rbp), %eax
 7314      FFFF
 7315 5b1b 4898     		cltq
 7316 5b1d 8B848550 		movl	-2480(%rbp,%rax,4), %eax
 7316      F6FFFF
 7317 5b24 39C2     		cmpl	%eax, %edx
 7318 5b26 740A     		je	.L369
1578:main.c        **** 							{
1579:main.c        **** 								ack_helper = 2;
 7319              		.loc 1 1579 0
 7320 5b28 C785E8F2 		movl	$2, -3352(%rbp)
 7320      FFFF0200 
 7320      0000
 7321              	.L369:
1575:main.c        **** 						{
 7322              		.loc 1 1575 0 discriminator 2
 7323 5b32 8385FCF2 		addl	$1, -3332(%rbp)
 7323      FFFF01
 7324              	.L368:
1575:main.c        **** 						{
 7325              		.loc 1 1575 0 is_stmt 0 discriminator 1
 7326 5b39 83BDFCF2 		cmpl	$31, -3332(%rbp)
 7326      FFFF1F
 7327 5b40 7EC4     		jle	.L370
 7328 5b42 EB05     		jmp	.L346
 7329              	.L348:
 7330              	.LBE66:
 7331              	.LBE62:
 7332              	.LBE53:
 7333              	.LBE52:
 7334              	.LBE51:
1294:main.c        **** 			fStatus = flIsFPGARunning(handle, &isRunning, &error);
 7335              		.loc 1 1294 0 is_stmt 1 discriminator 2
 7336 5b44 E9D72200 		jmp	.L230
 7336      00
 7337              	.L346:
 7338              	.LBB110:
 7339              	.LBB106:
 7340              	.LBB102:
1580:main.c        **** 							}
1581:main.c        **** 						}
1582:main.c        **** 
1583:main.c        **** 					}
1584:main.c        **** 
1585:main.c        **** 					printf("%s\n", "----------------------H2.4 ended----------------------- ");
 7341              		.loc 1 1585 0
 7342 5b49 BF000000 		movl	$.LC184, %edi
 7342      00
 7343 5b4e E8000000 		call	puts
 7343      00
1586:main.c        **** 
1587:main.c        **** 					printf("%s\n", "-------------------------H2.5 started-------------------------");
 7344              		.loc 1 1587 0
 7345 5b53 BF000000 		movl	$.LC185, %edi
 7345      00
 7346 5b58 E8000000 		call	puts
 7346      00
1588:main.c        **** 					
1589:main.c        **** 					if(ack_helper == 2)
 7347              		.loc 1 1589 0
 7348 5b5d 83BDE8F2 		cmpl	$2, -3352(%rbp)
 7348      FFFF02
 7349 5b64 7526     		jne	.L371
1590:main.c        **** 					{
1591:main.c        **** 						printf("%s\n", "Fails to receive encrypted ack1 ");
 7350              		.loc 1 1591 0
 7351 5b66 BF000000 		movl	$.LC186, %edi
 7351      00
 7352 5b6b E8000000 		call	puts
 7352      00
1592:main.c        **** 						if(k == 63)
 7353              		.loc 1 1592 0
 7354 5b70 83BDC8F2 		cmpl	$63, -3384(%rbp)
 7354      FFFF3F
 7355 5b77 0F852522 		jne	.L521
 7355      0000
1593:main.c        **** 						{
1594:main.c        **** 							k = 0;
 7356              		.loc 1 1594 0
 7357 5b7d C785C8F2 		movl	$0, -3384(%rbp)
 7357      FFFF0000 
 7357      0000
1595:main.c        **** 						}
1596:main.c        **** 						continue;
 7358              		.loc 1 1596 0
 7359 5b87 E9162200 		jmp	.L521
 7359      00
 7360              	.L371:
1597:main.c        **** 					}
1598:main.c        **** 
1599:main.c        **** 					printf("%s\n", "-------------------------H2.5 ended-------------------------");
 7361              		.loc 1 1599 0
 7362 5b8c BF000000 		movl	$.LC187, %edi
 7362      00
 7363 5b91 E8000000 		call	puts
 7363      00
1600:main.c        **** 
1601:main.c        **** 					printf("%s\n", "-------------------------H3 starts--------------------------");
 7364              		.loc 1 1601 0
 7365 5b96 BF000000 		movl	$.LC188, %edi
 7365      00
 7366 5b9b E8000000 		call	puts
 7366      00
1602:main.c        **** 
1603:main.c        **** 					int encrypted_ack2[32];
1604:main.c        **** 					printf("%s\n", "encrypting ack2 ");
 7367              		.loc 1 1604 0
 7368 5ba0 BF000000 		movl	$.LC189, %edi
 7368      00
 7369 5ba5 E8000000 		call	puts
 7369      00
1605:main.c        **** 					encrypter(ack2, K, encrypted_ack2);
 7370              		.loc 1 1605 0
 7371 5baa 488D95D0 		leaq	-1584(%rbp), %rdx
 7371      F9FFFF
 7372 5bb1 488D8DD0 		leaq	-2608(%rbp), %rcx
 7372      F5FFFF
 7373 5bb8 488D85D0 		leaq	-2352(%rbp), %rax
 7373      F6FFFF
 7374 5bbf 4889CE   		movq	%rcx, %rsi
 7375 5bc2 4889C7   		movq	%rax, %rdi
 7376 5bc5 E8000000 		call	encrypter
 7376      00
1606:main.c        **** 					printf("%s\n", "Ack2 got encrypted and it is as -----");
 7377              		.loc 1 1606 0
 7378 5bca BF000000 		movl	$.LC190, %edi
 7378      00
 7379 5bcf E8000000 		call	puts
 7379      00
 7380              	.LBB67:
1607:main.c        **** 					for (int i = 0; i < 32; ++i)
 7381              		.loc 1 1607 0
 7382 5bd4 C78500F3 		movl	$0, -3328(%rbp)
 7382      FFFF0000 
 7382      0000
 7383 5bde EB27     		jmp	.L373
 7384              	.L374:
1608:main.c        **** 					{
1609:main.c        **** 						printf("%d ", encrypted_ack2[i]);
 7385              		.loc 1 1609 0 discriminator 3
 7386 5be0 8B8500F3 		movl	-3328(%rbp), %eax
 7386      FFFF
 7387 5be6 4898     		cltq
 7388 5be8 8B8485D0 		movl	-1584(%rbp,%rax,4), %eax
 7388      F9FFFF
 7389 5bef 89C6     		movl	%eax, %esi
 7390 5bf1 BF000000 		movl	$.LC10, %edi
 7390      00
 7391 5bf6 B8000000 		movl	$0, %eax
 7391      00
 7392 5bfb E8000000 		call	printf
 7392      00
1607:main.c        **** 					for (int i = 0; i < 32; ++i)
 7393              		.loc 1 1607 0 discriminator 3
 7394 5c00 838500F3 		addl	$1, -3328(%rbp)
 7394      FFFF01
 7395              	.L373:
1607:main.c        **** 					for (int i = 0; i < 32; ++i)
 7396              		.loc 1 1607 0 is_stmt 0 discriminator 1
 7397 5c07 83BD00F3 		cmpl	$31, -3328(%rbp)
 7397      FFFF1F
 7398 5c0e 7ED0     		jle	.L374
 7399              	.LBE67:
1610:main.c        **** 					}
1611:main.c        **** 					printf("\n");
 7400              		.loc 1 1611 0 is_stmt 1
 7401 5c10 BF0A0000 		movl	$10, %edi
 7401      00
 7402 5c15 E8000000 		call	putchar
 7402      00
1612:main.c        **** 					uint8 encrpyted_ack2_tosend[4];
1613:main.c        **** 					printf("%s\n", "Converting encrypted ack2 from binary to uint8");
 7403              		.loc 1 1613 0
 7404 5c1a BF000000 		movl	$.LC191, %edi
 7404      00
 7405 5c1f E8000000 		call	puts
 7405      00
1614:main.c        **** 					BinTouint8(encrpyted_ack2_tosend, encrypted_ack2);
 7406              		.loc 1 1614 0
 7407 5c24 488D95D0 		leaq	-1584(%rbp), %rdx
 7407      F9FFFF
 7408 5c2b 488D4590 		leaq	-112(%rbp), %rax
 7409 5c2f 4889D6   		movq	%rdx, %rsi
 7410 5c32 4889C7   		movq	%rax, %rdi
 7411 5c35 E8000000 		call	BinTouint8
 7411      00
1615:main.c        **** 					printf("%s\n", "Converted encrypted ack2 to uint8 and it is as -----");
 7412              		.loc 1 1615 0
 7413 5c3a BF000000 		movl	$.LC192, %edi
 7413      00
 7414 5c3f E8000000 		call	puts
 7414      00
 7415              	.LBB68:
1616:main.c        **** 					for (int i = 0; i < 4; ++i)
 7416              		.loc 1 1616 0
 7417 5c44 C78504F3 		movl	$0, -3324(%rbp)
 7417      FFFF0000 
 7417      0000
 7418 5c4e EB28     		jmp	.L375
 7419              	.L376:
1617:main.c        **** 					{
1618:main.c        **** 						printf("%d ", encrpyted_ack2_tosend[i]);
 7420              		.loc 1 1618 0 discriminator 3
 7421 5c50 8B8504F3 		movl	-3324(%rbp), %eax
 7421      FFFF
 7422 5c56 4898     		cltq
 7423 5c58 0FB64405 		movzbl	-112(%rbp,%rax), %eax
 7423      90
 7424 5c5d 0FB6C0   		movzbl	%al, %eax
 7425 5c60 89C6     		movl	%eax, %esi
 7426 5c62 BF000000 		movl	$.LC10, %edi
 7426      00
 7427 5c67 B8000000 		movl	$0, %eax
 7427      00
 7428 5c6c E8000000 		call	printf
 7428      00
1616:main.c        **** 					for (int i = 0; i < 4; ++i)
 7429              		.loc 1 1616 0 discriminator 3
 7430 5c71 838504F3 		addl	$1, -3324(%rbp)
 7430      FFFF01
 7431              	.L375:
1616:main.c        **** 					for (int i = 0; i < 4; ++i)
 7432              		.loc 1 1616 0 is_stmt 0 discriminator 1
 7433 5c78 83BD04F3 		cmpl	$3, -3324(%rbp)
 7433      FFFF03
 7434 5c7f 7ECF     		jle	.L376
 7435              	.LBE68:
1619:main.c        **** 					}
1620:main.c        **** 					printf("\n");
 7436              		.loc 1 1620 0 is_stmt 1
 7437 5c81 BF0A0000 		movl	$10, %edi
 7437      00
 7438 5c86 E8000000 		call	putchar
 7438      00
1621:main.c        **** 					printf("%s\n", "Sending encrypted ack2 to fpga ");
 7439              		.loc 1 1621 0
 7440 5c8b BF000000 		movl	$.LC193, %edi
 7440      00
 7441 5c90 E8000000 		call	puts
 7441      00
1622:main.c        **** 					delay(del);
 7442              		.loc 1 1622 0
 7443 5c95 8B85B0F3 		movl	-3152(%rbp), %eax
 7443      FFFF
 7444 5c9b 89C7     		movl	%eax, %edi
 7445 5c9d E8000000 		call	delay
 7445      00
1623:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &encrpyted_ack2_tosend[0], &error);
 7446              		.loc 1 1623 0
 7447 5ca2 8B85C8F2 		movl	-3384(%rbp), %eax
 7447      FFFF
 7448 5ca8 01C0     		addl	%eax, %eax
 7449 5caa 83C001   		addl	$1, %eax
 7450 5cad 0FB6F0   		movzbl	%al, %esi
 7451 5cb0 488B85E0 		movq	-3104(%rbp), %rax
 7451      F3FFFF
 7452 5cb7 488D8DE8 		leaq	-3096(%rbp), %rcx
 7452      F3FFFF
 7453 5cbe 488D5590 		leaq	-112(%rbp), %rdx
 7454 5cc2 4989C8   		movq	%rcx, %r8
 7455 5cc5 4889D1   		movq	%rdx, %rcx
 7456 5cc8 BA010000 		movl	$1, %edx
 7456      00
 7457 5ccd 4889C7   		movq	%rax, %rdi
 7458 5cd0 E8000000 		call	flWriteChannel
 7458      00
 7459 5cd5 8985BCF2 		movl	%eax, -3396(%rbp)
 7459      FFFF
1624:main.c        **** 					delay(del);
 7460              		.loc 1 1624 0
 7461 5cdb 8B85B0F3 		movl	-3152(%rbp), %eax
 7461      FFFF
 7462 5ce1 89C7     		movl	%eax, %edi
 7463 5ce3 E8000000 		call	delay
 7463      00
1625:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &encrpyted_ack2_tosend[1], &error);
 7464              		.loc 1 1625 0
 7465 5ce8 8B85C8F2 		movl	-3384(%rbp), %eax
 7465      FFFF
 7466 5cee 01C0     		addl	%eax, %eax
 7467 5cf0 83C001   		addl	$1, %eax
 7468 5cf3 0FB6F0   		movzbl	%al, %esi
 7469 5cf6 488B85E0 		movq	-3104(%rbp), %rax
 7469      F3FFFF
 7470 5cfd 488D8DE8 		leaq	-3096(%rbp), %rcx
 7470      F3FFFF
 7471 5d04 488D5590 		leaq	-112(%rbp), %rdx
 7472 5d08 4883C201 		addq	$1, %rdx
 7473 5d0c 4989C8   		movq	%rcx, %r8
 7474 5d0f 4889D1   		movq	%rdx, %rcx
 7475 5d12 BA010000 		movl	$1, %edx
 7475      00
 7476 5d17 4889C7   		movq	%rax, %rdi
 7477 5d1a E8000000 		call	flWriteChannel
 7477      00
 7478 5d1f 8985BCF2 		movl	%eax, -3396(%rbp)
 7478      FFFF
1626:main.c        **** 					delay(del);
 7479              		.loc 1 1626 0
 7480 5d25 8B85B0F3 		movl	-3152(%rbp), %eax
 7480      FFFF
 7481 5d2b 89C7     		movl	%eax, %edi
 7482 5d2d E8000000 		call	delay
 7482      00
1627:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &encrpyted_ack2_tosend[2], &error);
 7483              		.loc 1 1627 0
 7484 5d32 8B85C8F2 		movl	-3384(%rbp), %eax
 7484      FFFF
 7485 5d38 01C0     		addl	%eax, %eax
 7486 5d3a 83C001   		addl	$1, %eax
 7487 5d3d 0FB6F0   		movzbl	%al, %esi
 7488 5d40 488B85E0 		movq	-3104(%rbp), %rax
 7488      F3FFFF
 7489 5d47 488D8DE8 		leaq	-3096(%rbp), %rcx
 7489      F3FFFF
 7490 5d4e 488D5590 		leaq	-112(%rbp), %rdx
 7491 5d52 4883C202 		addq	$2, %rdx
 7492 5d56 4989C8   		movq	%rcx, %r8
 7493 5d59 4889D1   		movq	%rdx, %rcx
 7494 5d5c BA010000 		movl	$1, %edx
 7494      00
 7495 5d61 4889C7   		movq	%rax, %rdi
 7496 5d64 E8000000 		call	flWriteChannel
 7496      00
 7497 5d69 8985BCF2 		movl	%eax, -3396(%rbp)
 7497      FFFF
1628:main.c        **** 					delay(del);
 7498              		.loc 1 1628 0
 7499 5d6f 8B85B0F3 		movl	-3152(%rbp), %eax
 7499      FFFF
 7500 5d75 89C7     		movl	%eax, %edi
 7501 5d77 E8000000 		call	delay
 7501      00
1629:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &encrpyted_ack2_tosend[3], &error);
 7502              		.loc 1 1629 0
 7503 5d7c 8B85C8F2 		movl	-3384(%rbp), %eax
 7503      FFFF
 7504 5d82 01C0     		addl	%eax, %eax
 7505 5d84 83C001   		addl	$1, %eax
 7506 5d87 0FB6F0   		movzbl	%al, %esi
 7507 5d8a 488B85E0 		movq	-3104(%rbp), %rax
 7507      F3FFFF
 7508 5d91 488D8DE8 		leaq	-3096(%rbp), %rcx
 7508      F3FFFF
 7509 5d98 488D5590 		leaq	-112(%rbp), %rdx
 7510 5d9c 4883C203 		addq	$3, %rdx
 7511 5da0 4989C8   		movq	%rcx, %r8
 7512 5da3 4889D1   		movq	%rdx, %rcx
 7513 5da6 BA010000 		movl	$1, %edx
 7513      00
 7514 5dab 4889C7   		movq	%rax, %rdi
 7515 5dae E8000000 		call	flWriteChannel
 7515      00
 7516 5db3 8985BCF2 		movl	%eax, -3396(%rbp)
 7516      FFFF
1630:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7517              		.loc 1 1630 0
 7518 5db9 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7518      FFFF00
 7519 5dc0 740F     		je	.L377
 7520              		.loc 1 1630 0 is_stmt 0 discriminator 1
 7521 5dc2 C785B8F2 		movl	$1, -3400(%rbp)
 7521      FFFF0100 
 7521      0000
 7522 5dcc E94F2000 		jmp	.L230
 7522      00
 7523              	.L377:
1631:main.c        **** 					printf("%s\n", "Encrypted ack2 send successfully");
 7524              		.loc 1 1631 0 is_stmt 1
 7525 5dd1 BF000000 		movl	$.LC194, %edi
 7525      00
 7526 5dd6 E8000000 		call	puts
 7526      00
1632:main.c        **** 
1633:main.c        **** 					printf("%s\n", "-------------------------H3 ended----------------------------");
 7527              		.loc 1 1633 0
 7528 5ddb BF000000 		movl	$.LC195, %edi
 7528      00
 7529 5de0 E8000000 		call	puts
 7529      00
1634:main.c        **** 
1635:main.c        **** 					printf("%s\n", "-------------------------H4 started--------------------------");
 7530              		.loc 1 1635 0
 7531 5de5 BF000000 		movl	$.LC196, %edi
 7531      00
 7532 5dea E8000000 		call	puts
 7532      00
1636:main.c        **** 
1637:main.c        **** 					printf("%s\n", "Calculating x and y co_ordinates ------------------");
 7533              		.loc 1 1637 0
 7534 5def BF000000 		movl	$.LC197, %edi
 7534      00
 7535 5df4 E8000000 		call	puts
 7535      00
 7536              	.LBB69:
1638:main.c        **** 
1639:main.c        **** 					int co_ordinates[8];
1640:main.c        **** 					for (int i = 0; i < 8; ++i)
 7537              		.loc 1 1640 0
 7538 5df9 C78508F3 		movl	$0, -3320(%rbp)
 7538      FFFF0000 
 7538      0000
 7539 5e03 EB28     		jmp	.L378
 7540              	.L379:
1641:main.c        **** 					{
1642:main.c        **** 						co_ordinates[i] = decrypted_pos[i+24];
 7541              		.loc 1 1642 0 discriminator 3
 7542 5e05 8B8508F3 		movl	-3320(%rbp), %eax
 7542      FFFF
 7543 5e0b 83C018   		addl	$24, %eax
 7544 5e0e 4898     		cltq
 7545 5e10 8B9485D0 		movl	-2096(%rbp,%rax,4), %edx
 7545      F7FFFF
 7546 5e17 8B8508F3 		movl	-3320(%rbp), %eax
 7546      FFFF
 7547 5e1d 4898     		cltq
 7548 5e1f 89948510 		movl	%edx, -2800(%rbp,%rax,4)
 7548      F5FFFF
1640:main.c        **** 					{
 7549              		.loc 1 1640 0 discriminator 3
 7550 5e26 838508F3 		addl	$1, -3320(%rbp)
 7550      FFFF01
 7551              	.L378:
1640:main.c        **** 					{
 7552              		.loc 1 1640 0 is_stmt 0 discriminator 1
 7553 5e2d 83BD08F3 		cmpl	$7, -3320(%rbp)
 7553      FFFF07
 7554 5e34 7ECF     		jle	.L379
 7555              	.LBE69:
1643:main.c        **** 					}
1644:main.c        **** 
1645:main.c        **** 					int x_cord = 8*co_ordinates[3]+4*co_ordinates[2]+2*co_ordinates[1]+co_ordinates[0];
 7556              		.loc 1 1645 0 is_stmt 1
 7557 5e36 8B851CF5 		movl	-2788(%rbp), %eax
 7557      FFFF
 7558 5e3c 8D1400   		leal	(%rax,%rax), %edx
 7559 5e3f 8B8518F5 		movl	-2792(%rbp), %eax
 7559      FFFF
 7560 5e45 01D0     		addl	%edx, %eax
 7561 5e47 8D1400   		leal	(%rax,%rax), %edx
 7562 5e4a 8B8514F5 		movl	-2796(%rbp), %eax
 7562      FFFF
 7563 5e50 01D0     		addl	%edx, %eax
 7564 5e52 8D1400   		leal	(%rax,%rax), %edx
 7565 5e55 8B8510F5 		movl	-2800(%rbp), %eax
 7565      FFFF
 7566 5e5b 01D0     		addl	%edx, %eax
 7567 5e5d 8985B4F3 		movl	%eax, -3148(%rbp)
 7567      FFFF
1646:main.c        **** 					int y_cord = 8*co_ordinates[7]+4*co_ordinates[6]+2*co_ordinates[5]+co_ordinates[4];
 7568              		.loc 1 1646 0
 7569 5e63 8B852CF5 		movl	-2772(%rbp), %eax
 7569      FFFF
 7570 5e69 8D1400   		leal	(%rax,%rax), %edx
 7571 5e6c 8B8528F5 		movl	-2776(%rbp), %eax
 7571      FFFF
 7572 5e72 01D0     		addl	%edx, %eax
 7573 5e74 8D1400   		leal	(%rax,%rax), %edx
 7574 5e77 8B8524F5 		movl	-2780(%rbp), %eax
 7574      FFFF
 7575 5e7d 01D0     		addl	%edx, %eax
 7576 5e7f 8D1400   		leal	(%rax,%rax), %edx
 7577 5e82 8B8520F5 		movl	-2784(%rbp), %eax
 7577      FFFF
 7578 5e88 01D0     		addl	%edx, %eax
 7579 5e8a 8985B8F3 		movl	%eax, -3144(%rbp)
 7579      FFFF
1647:main.c        **** 
1648:main.c        **** 
1649:main.c        **** 
1650:main.c        **** 					printf("%s\n", "x and y co_ordinates calculated, they are as --");
 7580              		.loc 1 1650 0
 7581 5e90 BF000000 		movl	$.LC198, %edi
 7581      00
 7582 5e95 E8000000 		call	puts
 7582      00
1651:main.c        **** 					printf("%d %d ", x_cord, y_cord);
 7583              		.loc 1 1651 0
 7584 5e9a 8B95B8F3 		movl	-3144(%rbp), %edx
 7584      FFFF
 7585 5ea0 8B85B4F3 		movl	-3148(%rbp), %eax
 7585      FFFF
 7586 5ea6 89C6     		movl	%eax, %esi
 7587 5ea8 BF000000 		movl	$.LC199, %edi
 7587      00
 7588 5ead B8000000 		movl	$0, %eax
 7588      00
 7589 5eb2 E8000000 		call	printf
 7589      00
1652:main.c        **** 					printf("\n");
 7590              		.loc 1 1652 0
 7591 5eb7 BF0A0000 		movl	$10, %edi
 7591      00
 7592 5ebc E8000000 		call	putchar
 7592      00
1653:main.c        **** 					int final_arr[8][8];
1654:main.c        **** 					FILE *fp = fopen("/home/shubham/Desktop/track_data.csv", "r");
 7593              		.loc 1 1654 0
 7594 5ec1 BE000000 		movl	$.LC6, %esi
 7594      00
 7595 5ec6 BF000000 		movl	$.LC7, %edi
 7595      00
 7596 5ecb E8000000 		call	fopen
 7596      00
 7597 5ed0 488985D8 		movq	%rax, -2856(%rbp)
 7597      F4FFFF
1655:main.c        **** 
1656:main.c        **** 					print(x_cord,y_cord,final_arr, fp);
 7598              		.loc 1 1656 0
 7599 5ed7 488B8DD8 		movq	-2856(%rbp), %rcx
 7599      F4FFFF
 7600 5ede 488D9560 		leaq	-416(%rbp), %rdx
 7600      FEFFFF
 7601 5ee5 8BB5B8F3 		movl	-3144(%rbp), %esi
 7601      FFFF
 7602 5eeb 8B85B4F3 		movl	-3148(%rbp), %eax
 7602      FFFF
 7603 5ef1 89C7     		movl	%eax, %edi
 7604 5ef3 E8000000 		call	print
 7604      00
1657:main.c        **** 
1658:main.c        **** 					printf("%s\n", "Got the information for x and y co_ordinates, 64 bits filled");
 7605              		.loc 1 1658 0
 7606 5ef8 BF000000 		movl	$.LC200, %edi
 7606      00
 7607 5efd E8000000 		call	puts
 7607      00
1659:main.c        **** 					printf("%s\n", "The final 64 bit array in decrypted form --");
 7608              		.loc 1 1659 0
 7609 5f02 BF000000 		movl	$.LC201, %edi
 7609      00
 7610 5f07 E8000000 		call	puts
 7610      00
 7611              	.LBB70:
1660:main.c        **** 
1661:main.c        **** 					for (int i = 0; i < 8; ++i)
 7612              		.loc 1 1661 0
 7613 5f0c C7850CF3 		movl	$0, -3316(%rbp)
 7613      FFFF0000 
 7613      0000
 7614 5f16 EB53     		jmp	.L380
 7615              	.L383:
 7616              	.LBB71:
1662:main.c        **** 					{
1663:main.c        **** 						for (int j = 0; j < 8; ++j)
 7617              		.loc 1 1663 0
 7618 5f18 C78510F3 		movl	$0, -3312(%rbp)
 7618      FFFF0000 
 7618      0000
 7619 5f22 EB37     		jmp	.L381
 7620              	.L382:
1664:main.c        **** 						{
1665:main.c        **** 							printf("%d ", final_arr[i][j]);
 7621              		.loc 1 1665 0 discriminator 3
 7622 5f24 8B8510F3 		movl	-3312(%rbp), %eax
 7622      FFFF
 7623 5f2a 4898     		cltq
 7624 5f2c 8B950CF3 		movl	-3316(%rbp), %edx
 7624      FFFF
 7625 5f32 4863D2   		movslq	%edx, %rdx
 7626 5f35 48C1E203 		salq	$3, %rdx
 7627 5f39 4801D0   		addq	%rdx, %rax
 7628 5f3c 8B848560 		movl	-416(%rbp,%rax,4), %eax
 7628      FEFFFF
 7629 5f43 89C6     		movl	%eax, %esi
 7630 5f45 BF000000 		movl	$.LC10, %edi
 7630      00
 7631 5f4a B8000000 		movl	$0, %eax
 7631      00
 7632 5f4f E8000000 		call	printf
 7632      00
1663:main.c        **** 						{
 7633              		.loc 1 1663 0 discriminator 3
 7634 5f54 838510F3 		addl	$1, -3312(%rbp)
 7634      FFFF01
 7635              	.L381:
1663:main.c        **** 						{
 7636              		.loc 1 1663 0 is_stmt 0 discriminator 1
 7637 5f5b 83BD10F3 		cmpl	$7, -3312(%rbp)
 7637      FFFF07
 7638 5f62 7EC0     		jle	.L382
 7639              	.LBE71:
1661:main.c        **** 					{
 7640              		.loc 1 1661 0 is_stmt 1 discriminator 2
 7641 5f64 83850CF3 		addl	$1, -3316(%rbp)
 7641      FFFF01
 7642              	.L380:
1661:main.c        **** 					{
 7643              		.loc 1 1661 0 is_stmt 0 discriminator 1
 7644 5f6b 83BD0CF3 		cmpl	$7, -3316(%rbp)
 7644      FFFF07
 7645 5f72 7EA4     		jle	.L383
 7646              	.LBE70:
1666:main.c        **** 						}
1667:main.c        **** 					}
1668:main.c        **** 
1669:main.c        **** 					printf("\n");
 7647              		.loc 1 1669 0 is_stmt 1
 7648 5f74 BF0A0000 		movl	$10, %edi
 7648      00
 7649 5f79 E8000000 		call	putchar
 7649      00
1670:main.c        **** 					printf("%s\n", "-------------------------H4 ended--------------------------");
 7650              		.loc 1 1670 0
 7651 5f7e BF000000 		movl	$.LC202, %edi
 7651      00
 7652 5f83 E8000000 		call	puts
 7652      00
1671:main.c        **** 
1672:main.c        **** 					printf("%s\n", "-------------------------H5 starts--------------------------");
 7653              		.loc 1 1672 0
 7654 5f88 BF000000 		movl	$.LC203, %edi
 7654      00
 7655 5f8d E8000000 		call	puts
 7655      00
 7656              	.LBB72:
1673:main.c        **** 
1674:main.c        **** 					int p1[32], p2[32], bin1[32], bin2[32];
1675:main.c        **** 
1676:main.c        **** 					for (int i = 0; i < 32; ++i)
 7657              		.loc 1 1676 0
 7658 5f92 C78514F3 		movl	$0, -3308(%rbp)
 7658      FFFF0000 
 7658      0000
 7659 5f9c EB2D     		jmp	.L384
 7660              	.L385:
1677:main.c        **** 					{
1678:main.c        **** 						bin1[i] = 0;
 7661              		.loc 1 1678 0 discriminator 3
 7662 5f9e 8B8514F3 		movl	-3308(%rbp), %eax
 7662      FFFF
 7663 5fa4 4898     		cltq
 7664 5fa6 C7848550 		movl	$0, -1200(%rbp,%rax,4)
 7664      FBFFFF00 
 7664      000000
1679:main.c        **** 						bin2[i] = 0;
 7665              		.loc 1 1679 0 discriminator 3
 7666 5fb1 8B8514F3 		movl	-3308(%rbp), %eax
 7666      FFFF
 7667 5fb7 4898     		cltq
 7668 5fb9 C78485D0 		movl	$0, -1072(%rbp,%rax,4)
 7668      FBFFFF00 
 7668      000000
1676:main.c        **** 					{
 7669              		.loc 1 1676 0 discriminator 3
 7670 5fc4 838514F3 		addl	$1, -3308(%rbp)
 7670      FFFF01
 7671              	.L384:
1676:main.c        **** 					{
 7672              		.loc 1 1676 0 is_stmt 0 discriminator 1
 7673 5fcb 83BD14F3 		cmpl	$31, -3308(%rbp)
 7673      FFFF1F
 7674 5fd2 7ECA     		jle	.L385
 7675              	.LBE72:
1680:main.c        **** 					}
1681:main.c        **** 
1682:main.c        **** 					int k1 = 0;
 7676              		.loc 1 1682 0 is_stmt 1
 7677 5fd4 C78518F3 		movl	$0, -3304(%rbp)
 7677      FFFF0000 
 7677      0000
 7678              	.LBB73:
1683:main.c        **** 					for(int i=0; i<4; i++)
 7679              		.loc 1 1683 0
 7680 5fde C7851CF3 		movl	$0, -3300(%rbp)
 7680      FFFF0000 
 7680      0000
 7681 5fe8 EB58     		jmp	.L386
 7682              	.L389:
 7683              	.LBB74:
1684:main.c        **** 					{
1685:main.c        **** 						for(int j=0; j<8; j++)
 7684              		.loc 1 1685 0
 7685 5fea C78520F3 		movl	$0, -3296(%rbp)
 7685      FFFF0000 
 7685      0000
 7686 5ff4 EB3C     		jmp	.L387
 7687              	.L388:
1686:main.c        **** 						{
1687:main.c        **** 							p1[k1] = final_arr[i][j];
 7688              		.loc 1 1687 0 discriminator 3
 7689 5ff6 8B8520F3 		movl	-3296(%rbp), %eax
 7689      FFFF
 7690 5ffc 4898     		cltq
 7691 5ffe 8B951CF3 		movl	-3300(%rbp), %edx
 7691      FFFF
 7692 6004 4863D2   		movslq	%edx, %rdx
 7693 6007 48C1E203 		salq	$3, %rdx
 7694 600b 4801D0   		addq	%rdx, %rax
 7695 600e 8B948560 		movl	-416(%rbp,%rax,4), %edx
 7695      FEFFFF
 7696 6015 8B8518F3 		movl	-3304(%rbp), %eax
 7696      FFFF
 7697 601b 4898     		cltq
 7698 601d 89948550 		movl	%edx, -1456(%rbp,%rax,4)
 7698      FAFFFF
1688:main.c        **** 							k1++;
 7699              		.loc 1 1688 0 discriminator 3
 7700 6024 838518F3 		addl	$1, -3304(%rbp)
 7700      FFFF01
1685:main.c        **** 						{
 7701              		.loc 1 1685 0 discriminator 3
 7702 602b 838520F3 		addl	$1, -3296(%rbp)
 7702      FFFF01
 7703              	.L387:
1685:main.c        **** 						{
 7704              		.loc 1 1685 0 is_stmt 0 discriminator 1
 7705 6032 83BD20F3 		cmpl	$7, -3296(%rbp)
 7705      FFFF07
 7706 6039 7EBB     		jle	.L388
 7707              	.LBE74:
1683:main.c        **** 					{
 7708              		.loc 1 1683 0 is_stmt 1 discriminator 2
 7709 603b 83851CF3 		addl	$1, -3300(%rbp)
 7709      FFFF01
 7710              	.L386:
1683:main.c        **** 					{
 7711              		.loc 1 1683 0 is_stmt 0 discriminator 1
 7712 6042 83BD1CF3 		cmpl	$3, -3300(%rbp)
 7712      FFFF03
 7713 6049 7E9F     		jle	.L389
 7714              	.LBE73:
1689:main.c        **** 						}
1690:main.c        **** 
1691:main.c        **** 					}
1692:main.c        **** 
1693:main.c        **** 					int k2 = 0;
 7715              		.loc 1 1693 0 is_stmt 1
 7716 604b C78524F3 		movl	$0, -3292(%rbp)
 7716      FFFF0000 
 7716      0000
 7717              	.LBB75:
1694:main.c        **** 					for(int i=4; i<8; i++){
 7718              		.loc 1 1694 0
 7719 6055 C78528F3 		movl	$4, -3288(%rbp)
 7719      FFFF0400 
 7719      0000
 7720 605f EB58     		jmp	.L390
 7721              	.L393:
 7722              	.LBB76:
1695:main.c        **** 						for(int j=0; j<8; j++)
 7723              		.loc 1 1695 0
 7724 6061 C7852CF3 		movl	$0, -3284(%rbp)
 7724      FFFF0000 
 7724      0000
 7725 606b EB3C     		jmp	.L391
 7726              	.L392:
1696:main.c        **** 						{
1697:main.c        **** 							p2[k2] = final_arr[i][j];
 7727              		.loc 1 1697 0 discriminator 3
 7728 606d 8B852CF3 		movl	-3284(%rbp), %eax
 7728      FFFF
 7729 6073 4898     		cltq
 7730 6075 8B9528F3 		movl	-3288(%rbp), %edx
 7730      FFFF
 7731 607b 4863D2   		movslq	%edx, %rdx
 7732 607e 48C1E203 		salq	$3, %rdx
 7733 6082 4801D0   		addq	%rdx, %rax
 7734 6085 8B948560 		movl	-416(%rbp,%rax,4), %edx
 7734      FEFFFF
 7735 608c 8B8524F3 		movl	-3292(%rbp), %eax
 7735      FFFF
 7736 6092 4898     		cltq
 7737 6094 899485D0 		movl	%edx, -1328(%rbp,%rax,4)
 7737      FAFFFF
1698:main.c        **** 							k2++;
 7738              		.loc 1 1698 0 discriminator 3
 7739 609b 838524F3 		addl	$1, -3292(%rbp)
 7739      FFFF01
1695:main.c        **** 						for(int j=0; j<8; j++)
 7740              		.loc 1 1695 0 discriminator 3
 7741 60a2 83852CF3 		addl	$1, -3284(%rbp)
 7741      FFFF01
 7742              	.L391:
1695:main.c        **** 						for(int j=0; j<8; j++)
 7743              		.loc 1 1695 0 is_stmt 0 discriminator 1
 7744 60a9 83BD2CF3 		cmpl	$7, -3284(%rbp)
 7744      FFFF07
 7745 60b0 7EBB     		jle	.L392
 7746              	.LBE76:
1694:main.c        **** 						for(int j=0; j<8; j++)
 7747              		.loc 1 1694 0 is_stmt 1 discriminator 2
 7748 60b2 838528F3 		addl	$1, -3288(%rbp)
 7748      FFFF01
 7749              	.L390:
1694:main.c        **** 						for(int j=0; j<8; j++)
 7750              		.loc 1 1694 0 is_stmt 0 discriminator 1
 7751 60b9 83BD28F3 		cmpl	$7, -3288(%rbp)
 7751      FFFF07
 7752 60c0 7E9F     		jle	.L393
 7753              	.LBE75:
1699:main.c        **** 						}
1700:main.c        **** 					}
1701:main.c        **** 
1702:main.c        **** 					printf("%s\n", "Encrypting first 32 bits of final array");
 7754              		.loc 1 1702 0 is_stmt 1
 7755 60c2 BF000000 		movl	$.LC204, %edi
 7755      00
 7756 60c7 E8000000 		call	puts
 7756      00
1703:main.c        **** 					encrypter(p1, K, bin1);
 7757              		.loc 1 1703 0
 7758 60cc 488D9550 		leaq	-1200(%rbp), %rdx
 7758      FBFFFF
 7759 60d3 488D8DD0 		leaq	-2608(%rbp), %rcx
 7759      F5FFFF
 7760 60da 488D8550 		leaq	-1456(%rbp), %rax
 7760      FAFFFF
 7761 60e1 4889CE   		movq	%rcx, %rsi
 7762 60e4 4889C7   		movq	%rax, %rdi
 7763 60e7 E8000000 		call	encrypter
 7763      00
1704:main.c        **** 					printf("%s\n", "First 32 bits got encrypted , they are as ----");
 7764              		.loc 1 1704 0
 7765 60ec BF000000 		movl	$.LC205, %edi
 7765      00
 7766 60f1 E8000000 		call	puts
 7766      00
 7767              	.LBB77:
1705:main.c        **** 					for (int i = 0; i < 32; ++i)
 7768              		.loc 1 1705 0
 7769 60f6 C78530F3 		movl	$0, -3280(%rbp)
 7769      FFFF0000 
 7769      0000
 7770 6100 EB27     		jmp	.L394
 7771              	.L395:
1706:main.c        **** 					{
1707:main.c        **** 						printf("%d ", bin1[i]);
 7772              		.loc 1 1707 0 discriminator 3
 7773 6102 8B8530F3 		movl	-3280(%rbp), %eax
 7773      FFFF
 7774 6108 4898     		cltq
 7775 610a 8B848550 		movl	-1200(%rbp,%rax,4), %eax
 7775      FBFFFF
 7776 6111 89C6     		movl	%eax, %esi
 7777 6113 BF000000 		movl	$.LC10, %edi
 7777      00
 7778 6118 B8000000 		movl	$0, %eax
 7778      00
 7779 611d E8000000 		call	printf
 7779      00
1705:main.c        **** 					for (int i = 0; i < 32; ++i)
 7780              		.loc 1 1705 0 discriminator 3
 7781 6122 838530F3 		addl	$1, -3280(%rbp)
 7781      FFFF01
 7782              	.L394:
1705:main.c        **** 					for (int i = 0; i < 32; ++i)
 7783              		.loc 1 1705 0 is_stmt 0 discriminator 1
 7784 6129 83BD30F3 		cmpl	$31, -3280(%rbp)
 7784      FFFF1F
 7785 6130 7ED0     		jle	.L395
 7786              	.LBE77:
1708:main.c        **** 					}
1709:main.c        **** 					printf("\n");
 7787              		.loc 1 1709 0 is_stmt 1
 7788 6132 BF0A0000 		movl	$10, %edi
 7788      00
 7789 6137 E8000000 		call	putchar
 7789      00
1710:main.c        **** 					uint8 first32_bitsTosend[4];
1711:main.c        **** 					printf("%s\n", "Converting first 32 bits to uint8");
 7790              		.loc 1 1711 0
 7791 613c BF000000 		movl	$.LC206, %edi
 7791      00
 7792 6141 E8000000 		call	puts
 7792      00
1712:main.c        **** 					BinTouint8(first32_bitsTosend, bin1);
 7793              		.loc 1 1712 0
 7794 6146 488D9550 		leaq	-1200(%rbp), %rdx
 7794      FBFFFF
 7795 614d 488D45A0 		leaq	-96(%rbp), %rax
 7796 6151 4889D6   		movq	%rdx, %rsi
 7797 6154 4889C7   		movq	%rax, %rdi
 7798 6157 E8000000 		call	BinTouint8
 7798      00
1713:main.c        **** 					printf("%s\n", "First 32 bits got converted to uint8, they are as");
 7799              		.loc 1 1713 0
 7800 615c BF000000 		movl	$.LC207, %edi
 7800      00
 7801 6161 E8000000 		call	puts
 7801      00
 7802              	.LBB78:
1714:main.c        **** 					for (int i = 0; i < 4; ++i)
 7803              		.loc 1 1714 0
 7804 6166 C78534F3 		movl	$0, -3276(%rbp)
 7804      FFFF0000 
 7804      0000
 7805 6170 EB28     		jmp	.L396
 7806              	.L397:
1715:main.c        **** 					{
1716:main.c        **** 						printf("%d ", first32_bitsTosend[i]);
 7807              		.loc 1 1716 0 discriminator 3
 7808 6172 8B8534F3 		movl	-3276(%rbp), %eax
 7808      FFFF
 7809 6178 4898     		cltq
 7810 617a 0FB64405 		movzbl	-96(%rbp,%rax), %eax
 7810      A0
 7811 617f 0FB6C0   		movzbl	%al, %eax
 7812 6182 89C6     		movl	%eax, %esi
 7813 6184 BF000000 		movl	$.LC10, %edi
 7813      00
 7814 6189 B8000000 		movl	$0, %eax
 7814      00
 7815 618e E8000000 		call	printf
 7815      00
1714:main.c        **** 					for (int i = 0; i < 4; ++i)
 7816              		.loc 1 1714 0 discriminator 3
 7817 6193 838534F3 		addl	$1, -3276(%rbp)
 7817      FFFF01
 7818              	.L396:
1714:main.c        **** 					for (int i = 0; i < 4; ++i)
 7819              		.loc 1 1714 0 is_stmt 0 discriminator 1
 7820 619a 83BD34F3 		cmpl	$3, -3276(%rbp)
 7820      FFFF03
 7821 61a1 7ECF     		jle	.L397
 7822              	.LBE78:
1717:main.c        **** 					}
1718:main.c        **** 					printf("\n");
 7823              		.loc 1 1718 0 is_stmt 1
 7824 61a3 BF0A0000 		movl	$10, %edi
 7824      00
 7825 61a8 E8000000 		call	putchar
 7825      00
1719:main.c        **** 					printf("%s\n", "Writing on channel first 32 bits encrypted");
 7826              		.loc 1 1719 0
 7827 61ad BF000000 		movl	$.LC208, %edi
 7827      00
 7828 61b2 E8000000 		call	puts
 7828      00
1720:main.c        **** 					delay(del);
 7829              		.loc 1 1720 0
 7830 61b7 8B85B0F3 		movl	-3152(%rbp), %eax
 7830      FFFF
 7831 61bd 89C7     		movl	%eax, %edi
 7832 61bf E8000000 		call	delay
 7832      00
1721:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &first32_bitsTosend[0], &error);
 7833              		.loc 1 1721 0
 7834 61c4 8B85C8F2 		movl	-3384(%rbp), %eax
 7834      FFFF
 7835 61ca 01C0     		addl	%eax, %eax
 7836 61cc 83C001   		addl	$1, %eax
 7837 61cf 0FB6F0   		movzbl	%al, %esi
 7838 61d2 488B85E0 		movq	-3104(%rbp), %rax
 7838      F3FFFF
 7839 61d9 488D8DE8 		leaq	-3096(%rbp), %rcx
 7839      F3FFFF
 7840 61e0 488D55A0 		leaq	-96(%rbp), %rdx
 7841 61e4 4989C8   		movq	%rcx, %r8
 7842 61e7 4889D1   		movq	%rdx, %rcx
 7843 61ea BA010000 		movl	$1, %edx
 7843      00
 7844 61ef 4889C7   		movq	%rax, %rdi
 7845 61f2 E8000000 		call	flWriteChannel
 7845      00
 7846 61f7 8985BCF2 		movl	%eax, -3396(%rbp)
 7846      FFFF
1722:main.c        **** 					delay(del);
 7847              		.loc 1 1722 0
 7848 61fd 8B85B0F3 		movl	-3152(%rbp), %eax
 7848      FFFF
 7849 6203 89C7     		movl	%eax, %edi
 7850 6205 E8000000 		call	delay
 7850      00
1723:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &first32_bitsTosend[1], &error);
 7851              		.loc 1 1723 0
 7852 620a 8B85C8F2 		movl	-3384(%rbp), %eax
 7852      FFFF
 7853 6210 01C0     		addl	%eax, %eax
 7854 6212 83C001   		addl	$1, %eax
 7855 6215 0FB6F0   		movzbl	%al, %esi
 7856 6218 488B85E0 		movq	-3104(%rbp), %rax
 7856      F3FFFF
 7857 621f 488D8DE8 		leaq	-3096(%rbp), %rcx
 7857      F3FFFF
 7858 6226 488D55A0 		leaq	-96(%rbp), %rdx
 7859 622a 4883C201 		addq	$1, %rdx
 7860 622e 4989C8   		movq	%rcx, %r8
 7861 6231 4889D1   		movq	%rdx, %rcx
 7862 6234 BA010000 		movl	$1, %edx
 7862      00
 7863 6239 4889C7   		movq	%rax, %rdi
 7864 623c E8000000 		call	flWriteChannel
 7864      00
 7865 6241 8985BCF2 		movl	%eax, -3396(%rbp)
 7865      FFFF
1724:main.c        **** 					delay(del);
 7866              		.loc 1 1724 0
 7867 6247 8B85B0F3 		movl	-3152(%rbp), %eax
 7867      FFFF
 7868 624d 89C7     		movl	%eax, %edi
 7869 624f E8000000 		call	delay
 7869      00
1725:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &first32_bitsTosend[2], &error);
 7870              		.loc 1 1725 0
 7871 6254 8B85C8F2 		movl	-3384(%rbp), %eax
 7871      FFFF
 7872 625a 01C0     		addl	%eax, %eax
 7873 625c 83C001   		addl	$1, %eax
 7874 625f 0FB6F0   		movzbl	%al, %esi
 7875 6262 488B85E0 		movq	-3104(%rbp), %rax
 7875      F3FFFF
 7876 6269 488D8DE8 		leaq	-3096(%rbp), %rcx
 7876      F3FFFF
 7877 6270 488D55A0 		leaq	-96(%rbp), %rdx
 7878 6274 4883C202 		addq	$2, %rdx
 7879 6278 4989C8   		movq	%rcx, %r8
 7880 627b 4889D1   		movq	%rdx, %rcx
 7881 627e BA010000 		movl	$1, %edx
 7881      00
 7882 6283 4889C7   		movq	%rax, %rdi
 7883 6286 E8000000 		call	flWriteChannel
 7883      00
 7884 628b 8985BCF2 		movl	%eax, -3396(%rbp)
 7884      FFFF
1726:main.c        **** 					delay(del);
 7885              		.loc 1 1726 0
 7886 6291 8B85B0F3 		movl	-3152(%rbp), %eax
 7886      FFFF
 7887 6297 89C7     		movl	%eax, %edi
 7888 6299 E8000000 		call	delay
 7888      00
1727:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &first32_bitsTosend[3], &error);
 7889              		.loc 1 1727 0
 7890 629e 8B85C8F2 		movl	-3384(%rbp), %eax
 7890      FFFF
 7891 62a4 01C0     		addl	%eax, %eax
 7892 62a6 83C001   		addl	$1, %eax
 7893 62a9 0FB6F0   		movzbl	%al, %esi
 7894 62ac 488B85E0 		movq	-3104(%rbp), %rax
 7894      F3FFFF
 7895 62b3 488D8DE8 		leaq	-3096(%rbp), %rcx
 7895      F3FFFF
 7896 62ba 488D55A0 		leaq	-96(%rbp), %rdx
 7897 62be 4883C203 		addq	$3, %rdx
 7898 62c2 4989C8   		movq	%rcx, %r8
 7899 62c5 4889D1   		movq	%rdx, %rcx
 7900 62c8 BA010000 		movl	$1, %edx
 7900      00
 7901 62cd 4889C7   		movq	%rax, %rdi
 7902 62d0 E8000000 		call	flWriteChannel
 7902      00
 7903 62d5 8985BCF2 		movl	%eax, -3396(%rbp)
 7903      FFFF
1728:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7904              		.loc 1 1728 0
 7905 62db 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7905      FFFF00
 7906 62e2 740F     		je	.L398
 7907              		.loc 1 1728 0 is_stmt 0 discriminator 1
 7908 62e4 C785B8F2 		movl	$1, -3400(%rbp)
 7908      FFFF0100 
 7908      0000
 7909 62ee E92D1B00 		jmp	.L230
 7909      00
 7910              	.L398:
1729:main.c        **** 
1730:main.c        **** 					printf("%s\n", "-----------------------------H5 ends------------------");
 7911              		.loc 1 1730 0 is_stmt 1
 7912 62f3 BF000000 		movl	$.LC209, %edi
 7912      00
 7913 62f8 E8000000 		call	puts
 7913      00
1731:main.c        **** 					printf("%s\n", "-----------------------------H6 starts------------------");
 7914              		.loc 1 1731 0
 7915 62fd BF000000 		movl	$.LC210, %edi
 7915      00
 7916 6302 E8000000 		call	puts
 7916      00
1732:main.c        **** 
1733:main.c        **** 					printf("%s\n", "Waiting for encrypted ack1 ");
 7917              		.loc 1 1733 0
 7918 6307 BF000000 		movl	$.LC211, %edi
 7918      00
 7919 630c E8000000 		call	puts
 7919      00
1734:main.c        **** 					time_t startTime, endTime;
1735:main.c        **** 					time(&startTime); 	
 7920              		.loc 1 1735 0
 7921 6311 488D85F8 		leaq	-3080(%rbp), %rax
 7921      F3FFFF
 7922 6318 4889C7   		movq	%rax, %rdi
 7923 631b E8000000 		call	time
 7923      00
1736:main.c        **** 
1737:main.c        **** 					printf("%s\n", "-----------------------------H7 starts------------------");
 7924              		.loc 1 1737 0
 7925 6320 BF000000 		movl	$.LC212, %edi
 7925      00
 7926 6325 E8000000 		call	puts
 7926      00
1738:main.c        **** 
1739:main.c        **** 					double diff;
1740:main.c        **** 					int arb3 = 0;
 7927              		.loc 1 1740 0
 7928 632a C78538F3 		movl	$0, -3272(%rbp)
 7928      FFFF0000 
 7928      0000
1741:main.c        **** 
1742:main.c        **** 					int breaker = 0;
 7929              		.loc 1 1742 0
 7930 6334 C7853CF3 		movl	$0, -3268(%rbp)
 7930      FFFF0000 
 7930      0000
 7931              	.L426:
 7932              	.LBB79:
1743:main.c        **** 					while(true)
1744:main.c        **** 					{
1745:main.c        **** 						time(&endTime);
 7933              		.loc 1 1745 0
 7934 633e 488D8500 		leaq	-3072(%rbp), %rax
 7934      F4FFFF
 7935 6345 4889C7   		movq	%rax, %rdi
 7936 6348 E8000000 		call	time
 7936      00
1746:main.c        **** 						diff = difftime(endTime, startTime);
 7937              		.loc 1 1746 0
 7938 634d 488B95F8 		movq	-3080(%rbp), %rdx
 7938      F3FFFF
 7939 6354 488B8500 		movq	-3072(%rbp), %rax
 7939      F4FFFF
 7940 635b 4889D6   		movq	%rdx, %rsi
 7941 635e 4889C7   		movq	%rax, %rdi
 7942 6361 E8000000 		call	difftime
 7942      00
 7943 6366 66480F7E 		movq	%xmm0, %rax
 7943      C0
 7944 636b 488985E0 		movq	%rax, -2848(%rbp)
 7944      F4FFFF
1747:main.c        **** 						if(diff > 256)
 7945              		.loc 1 1747 0
 7946 6372 F20F1085 		movsd	-2848(%rbp), %xmm0
 7946      E0F4FFFF 
 7947 637a 660F2E05 		ucomisd	.LC213(%rip), %xmm0
 7947      00000000 
 7948 6382 7620     		jbe	.L517
1748:main.c        **** 						{
1749:main.c        **** 							printf("%s\n", "Going to H2, time exceeded 256 seconds");
 7949              		.loc 1 1749 0
 7950 6384 BF000000 		movl	$.LC214, %edi
 7950      00
 7951 6389 E8000000 		call	puts
 7951      00
1750:main.c        **** 							k = k-1;
 7952              		.loc 1 1750 0
 7953 638e 83ADC8F2 		subl	$1, -3384(%rbp)
 7953      FFFF01
1751:main.c        **** 							arb3 = 1;
 7954              		.loc 1 1751 0
 7955 6395 C78538F3 		movl	$1, -3272(%rbp)
 7955      FFFF0100 
 7955      0000
1752:main.c        **** 							break;
 7956              		.loc 1 1752 0
 7957 639f E90A0500 		jmp	.L401
 7957      00
 7958              	.L517:
1753:main.c        **** 						}
1754:main.c        **** 						int arb = 0;
 7959              		.loc 1 1754 0
 7960 63a4 C78540F3 		movl	$0, -3264(%rbp)
 7960      FFFF0000 
 7960      0000
1755:main.c        **** 						uint8 encrypted_ack1_again2[4];
1756:main.c        **** 						delay(del);
 7961              		.loc 1 1756 0
 7962 63ae 8B85B0F3 		movl	-3152(%rbp), %eax
 7962      FFFF
 7963 63b4 89C7     		movl	%eax, %edi
 7964 63b6 E8000000 		call	delay
 7964      00
1757:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again2[0], &error);
 7965              		.loc 1 1757 0
 7966 63bb 8B85C8F2 		movl	-3384(%rbp), %eax
 7966      FFFF
 7967 63c1 01C0     		addl	%eax, %eax
 7968 63c3 0FB6F0   		movzbl	%al, %esi
 7969 63c6 488B85E0 		movq	-3104(%rbp), %rax
 7969      F3FFFF
 7970 63cd 488D8DE8 		leaq	-3096(%rbp), %rcx
 7970      F3FFFF
 7971 63d4 488D55D0 		leaq	-48(%rbp), %rdx
 7972 63d8 4989C8   		movq	%rcx, %r8
 7973 63db 4889D1   		movq	%rdx, %rcx
 7974 63de BA010000 		movl	$1, %edx
 7974      00
 7975 63e3 4889C7   		movq	%rax, %rdi
 7976 63e6 E8000000 		call	flReadChannelAsyncSubmit
 7976      00
 7977 63eb 8985BCF2 		movl	%eax, -3396(%rbp)
 7977      FFFF
1758:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7978              		.loc 1 1758 0
 7979 63f1 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7979      FFFF00
 7980 63f8 740F     		je	.L402
 7981              		.loc 1 1758 0 is_stmt 0 discriminator 1
 7982 63fa C785B8F2 		movl	$1, -3400(%rbp)
 7982      FFFF0100 
 7982      0000
 7983 6404 E9171A00 		jmp	.L230
 7983      00
 7984              	.L402:
1759:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 7985              		.loc 1 1759 0 is_stmt 1
 7986 6409 488B85E0 		movq	-3104(%rbp), %rax
 7986      F3FFFF
 7987 6410 488DBDE8 		leaq	-3096(%rbp), %rdi
 7987      F3FFFF
 7988 6417 488D8DB4 		leaq	-3404(%rbp), %rcx
 7988      F2FFFF
 7989 641e 488D95B4 		leaq	-3404(%rbp), %rdx
 7989      F2FFFF
 7990 6425 488DB5F0 		leaq	-3088(%rbp), %rsi
 7990      F3FFFF
 7991 642c 4989F8   		movq	%rdi, %r8
 7992 642f 4889C7   		movq	%rax, %rdi
 7993 6432 E8000000 		call	flReadChannelAsyncAwait
 7993      00
 7994 6437 8985BCF2 		movl	%eax, -3396(%rbp)
 7994      FFFF
1760:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 7995              		.loc 1 1760 0
 7996 643d 83BDBCF2 		cmpl	$0, -3396(%rbp)
 7996      FFFF00
 7997 6444 740F     		je	.L404
 7998              		.loc 1 1760 0 is_stmt 0 discriminator 1
 7999 6446 C785B8F2 		movl	$1, -3400(%rbp)
 7999      FFFF0100 
 7999      0000
 8000 6450 E9680400 		jmp	.L403
 8000      00
 8001              	.L404:
1761:main.c        **** 						if(encrypted_ack1_again2[0] == reset) 
 8002              		.loc 1 1761 0 is_stmt 1
 8003 6455 0FB645D0 		movzbl	-48(%rbp), %eax
 8004 6459 3A85AFF2 		cmpb	-3409(%rbp), %al
 8004      FFFF
 8005 645f 751D     		jne	.L405
1762:main.c        **** 							{
1763:main.c        **** 								k--; 
 8006              		.loc 1 1763 0
 8007 6461 83ADC8F2 		subl	$1, -3384(%rbp)
 8007      FFFF01
1764:main.c        **** 								breaker++; 
 8008              		.loc 1 1764 0
 8009 6468 83853CF3 		addl	$1, -3268(%rbp)
 8009      FFFF01
1765:main.c        **** 							    printf("%s\n", "-------------------------RESET------------------------");
 8010              		.loc 1 1765 0
 8011 646f BF000000 		movl	$.LC155, %edi
 8011      00
 8012 6474 E8000000 		call	puts
 8012      00
1766:main.c        **** 								break;
 8013              		.loc 1 1766 0
 8014 6479 E9300400 		jmp	.L401
 8014      00
 8015              	.L405:
1767:main.c        **** 							}
1768:main.c        **** 						delay(del);
 8016              		.loc 1 1768 0
 8017 647e 8B85B0F3 		movl	-3152(%rbp), %eax
 8017      FFFF
 8018 6484 89C7     		movl	%eax, %edi
 8019 6486 E8000000 		call	delay
 8019      00
1769:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again2[1], &error);
 8020              		.loc 1 1769 0
 8021 648b 8B85C8F2 		movl	-3384(%rbp), %eax
 8021      FFFF
 8022 6491 01C0     		addl	%eax, %eax
 8023 6493 0FB6F0   		movzbl	%al, %esi
 8024 6496 488B85E0 		movq	-3104(%rbp), %rax
 8024      F3FFFF
 8025 649d 488D8DE8 		leaq	-3096(%rbp), %rcx
 8025      F3FFFF
 8026 64a4 488D55D0 		leaq	-48(%rbp), %rdx
 8027 64a8 4883C201 		addq	$1, %rdx
 8028 64ac 4989C8   		movq	%rcx, %r8
 8029 64af 4889D1   		movq	%rdx, %rcx
 8030 64b2 BA010000 		movl	$1, %edx
 8030      00
 8031 64b7 4889C7   		movq	%rax, %rdi
 8032 64ba E8000000 		call	flReadChannelAsyncSubmit
 8032      00
 8033 64bf 8985BCF2 		movl	%eax, -3396(%rbp)
 8033      FFFF
1770:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8034              		.loc 1 1770 0
 8035 64c5 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8035      FFFF00
 8036 64cc 740F     		je	.L406
 8037              		.loc 1 1770 0 is_stmt 0 discriminator 1
 8038 64ce C785B8F2 		movl	$1, -3400(%rbp)
 8038      FFFF0100 
 8038      0000
 8039 64d8 E9E00300 		jmp	.L403
 8039      00
 8040              	.L406:
1771:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 8041              		.loc 1 1771 0 is_stmt 1
 8042 64dd 488B85E0 		movq	-3104(%rbp), %rax
 8042      F3FFFF
 8043 64e4 488DBDE8 		leaq	-3096(%rbp), %rdi
 8043      F3FFFF
 8044 64eb 488D8DB4 		leaq	-3404(%rbp), %rcx
 8044      F2FFFF
 8045 64f2 488D95B4 		leaq	-3404(%rbp), %rdx
 8045      F2FFFF
 8046 64f9 488DB5F0 		leaq	-3088(%rbp), %rsi
 8046      F3FFFF
 8047 6500 4989F8   		movq	%rdi, %r8
 8048 6503 4889C7   		movq	%rax, %rdi
 8049 6506 E8000000 		call	flReadChannelAsyncAwait
 8049      00
 8050 650b 8985BCF2 		movl	%eax, -3396(%rbp)
 8050      FFFF
1772:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8051              		.loc 1 1772 0
 8052 6511 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8052      FFFF00
 8053 6518 740F     		je	.L407
 8054              		.loc 1 1772 0 is_stmt 0 discriminator 1
 8055 651a C785B8F2 		movl	$1, -3400(%rbp)
 8055      FFFF0100 
 8055      0000
 8056 6524 E9940300 		jmp	.L403
 8056      00
 8057              	.L407:
1773:main.c        **** 						if(encrypted_ack1_again2[1] == reset) 
 8058              		.loc 1 1773 0 is_stmt 1
 8059 6529 0FB645D1 		movzbl	-47(%rbp), %eax
 8060 652d 3A85AFF2 		cmpb	-3409(%rbp), %al
 8060      FFFF
 8061 6533 751D     		jne	.L408
1774:main.c        **** 							{
1775:main.c        **** 								k--; 
 8062              		.loc 1 1775 0
 8063 6535 83ADC8F2 		subl	$1, -3384(%rbp)
 8063      FFFF01
1776:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 8064              		.loc 1 1776 0
 8065 653c BF000000 		movl	$.LC155, %edi
 8065      00
 8066 6541 E8000000 		call	puts
 8066      00
1777:main.c        **** 								breaker++; 
 8067              		.loc 1 1777 0
 8068 6546 83853CF3 		addl	$1, -3268(%rbp)
 8068      FFFF01
1778:main.c        **** 								break;
 8069              		.loc 1 1778 0
 8070 654d E95C0300 		jmp	.L401
 8070      00
 8071              	.L408:
1779:main.c        **** 							}
1780:main.c        **** 						delay(del);
 8072              		.loc 1 1780 0
 8073 6552 8B85B0F3 		movl	-3152(%rbp), %eax
 8073      FFFF
 8074 6558 89C7     		movl	%eax, %edi
 8075 655a E8000000 		call	delay
 8075      00
1781:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again2[2], &error);
 8076              		.loc 1 1781 0
 8077 655f 8B85C8F2 		movl	-3384(%rbp), %eax
 8077      FFFF
 8078 6565 01C0     		addl	%eax, %eax
 8079 6567 0FB6F0   		movzbl	%al, %esi
 8080 656a 488B85E0 		movq	-3104(%rbp), %rax
 8080      F3FFFF
 8081 6571 488D8DE8 		leaq	-3096(%rbp), %rcx
 8081      F3FFFF
 8082 6578 488D55D0 		leaq	-48(%rbp), %rdx
 8083 657c 4883C202 		addq	$2, %rdx
 8084 6580 4989C8   		movq	%rcx, %r8
 8085 6583 4889D1   		movq	%rdx, %rcx
 8086 6586 BA010000 		movl	$1, %edx
 8086      00
 8087 658b 4889C7   		movq	%rax, %rdi
 8088 658e E8000000 		call	flReadChannelAsyncSubmit
 8088      00
 8089 6593 8985BCF2 		movl	%eax, -3396(%rbp)
 8089      FFFF
1782:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8090              		.loc 1 1782 0
 8091 6599 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8091      FFFF00
 8092 65a0 740F     		je	.L409
 8093              		.loc 1 1782 0 is_stmt 0 discriminator 1
 8094 65a2 C785B8F2 		movl	$1, -3400(%rbp)
 8094      FFFF0100 
 8094      0000
 8095 65ac E90C0300 		jmp	.L403
 8095      00
 8096              	.L409:
1783:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 8097              		.loc 1 1783 0 is_stmt 1
 8098 65b1 488B85E0 		movq	-3104(%rbp), %rax
 8098      F3FFFF
 8099 65b8 488DBDE8 		leaq	-3096(%rbp), %rdi
 8099      F3FFFF
 8100 65bf 488D8DB4 		leaq	-3404(%rbp), %rcx
 8100      F2FFFF
 8101 65c6 488D95B4 		leaq	-3404(%rbp), %rdx
 8101      F2FFFF
 8102 65cd 488DB5F0 		leaq	-3088(%rbp), %rsi
 8102      F3FFFF
 8103 65d4 4989F8   		movq	%rdi, %r8
 8104 65d7 4889C7   		movq	%rax, %rdi
 8105 65da E8000000 		call	flReadChannelAsyncAwait
 8105      00
 8106 65df 8985BCF2 		movl	%eax, -3396(%rbp)
 8106      FFFF
1784:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8107              		.loc 1 1784 0
 8108 65e5 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8108      FFFF00
 8109 65ec 740F     		je	.L410
 8110              		.loc 1 1784 0 is_stmt 0 discriminator 1
 8111 65ee C785B8F2 		movl	$1, -3400(%rbp)
 8111      FFFF0100 
 8111      0000
 8112 65f8 E9C00200 		jmp	.L403
 8112      00
 8113              	.L410:
1785:main.c        **** 						if(encrypted_ack1_again2[2] == reset) 
 8114              		.loc 1 1785 0 is_stmt 1
 8115 65fd 0FB645D2 		movzbl	-46(%rbp), %eax
 8116 6601 3A85AFF2 		cmpb	-3409(%rbp), %al
 8116      FFFF
 8117 6607 751D     		jne	.L411
1786:main.c        **** 							{
1787:main.c        **** 								k--; 
 8118              		.loc 1 1787 0
 8119 6609 83ADC8F2 		subl	$1, -3384(%rbp)
 8119      FFFF01
1788:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 8120              		.loc 1 1788 0
 8121 6610 BF000000 		movl	$.LC155, %edi
 8121      00
 8122 6615 E8000000 		call	puts
 8122      00
1789:main.c        **** 								breaker++;
 8123              		.loc 1 1789 0
 8124 661a 83853CF3 		addl	$1, -3268(%rbp)
 8124      FFFF01
1790:main.c        **** 								break;
 8125              		.loc 1 1790 0
 8126 6621 E9880200 		jmp	.L401
 8126      00
 8127              	.L411:
1791:main.c        **** 							}
1792:main.c        **** 						delay(del);
 8128              		.loc 1 1792 0
 8129 6626 8B85B0F3 		movl	-3152(%rbp), %eax
 8129      FFFF
 8130 662c 89C7     		movl	%eax, %edi
 8131 662e E8000000 		call	delay
 8131      00
1793:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again2[3], &error);
 8132              		.loc 1 1793 0
 8133 6633 8B85C8F2 		movl	-3384(%rbp), %eax
 8133      FFFF
 8134 6639 01C0     		addl	%eax, %eax
 8135 663b 0FB6F0   		movzbl	%al, %esi
 8136 663e 488B85E0 		movq	-3104(%rbp), %rax
 8136      F3FFFF
 8137 6645 488D8DE8 		leaq	-3096(%rbp), %rcx
 8137      F3FFFF
 8138 664c 488D55D0 		leaq	-48(%rbp), %rdx
 8139 6650 4883C203 		addq	$3, %rdx
 8140 6654 4989C8   		movq	%rcx, %r8
 8141 6657 4889D1   		movq	%rdx, %rcx
 8142 665a BA010000 		movl	$1, %edx
 8142      00
 8143 665f 4889C7   		movq	%rax, %rdi
 8144 6662 E8000000 		call	flReadChannelAsyncSubmit
 8144      00
 8145 6667 8985BCF2 		movl	%eax, -3396(%rbp)
 8145      FFFF
1794:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8146              		.loc 1 1794 0
 8147 666d 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8147      FFFF00
 8148 6674 740F     		je	.L412
 8149              		.loc 1 1794 0 is_stmt 0 discriminator 1
 8150 6676 C785B8F2 		movl	$1, -3400(%rbp)
 8150      FFFF0100 
 8150      0000
 8151 6680 E9380200 		jmp	.L403
 8151      00
 8152              	.L412:
1795:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 8153              		.loc 1 1795 0 is_stmt 1
 8154 6685 488B85E0 		movq	-3104(%rbp), %rax
 8154      F3FFFF
 8155 668c 488DBDE8 		leaq	-3096(%rbp), %rdi
 8155      F3FFFF
 8156 6693 488D8DB4 		leaq	-3404(%rbp), %rcx
 8156      F2FFFF
 8157 669a 488D95B4 		leaq	-3404(%rbp), %rdx
 8157      F2FFFF
 8158 66a1 488DB5F0 		leaq	-3088(%rbp), %rsi
 8158      F3FFFF
 8159 66a8 4989F8   		movq	%rdi, %r8
 8160 66ab 4889C7   		movq	%rax, %rdi
 8161 66ae E8000000 		call	flReadChannelAsyncAwait
 8161      00
 8162 66b3 8985BCF2 		movl	%eax, -3396(%rbp)
 8162      FFFF
1796:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8163              		.loc 1 1796 0
 8164 66b9 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8164      FFFF00
 8165 66c0 740F     		je	.L413
 8166              		.loc 1 1796 0 is_stmt 0 discriminator 1
 8167 66c2 C785B8F2 		movl	$1, -3400(%rbp)
 8167      FFFF0100 
 8167      0000
 8168 66cc E9EC0100 		jmp	.L403
 8168      00
 8169              	.L413:
1797:main.c        **** 						if(encrypted_ack1_again2[3] == reset) 
 8170              		.loc 1 1797 0 is_stmt 1
 8171 66d1 0FB645D3 		movzbl	-45(%rbp), %eax
 8172 66d5 3A85AFF2 		cmpb	-3409(%rbp), %al
 8172      FFFF
 8173 66db 751D     		jne	.L414
1798:main.c        **** 							{
1799:main.c        **** 								k--; 
 8174              		.loc 1 1799 0
 8175 66dd 83ADC8F2 		subl	$1, -3384(%rbp)
 8175      FFFF01
1800:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 8176              		.loc 1 1800 0
 8177 66e4 BF000000 		movl	$.LC155, %edi
 8177      00
 8178 66e9 E8000000 		call	puts
 8178      00
1801:main.c        **** 								breaker++; 
 8179              		.loc 1 1801 0
 8180 66ee 83853CF3 		addl	$1, -3268(%rbp)
 8180      FFFF01
1802:main.c        **** 								break;
 8181              		.loc 1 1802 0
 8182 66f5 E9B40100 		jmp	.L401
 8182      00
 8183              	.L414:
1803:main.c        **** 							}
1804:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8184              		.loc 1 1804 0
 8185 66fa 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8185      FFFF00
 8186 6701 740F     		je	.L415
 8187              		.loc 1 1804 0 is_stmt 0 discriminator 1
 8188 6703 C785B8F2 		movl	$1, -3400(%rbp)
 8188      FFFF0100 
 8188      0000
 8189 670d E9AB0100 		jmp	.L403
 8189      00
 8190              	.L415:
1805:main.c        **** 						printf("%s\n", "Ack1 received successfully, not checked yet, it is as----");
 8191              		.loc 1 1805 0 is_stmt 1
 8192 6712 BF000000 		movl	$.LC215, %edi
 8192      00
 8193 6717 E8000000 		call	puts
 8193      00
 8194              	.LBB80:
1806:main.c        **** 						for (int i = 0; i < 4; ++i)
 8195              		.loc 1 1806 0
 8196 671c C78544F3 		movl	$0, -3260(%rbp)
 8196      FFFF0000 
 8196      0000
 8197 6726 EB28     		jmp	.L416
 8198              	.L417:
1807:main.c        **** 						{
1808:main.c        **** 							printf("%d ", encrypted_ack1_again2[i]);
 8199              		.loc 1 1808 0 discriminator 3
 8200 6728 8B8544F3 		movl	-3260(%rbp), %eax
 8200      FFFF
 8201 672e 4898     		cltq
 8202 6730 0FB64405 		movzbl	-48(%rbp,%rax), %eax
 8202      D0
 8203 6735 0FB6C0   		movzbl	%al, %eax
 8204 6738 89C6     		movl	%eax, %esi
 8205 673a BF000000 		movl	$.LC10, %edi
 8205      00
 8206 673f B8000000 		movl	$0, %eax
 8206      00
 8207 6744 E8000000 		call	printf
 8207      00
1806:main.c        **** 						for (int i = 0; i < 4; ++i)
 8208              		.loc 1 1806 0 discriminator 3
 8209 6749 838544F3 		addl	$1, -3260(%rbp)
 8209      FFFF01
 8210              	.L416:
1806:main.c        **** 						for (int i = 0; i < 4; ++i)
 8211              		.loc 1 1806 0 is_stmt 0 discriminator 1
 8212 6750 83BD44F3 		cmpl	$3, -3260(%rbp)
 8212      FFFF03
 8213 6757 7ECF     		jle	.L417
 8214              	.LBE80:
1809:main.c        **** 						}
1810:main.c        **** 						printf("\n");
 8215              		.loc 1 1810 0 is_stmt 1
 8216 6759 BF0A0000 		movl	$10, %edi
 8216      00
 8217 675e E8000000 		call	putchar
 8217      00
1811:main.c        **** 						int encrypted_ack1_again2_int[32];
1812:main.c        **** 						printf("%s\n", "Converting encrypted ack1 from uint8 to binary");
 8218              		.loc 1 1812 0
 8219 6763 BF000000 		movl	$.LC174, %edi
 8219      00
 8220 6768 E8000000 		call	puts
 8220      00
1813:main.c        **** 						uint8ToBin(encrypted_ack1_again2, encrypted_ack1_again2_int);
 8221              		.loc 1 1813 0
 8222 676d 488D95D0 		leaq	-816(%rbp), %rdx
 8222      FCFFFF
 8223 6774 488D45D0 		leaq	-48(%rbp), %rax
 8224 6778 4889D6   		movq	%rdx, %rsi
 8225 677b 4889C7   		movq	%rax, %rdi
 8226 677e E8000000 		call	uint8ToBin
 8226      00
1814:main.c        **** 						printf("%s\n", "Converted encrypted ack1 from uint8 to binary , it is as --");
 8227              		.loc 1 1814 0
 8228 6783 BF000000 		movl	$.LC216, %edi
 8228      00
 8229 6788 E8000000 		call	puts
 8229      00
 8230              	.LBB81:
1815:main.c        **** 						for (int i = 0; i < 32; ++i)
 8231              		.loc 1 1815 0
 8232 678d C78548F3 		movl	$0, -3256(%rbp)
 8232      FFFF0000 
 8232      0000
 8233 6797 EB27     		jmp	.L418
 8234              	.L419:
1816:main.c        **** 						{
1817:main.c        **** 							printf("%d ", encrypted_ack1_again2_int[i]);
 8235              		.loc 1 1817 0 discriminator 3
 8236 6799 8B8548F3 		movl	-3256(%rbp), %eax
 8236      FFFF
 8237 679f 4898     		cltq
 8238 67a1 8B8485D0 		movl	-816(%rbp,%rax,4), %eax
 8238      FCFFFF
 8239 67a8 89C6     		movl	%eax, %esi
 8240 67aa BF000000 		movl	$.LC10, %edi
 8240      00
 8241 67af B8000000 		movl	$0, %eax
 8241      00
 8242 67b4 E8000000 		call	printf
 8242      00
1815:main.c        **** 						for (int i = 0; i < 32; ++i)
 8243              		.loc 1 1815 0 discriminator 3
 8244 67b9 838548F3 		addl	$1, -3256(%rbp)
 8244      FFFF01
 8245              	.L418:
1815:main.c        **** 						for (int i = 0; i < 32; ++i)
 8246              		.loc 1 1815 0 is_stmt 0 discriminator 1
 8247 67c0 83BD48F3 		cmpl	$31, -3256(%rbp)
 8247      FFFF1F
 8248 67c7 7ED0     		jle	.L419
 8249              	.LBE81:
1818:main.c        **** 						}
1819:main.c        **** 						printf("\n");
 8250              		.loc 1 1819 0 is_stmt 1
 8251 67c9 BF0A0000 		movl	$10, %edi
 8251      00
 8252 67ce E8000000 		call	putchar
 8252      00
1820:main.c        **** 						int decrypted_ack1_again2_int[32];
1821:main.c        **** 						printf("%s\n", "Decrypting the encrypted ack1");
 8253              		.loc 1 1821 0
 8254 67d3 BF000000 		movl	$.LC217, %edi
 8254      00
 8255 67d8 E8000000 		call	puts
 8255      00
1822:main.c        **** 						decrypter(encrypted_ack1_again2_int, K, decrypted_ack1_again2_int);
 8256              		.loc 1 1822 0
 8257 67dd 488D9550 		leaq	-688(%rbp), %rdx
 8257      FDFFFF
 8258 67e4 488D8DD0 		leaq	-2608(%rbp), %rcx
 8258      F5FFFF
 8259 67eb 488D85D0 		leaq	-816(%rbp), %rax
 8259      FCFFFF
 8260 67f2 4889CE   		movq	%rcx, %rsi
 8261 67f5 4889C7   		movq	%rax, %rdi
 8262 67f8 E8000000 		call	decrypter
 8262      00
1823:main.c        **** 						printf("%s\n", "Encrypted ack1 decrypted successfully, it is as----");
 8263              		.loc 1 1823 0
 8264 67fd BF000000 		movl	$.LC218, %edi
 8264      00
 8265 6802 E8000000 		call	puts
 8265      00
 8266              	.LBB82:
1824:main.c        **** 						for (int i = 0; i < 32; ++i)
 8267              		.loc 1 1824 0
 8268 6807 C7854CF3 		movl	$0, -3252(%rbp)
 8268      FFFF0000 
 8268      0000
 8269 6811 EB27     		jmp	.L420
 8270              	.L421:
1825:main.c        **** 						{
1826:main.c        **** 							printf("%d ", decrypted_ack1_again2_int[i]);
 8271              		.loc 1 1826 0 discriminator 3
 8272 6813 8B854CF3 		movl	-3252(%rbp), %eax
 8272      FFFF
 8273 6819 4898     		cltq
 8274 681b 8B848550 		movl	-688(%rbp,%rax,4), %eax
 8274      FDFFFF
 8275 6822 89C6     		movl	%eax, %esi
 8276 6824 BF000000 		movl	$.LC10, %edi
 8276      00
 8277 6829 B8000000 		movl	$0, %eax
 8277      00
 8278 682e E8000000 		call	printf
 8278      00
1824:main.c        **** 						for (int i = 0; i < 32; ++i)
 8279              		.loc 1 1824 0 discriminator 3
 8280 6833 83854CF3 		addl	$1, -3252(%rbp)
 8280      FFFF01
 8281              	.L420:
1824:main.c        **** 						for (int i = 0; i < 32; ++i)
 8282              		.loc 1 1824 0 is_stmt 0 discriminator 1
 8283 683a 83BD4CF3 		cmpl	$31, -3252(%rbp)
 8283      FFFF1F
 8284 6841 7ED0     		jle	.L421
 8285              	.LBE82:
1827:main.c        **** 						}
1828:main.c        **** 						printf("\n");
 8286              		.loc 1 1828 0 is_stmt 1
 8287 6843 BF0A0000 		movl	$10, %edi
 8287      00
 8288 6848 E8000000 		call	putchar
 8288      00
 8289              	.LBB83:
1829:main.c        **** 						for(int i=0; i<32; i++)
 8290              		.loc 1 1829 0
 8291 684d C78550F3 		movl	$0, -3248(%rbp)
 8291      FFFF0000 
 8291      0000
 8292 6857 EB3D     		jmp	.L422
 8293              	.L424:
1830:main.c        **** 						{
1831:main.c        **** 							if(decrypted_ack1_again2_int[i] != ack1[i])
 8294              		.loc 1 1831 0
 8295 6859 8B8550F3 		movl	-3248(%rbp), %eax
 8295      FFFF
 8296 685f 4898     		cltq
 8297 6861 8B948550 		movl	-688(%rbp,%rax,4), %edx
 8297      FDFFFF
 8298 6868 8B8550F3 		movl	-3248(%rbp), %eax
 8298      FFFF
 8299 686e 4898     		cltq
 8300 6870 8B848550 		movl	-2480(%rbp,%rax,4), %eax
 8300      F6FFFF
 8301 6877 39C2     		cmpl	%eax, %edx
 8302 6879 7414     		je	.L423
1832:main.c        **** 							{
1833:main.c        **** 								arb = 1;
 8303              		.loc 1 1833 0
 8304 687b C78540F3 		movl	$1, -3264(%rbp)
 8304      FFFF0100 
 8304      0000
1834:main.c        **** 								printf("%s\n", "Ack1 doesn't match");
 8305              		.loc 1 1834 0
 8306 6885 BF000000 		movl	$.LC219, %edi
 8306      00
 8307 688a E8000000 		call	puts
 8307      00
 8308              	.L423:
1829:main.c        **** 						{
 8309              		.loc 1 1829 0 discriminator 2
 8310 688f 838550F3 		addl	$1, -3248(%rbp)
 8310      FFFF01
 8311              	.L422:
1829:main.c        **** 						{
 8312              		.loc 1 1829 0 is_stmt 0 discriminator 1
 8313 6896 83BD50F3 		cmpl	$31, -3248(%rbp)
 8313      FFFF1F
 8314 689d 7EBA     		jle	.L424
 8315              	.LBE83:
1835:main.c        **** 
1836:main.c        **** 							}
1837:main.c        **** 						}
1838:main.c        **** 						if(arb == 0)
 8316              		.loc 1 1838 0 is_stmt 1
 8317 689f 83BD40F3 		cmpl	$0, -3264(%rbp)
 8317      FFFF00
 8318 68a6 7405     		je	.L522
 8319              	.LBE79:
1839:main.c        **** 							break;
1840:main.c        **** 					}
 8320              		.loc 1 1840 0
 8321 68a8 E991FAFF 		jmp	.L426
 8321      FF
 8322              	.L522:
 8323              	.LBB84:
1839:main.c        **** 							break;
 8324              		.loc 1 1839 0
 8325 68ad 90       		nop
 8326              	.L401:
 8327              	.LBE84:
1841:main.c        **** 
1842:main.c        **** 					if(breaker>=1) continue;
 8328              		.loc 1 1842 0
 8329 68ae 83BD3CF3 		cmpl	$0, -3268(%rbp)
 8329      FFFF00
 8330 68b5 0F8FEA14 		jg	.L523
 8330      0000
 8331 68bb EB05     		jmp	.L518
 8332              	.L403:
 8333              	.LBE102:
 8334              	.LBE106:
 8335              	.LBE110:
1294:main.c        **** 			fStatus = flIsFPGARunning(handle, &isRunning, &error);
 8336              		.loc 1 1294 0 discriminator 2
 8337 68bd E95E1500 		jmp	.L230
 8337      00
 8338              	.L518:
 8339              	.LBB111:
 8340              	.LBB107:
 8341              	.LBB103:
1843:main.c        **** 
1844:main.c        **** 					if(arb3 == 1)
 8342              		.loc 1 1844 0
 8343 68c2 83BD38F3 		cmpl	$1, -3272(%rbp)
 8343      FFFF01
 8344 68c9 0F84D914 		je	.L524
 8344      0000
1845:main.c        **** 					{
1846:main.c        **** 						continue;
1847:main.c        **** 					}
1848:main.c        **** 
1849:main.c        **** 					printf("%s\n", "Ack1 match successfully");
 8345              		.loc 1 1849 0
 8346 68cf BF000000 		movl	$.LC220, %edi
 8346      00
 8347 68d4 E8000000 		call	puts
 8347      00
1850:main.c        **** 
1851:main.c        **** 					printf("%s\n", "encrypting last 32 bits to send to fpga ");
 8348              		.loc 1 1851 0
 8349 68d9 BF000000 		movl	$.LC221, %edi
 8349      00
 8350 68de E8000000 		call	puts
 8350      00
1852:main.c        **** 
1853:main.c        **** 					encrypter(p2, K, bin2);
 8351              		.loc 1 1853 0
 8352 68e3 488D95D0 		leaq	-1072(%rbp), %rdx
 8352      FBFFFF
 8353 68ea 488D8DD0 		leaq	-2608(%rbp), %rcx
 8353      F5FFFF
 8354 68f1 488D85D0 		leaq	-1328(%rbp), %rax
 8354      FAFFFF
 8355 68f8 4889CE   		movq	%rcx, %rsi
 8356 68fb 4889C7   		movq	%rax, %rdi
 8357 68fe E8000000 		call	encrypter
 8357      00
1854:main.c        **** 
1855:main.c        **** 					printf("%s\n", "Last 32 bits got encrypted , they are as in binary form");
 8358              		.loc 1 1855 0
 8359 6903 BF000000 		movl	$.LC222, %edi
 8359      00
 8360 6908 E8000000 		call	puts
 8360      00
 8361              	.LBB85:
1856:main.c        **** 					for (int i = 0; i < 32; ++i)
 8362              		.loc 1 1856 0
 8363 690d C78554F3 		movl	$0, -3244(%rbp)
 8363      FFFF0000 
 8363      0000
 8364 6917 EB27     		jmp	.L430
 8365              	.L431:
1857:main.c        **** 					{
1858:main.c        **** 						printf("%d ", bin2[i]);
 8366              		.loc 1 1858 0 discriminator 3
 8367 6919 8B8554F3 		movl	-3244(%rbp), %eax
 8367      FFFF
 8368 691f 4898     		cltq
 8369 6921 8B8485D0 		movl	-1072(%rbp,%rax,4), %eax
 8369      FBFFFF
 8370 6928 89C6     		movl	%eax, %esi
 8371 692a BF000000 		movl	$.LC10, %edi
 8371      00
 8372 692f B8000000 		movl	$0, %eax
 8372      00
 8373 6934 E8000000 		call	printf
 8373      00
1856:main.c        **** 					for (int i = 0; i < 32; ++i)
 8374              		.loc 1 1856 0 discriminator 3
 8375 6939 838554F3 		addl	$1, -3244(%rbp)
 8375      FFFF01
 8376              	.L430:
1856:main.c        **** 					for (int i = 0; i < 32; ++i)
 8377              		.loc 1 1856 0 is_stmt 0 discriminator 1
 8378 6940 83BD54F3 		cmpl	$31, -3244(%rbp)
 8378      FFFF1F
 8379 6947 7ED0     		jle	.L431
 8380              	.LBE85:
1859:main.c        **** 					}
1860:main.c        **** 
1861:main.c        **** 					uint8 last32_bitsTosend[4];
1862:main.c        **** 					printf("%s\n", "Converting last 32 bits to uint8");
 8381              		.loc 1 1862 0 is_stmt 1
 8382 6949 BF000000 		movl	$.LC223, %edi
 8382      00
 8383 694e E8000000 		call	puts
 8383      00
1863:main.c        **** 					BinTouint8(last32_bitsTosend, bin2);
 8384              		.loc 1 1863 0
 8385 6953 488D95D0 		leaq	-1072(%rbp), %rdx
 8385      FBFFFF
 8386 695a 488D45B0 		leaq	-80(%rbp), %rax
 8387 695e 4889D6   		movq	%rdx, %rsi
 8388 6961 4889C7   		movq	%rax, %rdi
 8389 6964 E8000000 		call	BinTouint8
 8389      00
1864:main.c        **** 					printf("%s\n", "Last 32 bits got converted to uint8, they are as");
 8390              		.loc 1 1864 0
 8391 6969 BF000000 		movl	$.LC224, %edi
 8391      00
 8392 696e E8000000 		call	puts
 8392      00
 8393              	.LBB86:
1865:main.c        **** 					for (int i = 0; i < 4; ++i)
 8394              		.loc 1 1865 0
 8395 6973 C78558F3 		movl	$0, -3240(%rbp)
 8395      FFFF0000 
 8395      0000
 8396 697d EB28     		jmp	.L432
 8397              	.L433:
1866:main.c        **** 					{
1867:main.c        **** 						printf("%d ", last32_bitsTosend[i]);
 8398              		.loc 1 1867 0 discriminator 3
 8399 697f 8B8558F3 		movl	-3240(%rbp), %eax
 8399      FFFF
 8400 6985 4898     		cltq
 8401 6987 0FB64405 		movzbl	-80(%rbp,%rax), %eax
 8401      B0
 8402 698c 0FB6C0   		movzbl	%al, %eax
 8403 698f 89C6     		movl	%eax, %esi
 8404 6991 BF000000 		movl	$.LC10, %edi
 8404      00
 8405 6996 B8000000 		movl	$0, %eax
 8405      00
 8406 699b E8000000 		call	printf
 8406      00
1865:main.c        **** 					for (int i = 0; i < 4; ++i)
 8407              		.loc 1 1865 0 discriminator 3
 8408 69a0 838558F3 		addl	$1, -3240(%rbp)
 8408      FFFF01
 8409              	.L432:
1865:main.c        **** 					for (int i = 0; i < 4; ++i)
 8410              		.loc 1 1865 0 is_stmt 0 discriminator 1
 8411 69a7 83BD58F3 		cmpl	$3, -3240(%rbp)
 8411      FFFF03
 8412 69ae 7ECF     		jle	.L433
 8413              	.LBE86:
1868:main.c        **** 					}
1869:main.c        **** 					printf("\n");
 8414              		.loc 1 1869 0 is_stmt 1
 8415 69b0 BF0A0000 		movl	$10, %edi
 8415      00
 8416 69b5 E8000000 		call	putchar
 8416      00
1870:main.c        **** 					printf("%s\n", "Writing on channel last 32 bits encrypted");
 8417              		.loc 1 1870 0
 8418 69ba BF000000 		movl	$.LC225, %edi
 8418      00
 8419 69bf E8000000 		call	puts
 8419      00
1871:main.c        **** 					delay(del);
 8420              		.loc 1 1871 0
 8421 69c4 8B85B0F3 		movl	-3152(%rbp), %eax
 8421      FFFF
 8422 69ca 89C7     		movl	%eax, %edi
 8423 69cc E8000000 		call	delay
 8423      00
1872:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &last32_bitsTosend[0], &error);
 8424              		.loc 1 1872 0
 8425 69d1 8B85C8F2 		movl	-3384(%rbp), %eax
 8425      FFFF
 8426 69d7 01C0     		addl	%eax, %eax
 8427 69d9 83C001   		addl	$1, %eax
 8428 69dc 0FB6F0   		movzbl	%al, %esi
 8429 69df 488B85E0 		movq	-3104(%rbp), %rax
 8429      F3FFFF
 8430 69e6 488D8DE8 		leaq	-3096(%rbp), %rcx
 8430      F3FFFF
 8431 69ed 488D55B0 		leaq	-80(%rbp), %rdx
 8432 69f1 4989C8   		movq	%rcx, %r8
 8433 69f4 4889D1   		movq	%rdx, %rcx
 8434 69f7 BA010000 		movl	$1, %edx
 8434      00
 8435 69fc 4889C7   		movq	%rax, %rdi
 8436 69ff E8000000 		call	flWriteChannel
 8436      00
 8437 6a04 8985BCF2 		movl	%eax, -3396(%rbp)
 8437      FFFF
1873:main.c        **** 					delay(del);
 8438              		.loc 1 1873 0
 8439 6a0a 8B85B0F3 		movl	-3152(%rbp), %eax
 8439      FFFF
 8440 6a10 89C7     		movl	%eax, %edi
 8441 6a12 E8000000 		call	delay
 8441      00
1874:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &last32_bitsTosend[1], &error);
 8442              		.loc 1 1874 0
 8443 6a17 8B85C8F2 		movl	-3384(%rbp), %eax
 8443      FFFF
 8444 6a1d 01C0     		addl	%eax, %eax
 8445 6a1f 83C001   		addl	$1, %eax
 8446 6a22 0FB6F0   		movzbl	%al, %esi
 8447 6a25 488B85E0 		movq	-3104(%rbp), %rax
 8447      F3FFFF
 8448 6a2c 488D8DE8 		leaq	-3096(%rbp), %rcx
 8448      F3FFFF
 8449 6a33 488D55B0 		leaq	-80(%rbp), %rdx
 8450 6a37 4883C201 		addq	$1, %rdx
 8451 6a3b 4989C8   		movq	%rcx, %r8
 8452 6a3e 4889D1   		movq	%rdx, %rcx
 8453 6a41 BA010000 		movl	$1, %edx
 8453      00
 8454 6a46 4889C7   		movq	%rax, %rdi
 8455 6a49 E8000000 		call	flWriteChannel
 8455      00
 8456 6a4e 8985BCF2 		movl	%eax, -3396(%rbp)
 8456      FFFF
1875:main.c        **** 					delay(del);
 8457              		.loc 1 1875 0
 8458 6a54 8B85B0F3 		movl	-3152(%rbp), %eax
 8458      FFFF
 8459 6a5a 89C7     		movl	%eax, %edi
 8460 6a5c E8000000 		call	delay
 8460      00
1876:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &last32_bitsTosend[2], &error);
 8461              		.loc 1 1876 0
 8462 6a61 8B85C8F2 		movl	-3384(%rbp), %eax
 8462      FFFF
 8463 6a67 01C0     		addl	%eax, %eax
 8464 6a69 83C001   		addl	$1, %eax
 8465 6a6c 0FB6F0   		movzbl	%al, %esi
 8466 6a6f 488B85E0 		movq	-3104(%rbp), %rax
 8466      F3FFFF
 8467 6a76 488D8DE8 		leaq	-3096(%rbp), %rcx
 8467      F3FFFF
 8468 6a7d 488D55B0 		leaq	-80(%rbp), %rdx
 8469 6a81 4883C202 		addq	$2, %rdx
 8470 6a85 4989C8   		movq	%rcx, %r8
 8471 6a88 4889D1   		movq	%rdx, %rcx
 8472 6a8b BA010000 		movl	$1, %edx
 8472      00
 8473 6a90 4889C7   		movq	%rax, %rdi
 8474 6a93 E8000000 		call	flWriteChannel
 8474      00
 8475 6a98 8985BCF2 		movl	%eax, -3396(%rbp)
 8475      FFFF
1877:main.c        **** 					delay(del);
 8476              		.loc 1 1877 0
 8477 6a9e 8B85B0F3 		movl	-3152(%rbp), %eax
 8477      FFFF
 8478 6aa4 89C7     		movl	%eax, %edi
 8479 6aa6 E8000000 		call	delay
 8479      00
1878:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &last32_bitsTosend[3], &error);
 8480              		.loc 1 1878 0
 8481 6aab 8B85C8F2 		movl	-3384(%rbp), %eax
 8481      FFFF
 8482 6ab1 01C0     		addl	%eax, %eax
 8483 6ab3 83C001   		addl	$1, %eax
 8484 6ab6 0FB6F0   		movzbl	%al, %esi
 8485 6ab9 488B85E0 		movq	-3104(%rbp), %rax
 8485      F3FFFF
 8486 6ac0 488D8DE8 		leaq	-3096(%rbp), %rcx
 8486      F3FFFF
 8487 6ac7 488D55B0 		leaq	-80(%rbp), %rdx
 8488 6acb 4883C203 		addq	$3, %rdx
 8489 6acf 4989C8   		movq	%rcx, %r8
 8490 6ad2 4889D1   		movq	%rdx, %rcx
 8491 6ad5 BA010000 		movl	$1, %edx
 8491      00
 8492 6ada 4889C7   		movq	%rax, %rdi
 8493 6add E8000000 		call	flWriteChannel
 8493      00
 8494 6ae2 8985BCF2 		movl	%eax, -3396(%rbp)
 8494      FFFF
1879:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8495              		.loc 1 1879 0
 8496 6ae8 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8496      FFFF00
 8497 6aef 740F     		je	.L434
 8498              		.loc 1 1879 0 is_stmt 0 discriminator 1
 8499 6af1 C785B8F2 		movl	$1, -3400(%rbp)
 8499      FFFF0100 
 8499      0000
 8500 6afb E9201300 		jmp	.L230
 8500      00
 8501              	.L434:
1880:main.c        **** 					printf("%s\n", "Successfully written last 32 bits");
 8502              		.loc 1 1880 0 is_stmt 1
 8503 6b00 BF000000 		movl	$.LC226, %edi
 8503      00
 8504 6b05 E8000000 		call	puts
 8504      00
1881:main.c        **** 
1882:main.c        **** 					printf("%s\n", "---------------------------------H7 ends---------------------");
 8505              		.loc 1 1882 0
 8506 6b0a BF000000 		movl	$.LC227, %edi
 8506      00
 8507 6b0f E8000000 		call	puts
 8507      00
1883:main.c        **** 
1884:main.c        **** 					time_t startTime2, endTime2;
1885:main.c        **** 					double diff2;
1886:main.c        **** 					time(&startTime2);
 8508              		.loc 1 1886 0
 8509 6b14 488D8508 		leaq	-3064(%rbp), %rax
 8509      F4FFFF
 8510 6b1b 4889C7   		movq	%rax, %rdi
 8511 6b1e E8000000 		call	time
 8511      00
1887:main.c        **** 
1888:main.c        **** 					int breaker2 = 0;
 8512              		.loc 1 1888 0
 8513 6b23 C7855CF3 		movl	$0, -3236(%rbp)
 8513      FFFF0000 
 8513      0000
 8514              	.L465:
 8515              	.LBB87:
1889:main.c        **** 					while(true)
1890:main.c        **** 					{
1891:main.c        **** 						time(&endTime2);
 8516              		.loc 1 1891 0
 8517 6b2d 488D8510 		leaq	-3056(%rbp), %rax
 8517      F4FFFF
 8518 6b34 4889C7   		movq	%rax, %rdi
 8519 6b37 E8000000 		call	time
 8519      00
1892:main.c        **** 						diff2 = difftime(endTime2, startTime2);
 8520              		.loc 1 1892 0
 8521 6b3c 488B9508 		movq	-3064(%rbp), %rdx
 8521      F4FFFF
 8522 6b43 488B8510 		movq	-3056(%rbp), %rax
 8522      F4FFFF
 8523 6b4a 4889D6   		movq	%rdx, %rsi
 8524 6b4d 4889C7   		movq	%rax, %rdi
 8525 6b50 E8000000 		call	difftime
 8525      00
 8526 6b55 66480F7E 		movq	%xmm0, %rax
 8526      C0
 8527 6b5a 488985E8 		movq	%rax, -2840(%rbp)
 8527      F4FFFF
1893:main.c        **** 						if(diff2 > 256)
 8528              		.loc 1 1893 0
 8529 6b61 F20F1085 		movsd	-2840(%rbp), %xmm0
 8529      E8F4FFFF 
 8530 6b69 660F2E05 		ucomisd	.LC213(%rip), %xmm0
 8530      00000000 
 8531 6b71 7613     		jbe	.L519
1894:main.c        **** 						{
1895:main.c        **** 							printf("%s\n", "Going to H2, time exceeded 256 seconds");
 8532              		.loc 1 1895 0
 8533 6b73 BF000000 		movl	$.LC214, %edi
 8533      00
 8534 6b78 E8000000 		call	puts
 8534      00
1896:main.c        **** 							k = k-1;
 8535              		.loc 1 1896 0
 8536 6b7d 83ADC8F2 		subl	$1, -3384(%rbp)
 8536      FFFF01
 8537 6b84 EBA7     		jmp	.L465
 8538              	.L519:
1897:main.c        **** 							continue;
1898:main.c        **** 						}
1899:main.c        **** 						int arb2 = 0;
 8539              		.loc 1 1899 0
 8540 6b86 C78560F3 		movl	$0, -3232(%rbp)
 8540      FFFF0000 
 8540      0000
1900:main.c        **** 						uint8 encrypted_ack1_again3[4];
1901:main.c        **** 						delay(del);
 8541              		.loc 1 1901 0
 8542 6b90 8B85B0F3 		movl	-3152(%rbp), %eax
 8542      FFFF
 8543 6b96 89C7     		movl	%eax, %edi
 8544 6b98 E8000000 		call	delay
 8544      00
1902:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again3[0], &error);
 8545              		.loc 1 1902 0
 8546 6b9d 8B85C8F2 		movl	-3384(%rbp), %eax
 8546      FFFF
 8547 6ba3 01C0     		addl	%eax, %eax
 8548 6ba5 0FB6F0   		movzbl	%al, %esi
 8549 6ba8 488B85E0 		movq	-3104(%rbp), %rax
 8549      F3FFFF
 8550 6baf 488D8DE8 		leaq	-3096(%rbp), %rcx
 8550      F3FFFF
 8551 6bb6 488D55D0 		leaq	-48(%rbp), %rdx
 8552 6bba 4989C8   		movq	%rcx, %r8
 8553 6bbd 4889D1   		movq	%rdx, %rcx
 8554 6bc0 BA010000 		movl	$1, %edx
 8554      00
 8555 6bc5 4889C7   		movq	%rax, %rdi
 8556 6bc8 E8000000 		call	flReadChannelAsyncSubmit
 8556      00
 8557 6bcd 8985BCF2 		movl	%eax, -3396(%rbp)
 8557      FFFF
1903:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8558              		.loc 1 1903 0
 8559 6bd3 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8559      FFFF00
 8560 6bda 740F     		je	.L438
 8561              		.loc 1 1903 0 is_stmt 0 discriminator 1
 8562 6bdc C785B8F2 		movl	$1, -3400(%rbp)
 8562      FFFF0100 
 8562      0000
 8563 6be6 E9351200 		jmp	.L230
 8563      00
 8564              	.L438:
1904:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 8565              		.loc 1 1904 0 is_stmt 1
 8566 6beb 488B85E0 		movq	-3104(%rbp), %rax
 8566      F3FFFF
 8567 6bf2 488DBDE8 		leaq	-3096(%rbp), %rdi
 8567      F3FFFF
 8568 6bf9 488D8DB4 		leaq	-3404(%rbp), %rcx
 8568      F2FFFF
 8569 6c00 488D95B4 		leaq	-3404(%rbp), %rdx
 8569      F2FFFF
 8570 6c07 488DB5F0 		leaq	-3088(%rbp), %rsi
 8570      F3FFFF
 8571 6c0e 4989F8   		movq	%rdi, %r8
 8572 6c11 4889C7   		movq	%rax, %rdi
 8573 6c14 E8000000 		call	flReadChannelAsyncAwait
 8573      00
 8574 6c19 8985BCF2 		movl	%eax, -3396(%rbp)
 8574      FFFF
1905:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8575              		.loc 1 1905 0
 8576 6c1f 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8576      FFFF00
 8577 6c26 740F     		je	.L440
 8578              		.loc 1 1905 0 is_stmt 0 discriminator 1
 8579 6c28 C785B8F2 		movl	$1, -3400(%rbp)
 8579      FFFF0100 
 8579      0000
 8580 6c32 E9590400 		jmp	.L439
 8580      00
 8581              	.L440:
1906:main.c        **** 						if(encrypted_ack1_again3[0] == reset) 
 8582              		.loc 1 1906 0 is_stmt 1
 8583 6c37 0FB645D0 		movzbl	-48(%rbp), %eax
 8584 6c3b 3A85AFF2 		cmpb	-3409(%rbp), %al
 8584      FFFF
 8585 6c41 751D     		jne	.L441
1907:main.c        **** 							{
1908:main.c        **** 								k--; 
 8586              		.loc 1 1908 0
 8587 6c43 83ADC8F2 		subl	$1, -3384(%rbp)
 8587      FFFF01
1909:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 8588              		.loc 1 1909 0
 8589 6c4a BF000000 		movl	$.LC155, %edi
 8589      00
 8590 6c4f E8000000 		call	puts
 8590      00
1910:main.c        **** 								breaker2++; 
 8591              		.loc 1 1910 0
 8592 6c54 83855CF3 		addl	$1, -3236(%rbp)
 8592      FFFF01
1911:main.c        **** 								break;
 8593              		.loc 1 1911 0
 8594 6c5b E9350400 		jmp	.L442
 8594      00
 8595              	.L441:
1912:main.c        **** 							}
1913:main.c        **** 						delay(del);
 8596              		.loc 1 1913 0
 8597 6c60 8B85B0F3 		movl	-3152(%rbp), %eax
 8597      FFFF
 8598 6c66 89C7     		movl	%eax, %edi
 8599 6c68 E8000000 		call	delay
 8599      00
1914:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again3[1], &error);
 8600              		.loc 1 1914 0
 8601 6c6d 8B85C8F2 		movl	-3384(%rbp), %eax
 8601      FFFF
 8602 6c73 01C0     		addl	%eax, %eax
 8603 6c75 0FB6F0   		movzbl	%al, %esi
 8604 6c78 488B85E0 		movq	-3104(%rbp), %rax
 8604      F3FFFF
 8605 6c7f 488D8DE8 		leaq	-3096(%rbp), %rcx
 8605      F3FFFF
 8606 6c86 488D55D0 		leaq	-48(%rbp), %rdx
 8607 6c8a 4883C201 		addq	$1, %rdx
 8608 6c8e 4989C8   		movq	%rcx, %r8
 8609 6c91 4889D1   		movq	%rdx, %rcx
 8610 6c94 BA010000 		movl	$1, %edx
 8610      00
 8611 6c99 4889C7   		movq	%rax, %rdi
 8612 6c9c E8000000 		call	flReadChannelAsyncSubmit
 8612      00
 8613 6ca1 8985BCF2 		movl	%eax, -3396(%rbp)
 8613      FFFF
1915:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8614              		.loc 1 1915 0
 8615 6ca7 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8615      FFFF00
 8616 6cae 740F     		je	.L443
 8617              		.loc 1 1915 0 is_stmt 0 discriminator 1
 8618 6cb0 C785B8F2 		movl	$1, -3400(%rbp)
 8618      FFFF0100 
 8618      0000
 8619 6cba E9D10300 		jmp	.L439
 8619      00
 8620              	.L443:
1916:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 8621              		.loc 1 1916 0 is_stmt 1
 8622 6cbf 488B85E0 		movq	-3104(%rbp), %rax
 8622      F3FFFF
 8623 6cc6 488DBDE8 		leaq	-3096(%rbp), %rdi
 8623      F3FFFF
 8624 6ccd 488D8DB4 		leaq	-3404(%rbp), %rcx
 8624      F2FFFF
 8625 6cd4 488D95B4 		leaq	-3404(%rbp), %rdx
 8625      F2FFFF
 8626 6cdb 488DB5F0 		leaq	-3088(%rbp), %rsi
 8626      F3FFFF
 8627 6ce2 4989F8   		movq	%rdi, %r8
 8628 6ce5 4889C7   		movq	%rax, %rdi
 8629 6ce8 E8000000 		call	flReadChannelAsyncAwait
 8629      00
 8630 6ced 8985BCF2 		movl	%eax, -3396(%rbp)
 8630      FFFF
1917:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8631              		.loc 1 1917 0
 8632 6cf3 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8632      FFFF00
 8633 6cfa 740F     		je	.L444
 8634              		.loc 1 1917 0 is_stmt 0 discriminator 1
 8635 6cfc C785B8F2 		movl	$1, -3400(%rbp)
 8635      FFFF0100 
 8635      0000
 8636 6d06 E9850300 		jmp	.L439
 8636      00
 8637              	.L444:
1918:main.c        **** 						if(encrypted_ack1_again3[1] == reset) 
 8638              		.loc 1 1918 0 is_stmt 1
 8639 6d0b 0FB645D1 		movzbl	-47(%rbp), %eax
 8640 6d0f 3A85AFF2 		cmpb	-3409(%rbp), %al
 8640      FFFF
 8641 6d15 751D     		jne	.L445
1919:main.c        **** 							{
1920:main.c        **** 								k--; 
 8642              		.loc 1 1920 0
 8643 6d17 83ADC8F2 		subl	$1, -3384(%rbp)
 8643      FFFF01
1921:main.c        **** 								breaker2++;
 8644              		.loc 1 1921 0
 8645 6d1e 83855CF3 		addl	$1, -3236(%rbp)
 8645      FFFF01
1922:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------"); 
 8646              		.loc 1 1922 0
 8647 6d25 BF000000 		movl	$.LC155, %edi
 8647      00
 8648 6d2a E8000000 		call	puts
 8648      00
1923:main.c        **** 								break;
 8649              		.loc 1 1923 0
 8650 6d2f E9610300 		jmp	.L442
 8650      00
 8651              	.L445:
1924:main.c        **** 							}
1925:main.c        **** 						delay(del);
 8652              		.loc 1 1925 0
 8653 6d34 8B85B0F3 		movl	-3152(%rbp), %eax
 8653      FFFF
 8654 6d3a 89C7     		movl	%eax, %edi
 8655 6d3c E8000000 		call	delay
 8655      00
1926:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again3[2], &error);
 8656              		.loc 1 1926 0
 8657 6d41 8B85C8F2 		movl	-3384(%rbp), %eax
 8657      FFFF
 8658 6d47 01C0     		addl	%eax, %eax
 8659 6d49 0FB6F0   		movzbl	%al, %esi
 8660 6d4c 488B85E0 		movq	-3104(%rbp), %rax
 8660      F3FFFF
 8661 6d53 488D8DE8 		leaq	-3096(%rbp), %rcx
 8661      F3FFFF
 8662 6d5a 488D55D0 		leaq	-48(%rbp), %rdx
 8663 6d5e 4883C202 		addq	$2, %rdx
 8664 6d62 4989C8   		movq	%rcx, %r8
 8665 6d65 4889D1   		movq	%rdx, %rcx
 8666 6d68 BA010000 		movl	$1, %edx
 8666      00
 8667 6d6d 4889C7   		movq	%rax, %rdi
 8668 6d70 E8000000 		call	flReadChannelAsyncSubmit
 8668      00
 8669 6d75 8985BCF2 		movl	%eax, -3396(%rbp)
 8669      FFFF
1927:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8670              		.loc 1 1927 0
 8671 6d7b 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8671      FFFF00
 8672 6d82 740F     		je	.L446
 8673              		.loc 1 1927 0 is_stmt 0 discriminator 1
 8674 6d84 C785B8F2 		movl	$1, -3400(%rbp)
 8674      FFFF0100 
 8674      0000
 8675 6d8e E9FD0200 		jmp	.L439
 8675      00
 8676              	.L446:
1928:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 8677              		.loc 1 1928 0 is_stmt 1
 8678 6d93 488B85E0 		movq	-3104(%rbp), %rax
 8678      F3FFFF
 8679 6d9a 488DBDE8 		leaq	-3096(%rbp), %rdi
 8679      F3FFFF
 8680 6da1 488D8DB4 		leaq	-3404(%rbp), %rcx
 8680      F2FFFF
 8681 6da8 488D95B4 		leaq	-3404(%rbp), %rdx
 8681      F2FFFF
 8682 6daf 488DB5F0 		leaq	-3088(%rbp), %rsi
 8682      F3FFFF
 8683 6db6 4989F8   		movq	%rdi, %r8
 8684 6db9 4889C7   		movq	%rax, %rdi
 8685 6dbc E8000000 		call	flReadChannelAsyncAwait
 8685      00
 8686 6dc1 8985BCF2 		movl	%eax, -3396(%rbp)
 8686      FFFF
1929:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8687              		.loc 1 1929 0
 8688 6dc7 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8688      FFFF00
 8689 6dce 740F     		je	.L447
 8690              		.loc 1 1929 0 is_stmt 0 discriminator 1
 8691 6dd0 C785B8F2 		movl	$1, -3400(%rbp)
 8691      FFFF0100 
 8691      0000
 8692 6dda E9B10200 		jmp	.L439
 8692      00
 8693              	.L447:
1930:main.c        **** 						if(encrypted_ack1_again3[2] == reset) 
 8694              		.loc 1 1930 0 is_stmt 1
 8695 6ddf 0FB645D2 		movzbl	-46(%rbp), %eax
 8696 6de3 3A85AFF2 		cmpb	-3409(%rbp), %al
 8696      FFFF
 8697 6de9 751D     		jne	.L448
1931:main.c        **** 							{
1932:main.c        **** 								k--; 
 8698              		.loc 1 1932 0
 8699 6deb 83ADC8F2 		subl	$1, -3384(%rbp)
 8699      FFFF01
1933:main.c        **** 								breaker2++; 
 8700              		.loc 1 1933 0
 8701 6df2 83855CF3 		addl	$1, -3236(%rbp)
 8701      FFFF01
1934:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 8702              		.loc 1 1934 0
 8703 6df9 BF000000 		movl	$.LC155, %edi
 8703      00
 8704 6dfe E8000000 		call	puts
 8704      00
1935:main.c        **** 								break;
 8705              		.loc 1 1935 0
 8706 6e03 E98D0200 		jmp	.L442
 8706      00
 8707              	.L448:
1936:main.c        **** 							}
1937:main.c        **** 						delay(del);
 8708              		.loc 1 1937 0
 8709 6e08 8B85B0F3 		movl	-3152(%rbp), %eax
 8709      FFFF
 8710 6e0e 89C7     		movl	%eax, %edi
 8711 6e10 E8000000 		call	delay
 8711      00
1938:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &encrypted_ack1_again3[3], &error);
 8712              		.loc 1 1938 0
 8713 6e15 8B85C8F2 		movl	-3384(%rbp), %eax
 8713      FFFF
 8714 6e1b 01C0     		addl	%eax, %eax
 8715 6e1d 0FB6F0   		movzbl	%al, %esi
 8716 6e20 488B85E0 		movq	-3104(%rbp), %rax
 8716      F3FFFF
 8717 6e27 488D8DE8 		leaq	-3096(%rbp), %rcx
 8717      F3FFFF
 8718 6e2e 488D55D0 		leaq	-48(%rbp), %rdx
 8719 6e32 4883C203 		addq	$3, %rdx
 8720 6e36 4989C8   		movq	%rcx, %r8
 8721 6e39 4889D1   		movq	%rdx, %rcx
 8722 6e3c BA010000 		movl	$1, %edx
 8722      00
 8723 6e41 4889C7   		movq	%rax, %rdi
 8724 6e44 E8000000 		call	flReadChannelAsyncSubmit
 8724      00
 8725 6e49 8985BCF2 		movl	%eax, -3396(%rbp)
 8725      FFFF
1939:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8726              		.loc 1 1939 0
 8727 6e4f 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8727      FFFF00
 8728 6e56 740F     		je	.L449
 8729              		.loc 1 1939 0 is_stmt 0 discriminator 1
 8730 6e58 C785B8F2 		movl	$1, -3400(%rbp)
 8730      FFFF0100 
 8730      0000
 8731 6e62 E9290200 		jmp	.L439
 8731      00
 8732              	.L449:
1940:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 8733              		.loc 1 1940 0 is_stmt 1
 8734 6e67 488B85E0 		movq	-3104(%rbp), %rax
 8734      F3FFFF
 8735 6e6e 488DBDE8 		leaq	-3096(%rbp), %rdi
 8735      F3FFFF
 8736 6e75 488D8DB4 		leaq	-3404(%rbp), %rcx
 8736      F2FFFF
 8737 6e7c 488D95B4 		leaq	-3404(%rbp), %rdx
 8737      F2FFFF
 8738 6e83 488DB5F0 		leaq	-3088(%rbp), %rsi
 8738      F3FFFF
 8739 6e8a 4989F8   		movq	%rdi, %r8
 8740 6e8d 4889C7   		movq	%rax, %rdi
 8741 6e90 E8000000 		call	flReadChannelAsyncAwait
 8741      00
 8742 6e95 8985BCF2 		movl	%eax, -3396(%rbp)
 8742      FFFF
1941:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8743              		.loc 1 1941 0
 8744 6e9b 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8744      FFFF00
 8745 6ea2 740F     		je	.L450
 8746              		.loc 1 1941 0 is_stmt 0 discriminator 1
 8747 6ea4 C785B8F2 		movl	$1, -3400(%rbp)
 8747      FFFF0100 
 8747      0000
 8748 6eae E9DD0100 		jmp	.L439
 8748      00
 8749              	.L450:
1942:main.c        **** 						if(encrypted_ack1_again3[3] == reset) 
 8750              		.loc 1 1942 0 is_stmt 1
 8751 6eb3 0FB645D3 		movzbl	-45(%rbp), %eax
 8752 6eb7 3A85AFF2 		cmpb	-3409(%rbp), %al
 8752      FFFF
 8753 6ebd 751D     		jne	.L451
1943:main.c        **** 							{
1944:main.c        **** 								k--; 
 8754              		.loc 1 1944 0
 8755 6ebf 83ADC8F2 		subl	$1, -3384(%rbp)
 8755      FFFF01
1945:main.c        **** 								breaker2++;
 8756              		.loc 1 1945 0
 8757 6ec6 83855CF3 		addl	$1, -3236(%rbp)
 8757      FFFF01
1946:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 8758              		.loc 1 1946 0
 8759 6ecd BF000000 		movl	$.LC155, %edi
 8759      00
 8760 6ed2 E8000000 		call	puts
 8760      00
1947:main.c        **** 								break;
 8761              		.loc 1 1947 0
 8762 6ed7 E9B90100 		jmp	.L442
 8762      00
 8763              	.L451:
1948:main.c        **** 							}
1949:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 8764              		.loc 1 1949 0
 8765 6edc 83BDBCF2 		cmpl	$0, -3396(%rbp)
 8765      FFFF00
 8766 6ee3 740F     		je	.L452
 8767              		.loc 1 1949 0 is_stmt 0 discriminator 1
 8768 6ee5 C785B8F2 		movl	$1, -3400(%rbp)
 8768      FFFF0100 
 8768      0000
 8769 6eef E99C0100 		jmp	.L439
 8769      00
 8770              	.L452:
1950:main.c        **** 						printf("%s\n", "Ack1 received successfully, not checked yet, it is as----");
 8771              		.loc 1 1950 0 is_stmt 1
 8772 6ef4 BF000000 		movl	$.LC215, %edi
 8772      00
 8773 6ef9 E8000000 		call	puts
 8773      00
 8774              	.LBB88:
1951:main.c        **** 						for (int i = 0; i < 4; ++i)
 8775              		.loc 1 1951 0
 8776 6efe C78564F3 		movl	$0, -3228(%rbp)
 8776      FFFF0000 
 8776      0000
 8777 6f08 EB28     		jmp	.L453
 8778              	.L454:
1952:main.c        **** 						{
1953:main.c        **** 							printf("%d ", encrypted_ack1_again3[i]);
 8779              		.loc 1 1953 0 discriminator 3
 8780 6f0a 8B8564F3 		movl	-3228(%rbp), %eax
 8780      FFFF
 8781 6f10 4898     		cltq
 8782 6f12 0FB64405 		movzbl	-48(%rbp,%rax), %eax
 8782      D0
 8783 6f17 0FB6C0   		movzbl	%al, %eax
 8784 6f1a 89C6     		movl	%eax, %esi
 8785 6f1c BF000000 		movl	$.LC10, %edi
 8785      00
 8786 6f21 B8000000 		movl	$0, %eax
 8786      00
 8787 6f26 E8000000 		call	printf
 8787      00
1951:main.c        **** 						for (int i = 0; i < 4; ++i)
 8788              		.loc 1 1951 0 discriminator 3
 8789 6f2b 838564F3 		addl	$1, -3228(%rbp)
 8789      FFFF01
 8790              	.L453:
1951:main.c        **** 						for (int i = 0; i < 4; ++i)
 8791              		.loc 1 1951 0 is_stmt 0 discriminator 1
 8792 6f32 83BD64F3 		cmpl	$3, -3228(%rbp)
 8792      FFFF03
 8793 6f39 7ECF     		jle	.L454
 8794              	.LBE88:
1954:main.c        **** 						}
1955:main.c        **** 						printf("\n");
 8795              		.loc 1 1955 0 is_stmt 1
 8796 6f3b BF0A0000 		movl	$10, %edi
 8796      00
 8797 6f40 E8000000 		call	putchar
 8797      00
1956:main.c        **** 						int encrypted_ack1_again3_int[32];
1957:main.c        **** 						printf("%s\n", "Converting encrypted ack1 from uint8 to binary");
 8798              		.loc 1 1957 0
 8799 6f45 BF000000 		movl	$.LC174, %edi
 8799      00
 8800 6f4a E8000000 		call	puts
 8800      00
1958:main.c        **** 						uint8ToBin(encrypted_ack1_again3, encrypted_ack1_again3_int);
 8801              		.loc 1 1958 0
 8802 6f4f 488D95D0 		leaq	-816(%rbp), %rdx
 8802      FCFFFF
 8803 6f56 488D45D0 		leaq	-48(%rbp), %rax
 8804 6f5a 4889D6   		movq	%rdx, %rsi
 8805 6f5d 4889C7   		movq	%rax, %rdi
 8806 6f60 E8000000 		call	uint8ToBin
 8806      00
1959:main.c        **** 						printf("%s\n", "Converted encrypted ack1 from uint8 to binary , it is as --");
 8807              		.loc 1 1959 0
 8808 6f65 BF000000 		movl	$.LC216, %edi
 8808      00
 8809 6f6a E8000000 		call	puts
 8809      00
 8810              	.LBB89:
1960:main.c        **** 						for (int i = 0; i < 32; ++i)
 8811              		.loc 1 1960 0
 8812 6f6f C78568F3 		movl	$0, -3224(%rbp)
 8812      FFFF0000 
 8812      0000
 8813 6f79 EB27     		jmp	.L455
 8814              	.L456:
1961:main.c        **** 						{
1962:main.c        **** 							printf("%d ", encrypted_ack1_again3_int[i]);
 8815              		.loc 1 1962 0 discriminator 3
 8816 6f7b 8B8568F3 		movl	-3224(%rbp), %eax
 8816      FFFF
 8817 6f81 4898     		cltq
 8818 6f83 8B8485D0 		movl	-816(%rbp,%rax,4), %eax
 8818      FCFFFF
 8819 6f8a 89C6     		movl	%eax, %esi
 8820 6f8c BF000000 		movl	$.LC10, %edi
 8820      00
 8821 6f91 B8000000 		movl	$0, %eax
 8821      00
 8822 6f96 E8000000 		call	printf
 8822      00
1960:main.c        **** 						for (int i = 0; i < 32; ++i)
 8823              		.loc 1 1960 0 discriminator 3
 8824 6f9b 838568F3 		addl	$1, -3224(%rbp)
 8824      FFFF01
 8825              	.L455:
1960:main.c        **** 						for (int i = 0; i < 32; ++i)
 8826              		.loc 1 1960 0 is_stmt 0 discriminator 1
 8827 6fa2 83BD68F3 		cmpl	$31, -3224(%rbp)
 8827      FFFF1F
 8828 6fa9 7ED0     		jle	.L456
 8829              	.LBE89:
1963:main.c        **** 						}
1964:main.c        **** 						printf("\n");
 8830              		.loc 1 1964 0 is_stmt 1
 8831 6fab BF0A0000 		movl	$10, %edi
 8831      00
 8832 6fb0 E8000000 		call	putchar
 8832      00
1965:main.c        **** 						int decrypted_ack1_again3_int[32];
1966:main.c        **** 						printf("%s\n", "Decrypting the encrypted ack1");
 8833              		.loc 1 1966 0
 8834 6fb5 BF000000 		movl	$.LC217, %edi
 8834      00
 8835 6fba E8000000 		call	puts
 8835      00
1967:main.c        **** 						decrypter(encrypted_ack1_again3_int, K, decrypted_ack1_again3_int);
 8836              		.loc 1 1967 0
 8837 6fbf 488D9550 		leaq	-688(%rbp), %rdx
 8837      FDFFFF
 8838 6fc6 488D8DD0 		leaq	-2608(%rbp), %rcx
 8838      F5FFFF
 8839 6fcd 488D85D0 		leaq	-816(%rbp), %rax
 8839      FCFFFF
 8840 6fd4 4889CE   		movq	%rcx, %rsi
 8841 6fd7 4889C7   		movq	%rax, %rdi
 8842 6fda E8000000 		call	decrypter
 8842      00
1968:main.c        **** 						printf("%s\n", "Encrypted ack1 decrypted successfully, it is as----");
 8843              		.loc 1 1968 0
 8844 6fdf BF000000 		movl	$.LC218, %edi
 8844      00
 8845 6fe4 E8000000 		call	puts
 8845      00
 8846              	.LBB90:
1969:main.c        **** 						for (int i = 0; i < 32; ++i)
 8847              		.loc 1 1969 0
 8848 6fe9 C7856CF3 		movl	$0, -3220(%rbp)
 8848      FFFF0000 
 8848      0000
 8849 6ff3 EB27     		jmp	.L457
 8850              	.L458:
1970:main.c        **** 						{
1971:main.c        **** 							printf("%d ", decrypted_ack1_again3_int[i]);
 8851              		.loc 1 1971 0 discriminator 3
 8852 6ff5 8B856CF3 		movl	-3220(%rbp), %eax
 8852      FFFF
 8853 6ffb 4898     		cltq
 8854 6ffd 8B848550 		movl	-688(%rbp,%rax,4), %eax
 8854      FDFFFF
 8855 7004 89C6     		movl	%eax, %esi
 8856 7006 BF000000 		movl	$.LC10, %edi
 8856      00
 8857 700b B8000000 		movl	$0, %eax
 8857      00
 8858 7010 E8000000 		call	printf
 8858      00
1969:main.c        **** 						for (int i = 0; i < 32; ++i)
 8859              		.loc 1 1969 0 discriminator 3
 8860 7015 83856CF3 		addl	$1, -3220(%rbp)
 8860      FFFF01
 8861              	.L457:
1969:main.c        **** 						for (int i = 0; i < 32; ++i)
 8862              		.loc 1 1969 0 is_stmt 0 discriminator 1
 8863 701c 83BD6CF3 		cmpl	$31, -3220(%rbp)
 8863      FFFF1F
 8864 7023 7ED0     		jle	.L458
 8865              	.LBE90:
1972:main.c        **** 						}
1973:main.c        **** 						printf("\n");
 8866              		.loc 1 1973 0 is_stmt 1
 8867 7025 BF0A0000 		movl	$10, %edi
 8867      00
 8868 702a E8000000 		call	putchar
 8868      00
 8869              	.LBB91:
1974:main.c        **** 						for(int i=0; i<32; i++)
 8870              		.loc 1 1974 0
 8871 702f C78570F3 		movl	$0, -3216(%rbp)
 8871      FFFF0000 
 8871      0000
 8872 7039 EB3D     		jmp	.L459
 8873              	.L461:
1975:main.c        **** 						{
1976:main.c        **** 							if(decrypted_ack1_again3_int[i] != ack1[i])
 8874              		.loc 1 1976 0
 8875 703b 8B8570F3 		movl	-3216(%rbp), %eax
 8875      FFFF
 8876 7041 4898     		cltq
 8877 7043 8B948550 		movl	-688(%rbp,%rax,4), %edx
 8877      FDFFFF
 8878 704a 8B8570F3 		movl	-3216(%rbp), %eax
 8878      FFFF
 8879 7050 4898     		cltq
 8880 7052 8B848550 		movl	-2480(%rbp,%rax,4), %eax
 8880      F6FFFF
 8881 7059 39C2     		cmpl	%eax, %edx
 8882 705b 7414     		je	.L460
1977:main.c        **** 							{
1978:main.c        **** 								arb2 = 1;
 8883              		.loc 1 1978 0
 8884 705d C78560F3 		movl	$1, -3232(%rbp)
 8884      FFFF0100 
 8884      0000
1979:main.c        **** 								printf("%s\n", "Ack1 doesn't match");
 8885              		.loc 1 1979 0
 8886 7067 BF000000 		movl	$.LC219, %edi
 8886      00
 8887 706c E8000000 		call	puts
 8887      00
 8888              	.L460:
1974:main.c        **** 						{
 8889              		.loc 1 1974 0 discriminator 2
 8890 7071 838570F3 		addl	$1, -3216(%rbp)
 8890      FFFF01
 8891              	.L459:
1974:main.c        **** 						{
 8892              		.loc 1 1974 0 is_stmt 0 discriminator 1
 8893 7078 83BD70F3 		cmpl	$31, -3216(%rbp)
 8893      FFFF1F
 8894 707f 7EBA     		jle	.L461
 8895              	.LBE91:
1980:main.c        **** 
1981:main.c        **** 							}
1982:main.c        **** 						}
1983:main.c        **** 						if(arb2 == 0)
 8896              		.loc 1 1983 0 is_stmt 1
 8897 7081 83BD60F3 		cmpl	$0, -3232(%rbp)
 8897      FFFF00
 8898 7088 0F859FFA 		jne	.L465
 8898      FFFF
1984:main.c        **** 							break;
 8899              		.loc 1 1984 0
 8900 708e EB05     		jmp	.L442
 8901              	.L439:
 8902              	.LBE87:
 8903              	.LBE103:
 8904              	.LBE107:
 8905              	.LBE111:
1294:main.c        **** 			fStatus = flIsFPGARunning(handle, &isRunning, &error);
 8906              		.loc 1 1294 0 discriminator 2
 8907 7090 E98B0D00 		jmp	.L230
 8907      00
 8908              	.L442:
 8909              	.LBB112:
 8910              	.LBB108:
 8911              	.LBB104:
1985:main.c        **** 					}
1986:main.c        **** 
1987:main.c        **** 					if(breaker2 >= 1) continue;
 8912              		.loc 1 1987 0
 8913 7095 83BD5CF3 		cmpl	$0, -3236(%rbp)
 8913      FFFF00
 8914 709c 0F8F090D 		jg	.L525
 8914      0000
1988:main.c        **** 
1989:main.c        **** 					printf("\n");
 8915              		.loc 1 1989 0
 8916 70a2 BF0A0000 		movl	$10, %edi
 8916      00
 8917 70a7 E8000000 		call	putchar
 8917      00
1990:main.c        **** 					int encrypted_ack2_again[32];
1991:main.c        **** 					printf("%s\n", "Encrypting ack2 ");
 8918              		.loc 1 1991 0
 8919 70ac BF000000 		movl	$.LC228, %edi
 8919      00
 8920 70b1 E8000000 		call	puts
 8920      00
1992:main.c        **** 					encrypter(ack2, K, encrypted_ack2_again);
 8921              		.loc 1 1992 0
 8922 70b6 488D9550 		leaq	-944(%rbp), %rdx
 8922      FCFFFF
 8923 70bd 488D8DD0 		leaq	-2608(%rbp), %rcx
 8923      F5FFFF
 8924 70c4 488D85D0 		leaq	-2352(%rbp), %rax
 8924      F6FFFF
 8925 70cb 4889CE   		movq	%rcx, %rsi
 8926 70ce 4889C7   		movq	%rax, %rdi
 8927 70d1 E8000000 		call	encrypter
 8927      00
1993:main.c        **** 					printf("%s\n", "Encrypted ack2 is as follows  ----");
 8928              		.loc 1 1993 0
 8929 70d6 BF000000 		movl	$.LC229, %edi
 8929      00
 8930 70db E8000000 		call	puts
 8930      00
 8931              	.LBB92:
1994:main.c        **** 					for (int i = 0; i < 32; ++i)
 8932              		.loc 1 1994 0
 8933 70e0 C78574F3 		movl	$0, -3212(%rbp)
 8933      FFFF0000 
 8933      0000
 8934 70ea EB27     		jmp	.L466
 8935              	.L467:
1995:main.c        **** 					{
1996:main.c        **** 						printf("%d ", encrypted_ack2_again[i]);
 8936              		.loc 1 1996 0 discriminator 3
 8937 70ec 8B8574F3 		movl	-3212(%rbp), %eax
 8937      FFFF
 8938 70f2 4898     		cltq
 8939 70f4 8B848550 		movl	-944(%rbp,%rax,4), %eax
 8939      FCFFFF
 8940 70fb 89C6     		movl	%eax, %esi
 8941 70fd BF000000 		movl	$.LC10, %edi
 8941      00
 8942 7102 B8000000 		movl	$0, %eax
 8942      00
 8943 7107 E8000000 		call	printf
 8943      00
1994:main.c        **** 					for (int i = 0; i < 32; ++i)
 8944              		.loc 1 1994 0 discriminator 3
 8945 710c 838574F3 		addl	$1, -3212(%rbp)
 8945      FFFF01
 8946              	.L466:
1994:main.c        **** 					for (int i = 0; i < 32; ++i)
 8947              		.loc 1 1994 0 is_stmt 0 discriminator 1
 8948 7113 83BD74F3 		cmpl	$31, -3212(%rbp)
 8948      FFFF1F
 8949 711a 7ED0     		jle	.L467
 8950              	.LBE92:
1997:main.c        **** 					}
1998:main.c        **** 					printf("\n");
 8951              		.loc 1 1998 0 is_stmt 1
 8952 711c BF0A0000 		movl	$10, %edi
 8952      00
 8953 7121 E8000000 		call	putchar
 8953      00
1999:main.c        **** 					uint8 encrypted_ack2_again_uint8[4];
2000:main.c        **** 					printf("%s\n", "Converting encrypted ack2 from binary to uint8");
 8954              		.loc 1 2000 0
 8955 7126 BF000000 		movl	$.LC191, %edi
 8955      00
 8956 712b E8000000 		call	puts
 8956      00
2001:main.c        **** 					BinTouint8(encrypted_ack2_again_uint8, encrypted_ack2_again);
 8957              		.loc 1 2001 0
 8958 7130 488D9550 		leaq	-944(%rbp), %rdx
 8958      FCFFFF
 8959 7137 488D45C0 		leaq	-64(%rbp), %rax
 8960 713b 4889D6   		movq	%rdx, %rsi
 8961 713e 4889C7   		movq	%rax, %rdi
 8962 7141 E8000000 		call	BinTouint8
 8962      00
2002:main.c        **** 					printf("%s\n", "Converted encrypted ack2 to uint8, it is as follows");
 8963              		.loc 1 2002 0
 8964 7146 BF000000 		movl	$.LC230, %edi
 8964      00
 8965 714b E8000000 		call	puts
 8965      00
 8966              	.LBB93:
2003:main.c        **** 					for (int i = 0; i < 4; ++i)
 8967              		.loc 1 2003 0
 8968 7150 C78578F3 		movl	$0, -3208(%rbp)
 8968      FFFF0000 
 8968      0000
 8969 715a EB28     		jmp	.L468
 8970              	.L469:
2004:main.c        **** 					{
2005:main.c        **** 						printf("%d ", encrypted_ack2_again_uint8[i]);
 8971              		.loc 1 2005 0 discriminator 3
 8972 715c 8B8578F3 		movl	-3208(%rbp), %eax
 8972      FFFF
 8973 7162 4898     		cltq
 8974 7164 0FB64405 		movzbl	-64(%rbp,%rax), %eax
 8974      C0
 8975 7169 0FB6C0   		movzbl	%al, %eax
 8976 716c 89C6     		movl	%eax, %esi
 8977 716e BF000000 		movl	$.LC10, %edi
 8977      00
 8978 7173 B8000000 		movl	$0, %eax
 8978      00
 8979 7178 E8000000 		call	printf
 8979      00
2003:main.c        **** 					for (int i = 0; i < 4; ++i)
 8980              		.loc 1 2003 0 discriminator 3
 8981 717d 838578F3 		addl	$1, -3208(%rbp)
 8981      FFFF01
 8982              	.L468:
2003:main.c        **** 					for (int i = 0; i < 4; ++i)
 8983              		.loc 1 2003 0 is_stmt 0 discriminator 1
 8984 7184 83BD78F3 		cmpl	$3, -3208(%rbp)
 8984      FFFF03
 8985 718b 7ECF     		jle	.L469
 8986              	.LBE93:
2006:main.c        **** 					}
2007:main.c        **** 					printf("\n");
 8987              		.loc 1 2007 0 is_stmt 1
 8988 718d BF0A0000 		movl	$10, %edi
 8988      00
 8989 7192 E8000000 		call	putchar
 8989      00
2008:main.c        **** 					printf("%s\n", "Writing encrypted ack2 to channel");
 8990              		.loc 1 2008 0
 8991 7197 BF000000 		movl	$.LC231, %edi
 8991      00
 8992 719c E8000000 		call	puts
 8992      00
2009:main.c        **** 					delay(del);
 8993              		.loc 1 2009 0
 8994 71a1 8B85B0F3 		movl	-3152(%rbp), %eax
 8994      FFFF
 8995 71a7 89C7     		movl	%eax, %edi
 8996 71a9 E8000000 		call	delay
 8996      00
2010:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &encrypted_ack2_again_uint8[0], &error);
 8997              		.loc 1 2010 0
 8998 71ae 8B85C8F2 		movl	-3384(%rbp), %eax
 8998      FFFF
 8999 71b4 01C0     		addl	%eax, %eax
 9000 71b6 83C001   		addl	$1, %eax
 9001 71b9 0FB6F0   		movzbl	%al, %esi
 9002 71bc 488B85E0 		movq	-3104(%rbp), %rax
 9002      F3FFFF
 9003 71c3 488D8DE8 		leaq	-3096(%rbp), %rcx
 9003      F3FFFF
 9004 71ca 488D55C0 		leaq	-64(%rbp), %rdx
 9005 71ce 4989C8   		movq	%rcx, %r8
 9006 71d1 4889D1   		movq	%rdx, %rcx
 9007 71d4 BA010000 		movl	$1, %edx
 9007      00
 9008 71d9 4889C7   		movq	%rax, %rdi
 9009 71dc E8000000 		call	flWriteChannel
 9009      00
 9010 71e1 8985BCF2 		movl	%eax, -3396(%rbp)
 9010      FFFF
2011:main.c        **** 					delay(del);
 9011              		.loc 1 2011 0
 9012 71e7 8B85B0F3 		movl	-3152(%rbp), %eax
 9012      FFFF
 9013 71ed 89C7     		movl	%eax, %edi
 9014 71ef E8000000 		call	delay
 9014      00
2012:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &encrypted_ack2_again_uint8[1], &error);
 9015              		.loc 1 2012 0
 9016 71f4 8B85C8F2 		movl	-3384(%rbp), %eax
 9016      FFFF
 9017 71fa 01C0     		addl	%eax, %eax
 9018 71fc 83C001   		addl	$1, %eax
 9019 71ff 0FB6F0   		movzbl	%al, %esi
 9020 7202 488B85E0 		movq	-3104(%rbp), %rax
 9020      F3FFFF
 9021 7209 488D8DE8 		leaq	-3096(%rbp), %rcx
 9021      F3FFFF
 9022 7210 488D55C0 		leaq	-64(%rbp), %rdx
 9023 7214 4883C201 		addq	$1, %rdx
 9024 7218 4989C8   		movq	%rcx, %r8
 9025 721b 4889D1   		movq	%rdx, %rcx
 9026 721e BA010000 		movl	$1, %edx
 9026      00
 9027 7223 4889C7   		movq	%rax, %rdi
 9028 7226 E8000000 		call	flWriteChannel
 9028      00
 9029 722b 8985BCF2 		movl	%eax, -3396(%rbp)
 9029      FFFF
2013:main.c        **** 					delay(del);
 9030              		.loc 1 2013 0
 9031 7231 8B85B0F3 		movl	-3152(%rbp), %eax
 9031      FFFF
 9032 7237 89C7     		movl	%eax, %edi
 9033 7239 E8000000 		call	delay
 9033      00
2014:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &encrypted_ack2_again_uint8[2], &error);
 9034              		.loc 1 2014 0
 9035 723e 8B85C8F2 		movl	-3384(%rbp), %eax
 9035      FFFF
 9036 7244 01C0     		addl	%eax, %eax
 9037 7246 83C001   		addl	$1, %eax
 9038 7249 0FB6F0   		movzbl	%al, %esi
 9039 724c 488B85E0 		movq	-3104(%rbp), %rax
 9039      F3FFFF
 9040 7253 488D8DE8 		leaq	-3096(%rbp), %rcx
 9040      F3FFFF
 9041 725a 488D55C0 		leaq	-64(%rbp), %rdx
 9042 725e 4883C202 		addq	$2, %rdx
 9043 7262 4989C8   		movq	%rcx, %r8
 9044 7265 4889D1   		movq	%rdx, %rcx
 9045 7268 BA010000 		movl	$1, %edx
 9045      00
 9046 726d 4889C7   		movq	%rax, %rdi
 9047 7270 E8000000 		call	flWriteChannel
 9047      00
 9048 7275 8985BCF2 		movl	%eax, -3396(%rbp)
 9048      FFFF
2015:main.c        **** 					delay(del);
 9049              		.loc 1 2015 0
 9050 727b 8B85B0F3 		movl	-3152(%rbp), %eax
 9050      FFFF
 9051 7281 89C7     		movl	%eax, %edi
 9052 7283 E8000000 		call	delay
 9052      00
2016:main.c        **** 					fStatus = flWriteChannel(handle, 2*k+1, 1, &encrypted_ack2_again_uint8[3], &error);
 9053              		.loc 1 2016 0
 9054 7288 8B85C8F2 		movl	-3384(%rbp), %eax
 9054      FFFF
 9055 728e 01C0     		addl	%eax, %eax
 9056 7290 83C001   		addl	$1, %eax
 9057 7293 0FB6F0   		movzbl	%al, %esi
 9058 7296 488B85E0 		movq	-3104(%rbp), %rax
 9058      F3FFFF
 9059 729d 488D8DE8 		leaq	-3096(%rbp), %rcx
 9059      F3FFFF
 9060 72a4 488D55C0 		leaq	-64(%rbp), %rdx
 9061 72a8 4883C203 		addq	$3, %rdx
 9062 72ac 4989C8   		movq	%rcx, %r8
 9063 72af 4889D1   		movq	%rdx, %rcx
 9064 72b2 BA010000 		movl	$1, %edx
 9064      00
 9065 72b7 4889C7   		movq	%rax, %rdi
 9066 72ba E8000000 		call	flWriteChannel
 9066      00
 9067 72bf 8985BCF2 		movl	%eax, -3396(%rbp)
 9067      FFFF
2017:main.c        **** 					CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9068              		.loc 1 2017 0
 9069 72c5 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9069      FFFF00
 9070 72cc 740F     		je	.L470
 9071              		.loc 1 2017 0 is_stmt 0 discriminator 1
 9072 72ce C785B8F2 		movl	$1, -3400(%rbp)
 9072      FFFF0100 
 9072      0000
 9073 72d8 E9430B00 		jmp	.L230
 9073      00
 9074              	.L470:
2018:main.c        **** 					printf("%s\n", "Written successfully encrypted ack2, the written data is --");
 9075              		.loc 1 2018 0 is_stmt 1
 9076 72dd BF000000 		movl	$.LC232, %edi
 9076      00
 9077 72e2 E8000000 		call	puts
 9077      00
 9078              	.LBB94:
2019:main.c        **** 					for (int i = 0; i < 4; ++i)
 9079              		.loc 1 2019 0
 9080 72e7 C7857CF3 		movl	$0, -3204(%rbp)
 9080      FFFF0000 
 9080      0000
 9081 72f1 EB28     		jmp	.L471
 9082              	.L472:
2020:main.c        **** 					{
2021:main.c        **** 						printf("%d ", encrypted_ack2_again_uint8[i]);
 9083              		.loc 1 2021 0 discriminator 3
 9084 72f3 8B857CF3 		movl	-3204(%rbp), %eax
 9084      FFFF
 9085 72f9 4898     		cltq
 9086 72fb 0FB64405 		movzbl	-64(%rbp,%rax), %eax
 9086      C0
 9087 7300 0FB6C0   		movzbl	%al, %eax
 9088 7303 89C6     		movl	%eax, %esi
 9089 7305 BF000000 		movl	$.LC10, %edi
 9089      00
 9090 730a B8000000 		movl	$0, %eax
 9090      00
 9091 730f E8000000 		call	printf
 9091      00
2019:main.c        **** 					for (int i = 0; i < 4; ++i)
 9092              		.loc 1 2019 0 discriminator 3
 9093 7314 83857CF3 		addl	$1, -3204(%rbp)
 9093      FFFF01
 9094              	.L471:
2019:main.c        **** 					for (int i = 0; i < 4; ++i)
 9095              		.loc 1 2019 0 is_stmt 0 discriminator 1
 9096 731b 83BD7CF3 		cmpl	$3, -3204(%rbp)
 9096      FFFF03
 9097 7322 7ECF     		jle	.L472
 9098              	.LBE94:
2022:main.c        **** 					}
2023:main.c        **** 
2024:main.c        **** 		 			//////////////////////////////////////////////////////////////////////////////
2025:main.c        **** 					printf("\n");
 9099              		.loc 1 2025 0 is_stmt 1
 9100 7324 BF0A0000 		movl	$10, %edi
 9100      00
 9101 7329 E8000000 		call	putchar
 9101      00
2026:main.c        **** 					printf("%s\n", "Receiving data to update CSV file");
 9102              		.loc 1 2026 0
 9103 732e BF000000 		movl	$.LC233, %edi
 9103      00
 9104 7333 E8000000 		call	puts
 9104      00
2027:main.c        **** 
2028:main.c        **** 					int X[8] = {0,1,1,1,1,1,1,1};
 9105              		.loc 1 2028 0
 9106 7338 C78530F5 		movl	$0, -2768(%rbp)
 9106      FFFF0000 
 9106      0000
 9107 7342 C78534F5 		movl	$1, -2764(%rbp)
 9107      FFFF0100 
 9107      0000
 9108 734c C78538F5 		movl	$1, -2760(%rbp)
 9108      FFFF0100 
 9108      0000
 9109 7356 C7853CF5 		movl	$1, -2756(%rbp)
 9109      FFFF0100 
 9109      0000
 9110 7360 C78540F5 		movl	$1, -2752(%rbp)
 9110      FFFF0100 
 9110      0000
 9111 736a C78544F5 		movl	$1, -2748(%rbp)
 9111      FFFF0100 
 9111      0000
 9112 7374 C78548F5 		movl	$1, -2744(%rbp)
 9112      FFFF0100 
 9112      0000
 9113 737e C7854CF5 		movl	$1, -2740(%rbp)
 9113      FFFF0100 
 9113      0000
2029:main.c        **** 					int decX = bitArrayToInt(X, 8);
 9114              		.loc 1 2029 0
 9115 7388 488D8530 		leaq	-2768(%rbp), %rax
 9115      F5FFFF
 9116 738f BE080000 		movl	$8, %esi
 9116      00
 9117 7394 4889C7   		movq	%rax, %rdi
 9118 7397 E8000000 		call	bitArrayToInt
 9118      00
 9119 739c 8985BCF3 		movl	%eax, -3140(%rbp)
 9119      FFFF
2030:main.c        **** 					int Y[8] = {1,1,1,1,1,1,1,1};
 9120              		.loc 1 2030 0
 9121 73a2 C78550F5 		movl	$1, -2736(%rbp)
 9121      FFFF0100 
 9121      0000
 9122 73ac C78554F5 		movl	$1, -2732(%rbp)
 9122      FFFF0100 
 9122      0000
 9123 73b6 C78558F5 		movl	$1, -2728(%rbp)
 9123      FFFF0100 
 9123      0000
 9124 73c0 C7855CF5 		movl	$1, -2724(%rbp)
 9124      FFFF0100 
 9124      0000
 9125 73ca C78560F5 		movl	$1, -2720(%rbp)
 9125      FFFF0100 
 9125      0000
 9126 73d4 C78564F5 		movl	$1, -2716(%rbp)
 9126      FFFF0100 
 9126      0000
 9127 73de C78568F5 		movl	$1, -2712(%rbp)
 9127      FFFF0100 
 9127      0000
 9128 73e8 C7856CF5 		movl	$1, -2708(%rbp)
 9128      FFFF0100 
 9128      0000
2031:main.c        **** 					int decY = bitArrayToInt(Y, 8);
 9129              		.loc 1 2031 0
 9130 73f2 488D8550 		leaq	-2736(%rbp), %rax
 9130      F5FFFF
 9131 73f9 BE080000 		movl	$8, %esi
 9131      00
 9132 73fe 4889C7   		movq	%rax, %rdi
 9133 7401 E8000000 		call	bitArrayToInt
 9133      00
 9134 7406 8985C0F3 		movl	%eax, -3136(%rbp)
 9134      FFFF
2032:main.c        **** 
2033:main.c        **** 					uint8 direct;
2034:main.c        **** 					uint8 updaterFPGA[4];
2035:main.c        **** 					int updatesFromFPGA[32];
2036:main.c        **** 					int updatesForCSV[8];
2037:main.c        **** 					int exists, ok, dir, nxt;
2038:main.c        **** 					bool updateCSV=false;
 9135              		.loc 1 2038 0
 9136 740c C685ACF2 		movb	$0, -3412(%rbp)
 9136      FFFF00
2039:main.c        **** 
2040:main.c        **** 					int cnt1 = 0;
 9137              		.loc 1 2040 0
 9138 7413 C78580F3 		movl	$0, -3200(%rbp)
 9138      FFFF0000 
 9138      0000
2041:main.c        **** 					int cnt2 = 0;
 9139              		.loc 1 2041 0
 9140 741d C78584F3 		movl	$0, -3196(%rbp)
 9140      FFFF0000 
 9140      0000
2042:main.c        **** 					//size_t startT, endT;
2043:main.c        **** 					//time(&startT);
2044:main.c        **** 					//int timeout = 50;
2045:main.c        **** 					//int diff3;
2046:main.c        **** 					int breaker3 = 0;
 9141              		.loc 1 2046 0
 9142 7427 C78588F3 		movl	$0, -3192(%rbp)
 9142      FFFF0000 
 9142      0000
 9143              	.L501:
 9144              	.LBB95:
2047:main.c        **** 					while(1)
2048:main.c        **** 					{	
2049:main.c        **** 						//printf("%s", "FPGA Count " );
2050:main.c        **** 						cnt1++;
 9145              		.loc 1 2050 0
 9146 7431 838580F3 		addl	$1, -3200(%rbp)
 9146      FFFF01
2051:main.c        **** 						//printf("%d\n", cnt1);
2052:main.c        **** 						//printf("%s\n", "Receiving Controlling signal form FPGA ");
2053:main.c        **** 						
2054:main.c        **** 
2055:main.c        **** 						// -------------------------------------------------------------
2056:main.c        **** 						// timer part start
2057:main.c        **** 
2058:main.c        **** 						delay(del);
 9147              		.loc 1 2058 0
 9148 7438 8B85B0F3 		movl	-3152(%rbp), %eax
 9148      FFFF
 9149 743e 89C7     		movl	%eax, %edi
 9150 7440 E8000000 		call	delay
 9150      00
2059:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &direct, &error);
 9151              		.loc 1 2059 0
 9152 7445 8B85C8F2 		movl	-3384(%rbp), %eax
 9152      FFFF
 9153 744b 01C0     		addl	%eax, %eax
 9154 744d 0FB6F0   		movzbl	%al, %esi
 9155 7450 488B85E0 		movq	-3104(%rbp), %rax
 9155      F3FFFF
 9156 7457 488D8DE8 		leaq	-3096(%rbp), %rcx
 9156      F3FFFF
 9157 745e 488D95A9 		leaq	-3415(%rbp), %rdx
 9157      F2FFFF
 9158 7465 4989C8   		movq	%rcx, %r8
 9159 7468 4889D1   		movq	%rdx, %rcx
 9160 746b BA010000 		movl	$1, %edx
 9160      00
 9161 7470 4889C7   		movq	%rax, %rdi
 9162 7473 E8000000 		call	flReadChannelAsyncSubmit
 9162      00
 9163 7478 8985BCF2 		movl	%eax, -3396(%rbp)
 9163      FFFF
2060:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9164              		.loc 1 2060 0
 9165 747e 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9165      FFFF00
 9166 7485 740F     		je	.L473
 9167              		.loc 1 2060 0 is_stmt 0 discriminator 1
 9168 7487 C785B8F2 		movl	$1, -3400(%rbp)
 9168      FFFF0100 
 9168      0000
 9169 7491 E98A0900 		jmp	.L230
 9169      00
 9170              	.L473:
2061:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 9171              		.loc 1 2061 0 is_stmt 1
 9172 7496 488B85E0 		movq	-3104(%rbp), %rax
 9172      F3FFFF
 9173 749d 488DBDE8 		leaq	-3096(%rbp), %rdi
 9173      F3FFFF
 9174 74a4 488D8DB4 		leaq	-3404(%rbp), %rcx
 9174      F2FFFF
 9175 74ab 488D95B4 		leaq	-3404(%rbp), %rdx
 9175      F2FFFF
 9176 74b2 488DB5F0 		leaq	-3088(%rbp), %rsi
 9176      F3FFFF
 9177 74b9 4989F8   		movq	%rdi, %r8
 9178 74bc 4889C7   		movq	%rax, %rdi
 9179 74bf E8000000 		call	flReadChannelAsyncAwait
 9179      00
 9180 74c4 8985BCF2 		movl	%eax, -3396(%rbp)
 9180      FFFF
2062:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9181              		.loc 1 2062 0
 9182 74ca 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9182      FFFF00
 9183 74d1 740F     		je	.L474
 9184              		.loc 1 2062 0 is_stmt 0 discriminator 1
 9185 74d3 C785B8F2 		movl	$1, -3400(%rbp)
 9185      FFFF0100 
 9185      0000
 9186 74dd E93E0900 		jmp	.L230
 9186      00
 9187              	.L474:
2063:main.c        **** 						// time(&endT);
2064:main.c        **** 
2065:main.c        **** 						
2066:main.c        **** 
2067:main.c        **** 						//diff3 = difftime(startT,endT);
2068:main.c        **** 						// if(diff3 > timeout)
2069:main.c        **** 						// {
2070:main.c        **** 						// 	printf("%s\n", "Timeout happened");
2071:main.c        **** 						// 	break;
2072:main.c        **** 						// }
2073:main.c        **** 
2074:main.c        **** 						// -------------------------------------------------------------
2075:main.c        **** 						// timer part ended
2076:main.c        **** 
2077:main.c        **** 						
2078:main.c        **** 						if(direct == reset) 
 9188              		.loc 1 2078 0 is_stmt 1
 9189 74e2 0FB685A9 		movzbl	-3415(%rbp), %eax
 9189      F2FFFF
 9190 74e9 3A85AFF2 		cmpb	-3409(%rbp), %al
 9190      FFFF
 9191 74ef 751D     		jne	.L475
2079:main.c        **** 							{
2080:main.c        **** 								k--; 
 9192              		.loc 1 2080 0
 9193 74f1 83ADC8F2 		subl	$1, -3384(%rbp)
 9193      FFFF01
2081:main.c        **** 								breaker3++; 
 9194              		.loc 1 2081 0
 9195 74f8 838588F3 		addl	$1, -3192(%rbp)
 9195      FFFF01
2082:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 9196              		.loc 1 2082 0
 9197 74ff BF000000 		movl	$.LC155, %edi
 9197      00
 9198 7504 E8000000 		call	puts
 9198      00
2083:main.c        **** 								break;
 9199              		.loc 1 2083 0
 9200 7509 E93B0500 		jmp	.L476
 9200      00
 9201              	.L475:
2084:main.c        **** 							}
2085:main.c        **** 						// printf("%s\n", "Controlling signal received from FPGA, it is-----");
2086:main.c        **** 						// printf("%d\n", direct);
2087:main.c        **** 						// printf("%s\n", "Checking the controlling singal, whether it is to update CSV data or not")
2088:main.c        **** 						int director = (int)direct;
 9202              		.loc 1 2088 0
 9203 750e 0FB685A9 		movzbl	-3415(%rbp), %eax
 9203      F2FFFF
 9204 7515 0FB6C0   		movzbl	%al, %eax
 9205 7518 8985C4F3 		movl	%eax, -3132(%rbp)
 9205      FFFF
2089:main.c        **** 						if(director==decX) 
 9206              		.loc 1 2089 0
 9207 751e 8B85C4F3 		movl	-3132(%rbp), %eax
 9207      FFFF
 9208 7524 3B85BCF3 		cmpl	-3140(%rbp), %eax
 9208      FFFF
 9209 752a 750F     		jne	.L477
2090:main.c        **** 							{
2091:main.c        **** 								printf("%s\n", "No data from FPGA, gping to UART part");
 9210              		.loc 1 2091 0
 9211 752c BF000000 		movl	$.LC234, %edi
 9211      00
 9212 7531 E8000000 		call	puts
 9212      00
2092:main.c        **** 								break;
 9213              		.loc 1 2092 0
 9214 7536 E90E0500 		jmp	.L476
 9214      00
 9215              	.L477:
2093:main.c        **** 							}
2094:main.c        **** 						if(director==decY)
 9216              		.loc 1 2094 0
 9217 753b 8B85C4F3 		movl	-3132(%rbp), %eax
 9217      FFFF
 9218 7541 3B85C0F3 		cmpl	-3136(%rbp), %eax
 9218      FFFF
 9219 7547 0F85E4FE 		jne	.L501
 9219      FFFF
 9220              	.LBB96:
2095:main.c        **** 						{	
2096:main.c        **** 							updateCSV = true;
 9221              		.loc 1 2096 0
 9222 754d C685ACF2 		movb	$1, -3412(%rbp)
 9222      FFFF01
2097:main.c        **** 							printf("%s\n", "Controlling signal is to update the CSV data");
 9223              		.loc 1 2097 0
 9224 7554 BF000000 		movl	$.LC235, %edi
 9224      00
 9225 7559 E8000000 		call	puts
 9225      00
2098:main.c        **** 							printf("%s\n", "Receiving encrypted data from the FPGA to update CSV");
 9226              		.loc 1 2098 0
 9227 755e BF000000 		movl	$.LC236, %edi
 9227      00
 9228 7563 E8000000 		call	puts
 9228      00
2099:main.c        **** 							delay(del);
 9229              		.loc 1 2099 0
 9230 7568 8B85B0F3 		movl	-3152(%rbp), %eax
 9230      FFFF
 9231 756e 89C7     		movl	%eax, %edi
 9232 7570 E8000000 		call	delay
 9232      00
2100:main.c        **** 							fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &updaterFPGA[0], &error);
 9233              		.loc 1 2100 0
 9234 7575 8B85C8F2 		movl	-3384(%rbp), %eax
 9234      FFFF
 9235 757b 01C0     		addl	%eax, %eax
 9236 757d 0FB6F0   		movzbl	%al, %esi
 9237 7580 488B85E0 		movq	-3104(%rbp), %rax
 9237      F3FFFF
 9238 7587 488D8DE8 		leaq	-3096(%rbp), %rcx
 9238      F3FFFF
 9239 758e 488D55D0 		leaq	-48(%rbp), %rdx
 9240 7592 4989C8   		movq	%rcx, %r8
 9241 7595 4889D1   		movq	%rdx, %rcx
 9242 7598 BA010000 		movl	$1, %edx
 9242      00
 9243 759d 4889C7   		movq	%rax, %rdi
 9244 75a0 E8000000 		call	flReadChannelAsyncSubmit
 9244      00
 9245 75a5 8985BCF2 		movl	%eax, -3396(%rbp)
 9245      FFFF
2101:main.c        **** 							CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9246              		.loc 1 2101 0
 9247 75ab 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9247      FFFF00
 9248 75b2 740F     		je	.L479
 9249              		.loc 1 2101 0 is_stmt 0 discriminator 1
 9250 75b4 C785B8F2 		movl	$1, -3400(%rbp)
 9250      FFFF0100 
 9250      0000
 9251 75be E95D0800 		jmp	.L230
 9251      00
 9252              	.L479:
2102:main.c        **** 							fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 9253              		.loc 1 2102 0 is_stmt 1
 9254 75c3 488B85E0 		movq	-3104(%rbp), %rax
 9254      F3FFFF
 9255 75ca 488DBDE8 		leaq	-3096(%rbp), %rdi
 9255      F3FFFF
 9256 75d1 488D8DB4 		leaq	-3404(%rbp), %rcx
 9256      F2FFFF
 9257 75d8 488D95B4 		leaq	-3404(%rbp), %rdx
 9257      F2FFFF
 9258 75df 488DB5F0 		leaq	-3088(%rbp), %rsi
 9258      F3FFFF
 9259 75e6 4989F8   		movq	%rdi, %r8
 9260 75e9 4889C7   		movq	%rax, %rdi
 9261 75ec E8000000 		call	flReadChannelAsyncAwait
 9261      00
 9262 75f1 8985BCF2 		movl	%eax, -3396(%rbp)
 9262      FFFF
2103:main.c        **** 							CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9263              		.loc 1 2103 0
 9264 75f7 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9264      FFFF00
 9265 75fe 740F     		je	.L481
 9266              		.loc 1 2103 0 is_stmt 0 discriminator 1
 9267 7600 C785B8F2 		movl	$1, -3400(%rbp)
 9267      FFFF0100 
 9267      0000
 9268 760a E9350400 		jmp	.L480
 9268      00
 9269              	.L481:
2104:main.c        **** 							if(updaterFPGA[0] == reset) 
 9270              		.loc 1 2104 0 is_stmt 1
 9271 760f 0FB645D0 		movzbl	-48(%rbp), %eax
 9272 7613 3A85AFF2 		cmpb	-3409(%rbp), %al
 9272      FFFF
 9273 7619 751D     		jne	.L482
2105:main.c        **** 							{
2106:main.c        **** 								k--; 
 9274              		.loc 1 2106 0
 9275 761b 83ADC8F2 		subl	$1, -3384(%rbp)
 9275      FFFF01
2107:main.c        **** 								breaker3++; 
 9276              		.loc 1 2107 0
 9277 7622 838588F3 		addl	$1, -3192(%rbp)
 9277      FFFF01
2108:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 9278              		.loc 1 2108 0
 9279 7629 BF000000 		movl	$.LC155, %edi
 9279      00
 9280 762e E8000000 		call	puts
 9280      00
2109:main.c        **** 								break;
 9281              		.loc 1 2109 0
 9282 7633 E9110400 		jmp	.L476
 9282      00
 9283              	.L482:
2110:main.c        **** 							}
2111:main.c        **** 							delay(del);
 9284              		.loc 1 2111 0
 9285 7638 8B85B0F3 		movl	-3152(%rbp), %eax
 9285      FFFF
 9286 763e 89C7     		movl	%eax, %edi
 9287 7640 E8000000 		call	delay
 9287      00
2112:main.c        **** 							fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &updaterFPGA[1], &error);
 9288              		.loc 1 2112 0
 9289 7645 8B85C8F2 		movl	-3384(%rbp), %eax
 9289      FFFF
 9290 764b 01C0     		addl	%eax, %eax
 9291 764d 0FB6F0   		movzbl	%al, %esi
 9292 7650 488B85E0 		movq	-3104(%rbp), %rax
 9292      F3FFFF
 9293 7657 488D8DE8 		leaq	-3096(%rbp), %rcx
 9293      F3FFFF
 9294 765e 488D55D0 		leaq	-48(%rbp), %rdx
 9295 7662 4883C201 		addq	$1, %rdx
 9296 7666 4989C8   		movq	%rcx, %r8
 9297 7669 4889D1   		movq	%rdx, %rcx
 9298 766c BA010000 		movl	$1, %edx
 9298      00
 9299 7671 4889C7   		movq	%rax, %rdi
 9300 7674 E8000000 		call	flReadChannelAsyncSubmit
 9300      00
 9301 7679 8985BCF2 		movl	%eax, -3396(%rbp)
 9301      FFFF
2113:main.c        **** 							CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9302              		.loc 1 2113 0
 9303 767f 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9303      FFFF00
 9304 7686 740F     		je	.L484
 9305              		.loc 1 2113 0 is_stmt 0 discriminator 1
 9306 7688 C785B8F2 		movl	$1, -3400(%rbp)
 9306      FFFF0100 
 9306      0000
 9307 7692 E9AD0300 		jmp	.L480
 9307      00
 9308              	.L484:
2114:main.c        **** 							fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 9309              		.loc 1 2114 0 is_stmt 1
 9310 7697 488B85E0 		movq	-3104(%rbp), %rax
 9310      F3FFFF
 9311 769e 488DBDE8 		leaq	-3096(%rbp), %rdi
 9311      F3FFFF
 9312 76a5 488D8DB4 		leaq	-3404(%rbp), %rcx
 9312      F2FFFF
 9313 76ac 488D95B4 		leaq	-3404(%rbp), %rdx
 9313      F2FFFF
 9314 76b3 488DB5F0 		leaq	-3088(%rbp), %rsi
 9314      F3FFFF
 9315 76ba 4989F8   		movq	%rdi, %r8
 9316 76bd 4889C7   		movq	%rax, %rdi
 9317 76c0 E8000000 		call	flReadChannelAsyncAwait
 9317      00
 9318 76c5 8985BCF2 		movl	%eax, -3396(%rbp)
 9318      FFFF
2115:main.c        **** 							CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9319              		.loc 1 2115 0
 9320 76cb 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9320      FFFF00
 9321 76d2 740F     		je	.L485
 9322              		.loc 1 2115 0 is_stmt 0 discriminator 1
 9323 76d4 C785B8F2 		movl	$1, -3400(%rbp)
 9323      FFFF0100 
 9323      0000
 9324 76de E9610300 		jmp	.L480
 9324      00
 9325              	.L485:
2116:main.c        **** 							if(updaterFPGA[1] == reset) 
 9326              		.loc 1 2116 0 is_stmt 1
 9327 76e3 0FB645D1 		movzbl	-47(%rbp), %eax
 9328 76e7 3A85AFF2 		cmpb	-3409(%rbp), %al
 9328      FFFF
 9329 76ed 751D     		jne	.L486
2117:main.c        **** 							{
2118:main.c        **** 								k--; 
 9330              		.loc 1 2118 0
 9331 76ef 83ADC8F2 		subl	$1, -3384(%rbp)
 9331      FFFF01
2119:main.c        **** 								breaker3++; 
 9332              		.loc 1 2119 0
 9333 76f6 838588F3 		addl	$1, -3192(%rbp)
 9333      FFFF01
2120:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 9334              		.loc 1 2120 0
 9335 76fd BF000000 		movl	$.LC155, %edi
 9335      00
 9336 7702 E8000000 		call	puts
 9336      00
2121:main.c        **** 								break;
 9337              		.loc 1 2121 0
 9338 7707 E93D0300 		jmp	.L476
 9338      00
 9339              	.L486:
2122:main.c        **** 							}
2123:main.c        **** 							delay(del);
 9340              		.loc 1 2123 0
 9341 770c 8B85B0F3 		movl	-3152(%rbp), %eax
 9341      FFFF
 9342 7712 89C7     		movl	%eax, %edi
 9343 7714 E8000000 		call	delay
 9343      00
2124:main.c        **** 							fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &updaterFPGA[2], &error);
 9344              		.loc 1 2124 0
 9345 7719 8B85C8F2 		movl	-3384(%rbp), %eax
 9345      FFFF
 9346 771f 01C0     		addl	%eax, %eax
 9347 7721 0FB6F0   		movzbl	%al, %esi
 9348 7724 488B85E0 		movq	-3104(%rbp), %rax
 9348      F3FFFF
 9349 772b 488D8DE8 		leaq	-3096(%rbp), %rcx
 9349      F3FFFF
 9350 7732 488D55D0 		leaq	-48(%rbp), %rdx
 9351 7736 4883C202 		addq	$2, %rdx
 9352 773a 4989C8   		movq	%rcx, %r8
 9353 773d 4889D1   		movq	%rdx, %rcx
 9354 7740 BA010000 		movl	$1, %edx
 9354      00
 9355 7745 4889C7   		movq	%rax, %rdi
 9356 7748 E8000000 		call	flReadChannelAsyncSubmit
 9356      00
 9357 774d 8985BCF2 		movl	%eax, -3396(%rbp)
 9357      FFFF
2125:main.c        **** 							CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9358              		.loc 1 2125 0
 9359 7753 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9359      FFFF00
 9360 775a 740F     		je	.L487
 9361              		.loc 1 2125 0 is_stmt 0 discriminator 1
 9362 775c C785B8F2 		movl	$1, -3400(%rbp)
 9362      FFFF0100 
 9362      0000
 9363 7766 E9D90200 		jmp	.L480
 9363      00
 9364              	.L487:
2126:main.c        **** 							fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 9365              		.loc 1 2126 0 is_stmt 1
 9366 776b 488B85E0 		movq	-3104(%rbp), %rax
 9366      F3FFFF
 9367 7772 488DBDE8 		leaq	-3096(%rbp), %rdi
 9367      F3FFFF
 9368 7779 488D8DB4 		leaq	-3404(%rbp), %rcx
 9368      F2FFFF
 9369 7780 488D95B4 		leaq	-3404(%rbp), %rdx
 9369      F2FFFF
 9370 7787 488DB5F0 		leaq	-3088(%rbp), %rsi
 9370      F3FFFF
 9371 778e 4989F8   		movq	%rdi, %r8
 9372 7791 4889C7   		movq	%rax, %rdi
 9373 7794 E8000000 		call	flReadChannelAsyncAwait
 9373      00
 9374 7799 8985BCF2 		movl	%eax, -3396(%rbp)
 9374      FFFF
2127:main.c        **** 							CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9375              		.loc 1 2127 0
 9376 779f 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9376      FFFF00
 9377 77a6 740F     		je	.L488
 9378              		.loc 1 2127 0 is_stmt 0 discriminator 1
 9379 77a8 C785B8F2 		movl	$1, -3400(%rbp)
 9379      FFFF0100 
 9379      0000
 9380 77b2 E98D0200 		jmp	.L480
 9380      00
 9381              	.L488:
2128:main.c        **** 							if(updaterFPGA[2] == reset) 
 9382              		.loc 1 2128 0 is_stmt 1
 9383 77b7 0FB645D2 		movzbl	-46(%rbp), %eax
 9384 77bb 3A85AFF2 		cmpb	-3409(%rbp), %al
 9384      FFFF
 9385 77c1 751D     		jne	.L489
2129:main.c        **** 							{
2130:main.c        **** 								k--; 
 9386              		.loc 1 2130 0
 9387 77c3 83ADC8F2 		subl	$1, -3384(%rbp)
 9387      FFFF01
2131:main.c        **** 								breaker3++; 
 9388              		.loc 1 2131 0
 9389 77ca 838588F3 		addl	$1, -3192(%rbp)
 9389      FFFF01
2132:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 9390              		.loc 1 2132 0
 9391 77d1 BF000000 		movl	$.LC155, %edi
 9391      00
 9392 77d6 E8000000 		call	puts
 9392      00
2133:main.c        **** 								break;
 9393              		.loc 1 2133 0
 9394 77db E9690200 		jmp	.L476
 9394      00
 9395              	.L489:
2134:main.c        **** 							}
2135:main.c        **** 							delay(del);
 9396              		.loc 1 2135 0
 9397 77e0 8B85B0F3 		movl	-3152(%rbp), %eax
 9397      FFFF
 9398 77e6 89C7     		movl	%eax, %edi
 9399 77e8 E8000000 		call	delay
 9399      00
2136:main.c        **** 							fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &updaterFPGA[3], &error);
 9400              		.loc 1 2136 0
 9401 77ed 8B85C8F2 		movl	-3384(%rbp), %eax
 9401      FFFF
 9402 77f3 01C0     		addl	%eax, %eax
 9403 77f5 0FB6F0   		movzbl	%al, %esi
 9404 77f8 488B85E0 		movq	-3104(%rbp), %rax
 9404      F3FFFF
 9405 77ff 488D8DE8 		leaq	-3096(%rbp), %rcx
 9405      F3FFFF
 9406 7806 488D55D0 		leaq	-48(%rbp), %rdx
 9407 780a 4883C203 		addq	$3, %rdx
 9408 780e 4989C8   		movq	%rcx, %r8
 9409 7811 4889D1   		movq	%rdx, %rcx
 9410 7814 BA010000 		movl	$1, %edx
 9410      00
 9411 7819 4889C7   		movq	%rax, %rdi
 9412 781c E8000000 		call	flReadChannelAsyncSubmit
 9412      00
 9413 7821 8985BCF2 		movl	%eax, -3396(%rbp)
 9413      FFFF
2137:main.c        **** 							CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9414              		.loc 1 2137 0
 9415 7827 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9415      FFFF00
 9416 782e 740F     		je	.L490
 9417              		.loc 1 2137 0 is_stmt 0 discriminator 1
 9418 7830 C785B8F2 		movl	$1, -3400(%rbp)
 9418      FFFF0100 
 9418      0000
 9419 783a E9050200 		jmp	.L480
 9419      00
 9420              	.L490:
2138:main.c        **** 							fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 9421              		.loc 1 2138 0 is_stmt 1
 9422 783f 488B85E0 		movq	-3104(%rbp), %rax
 9422      F3FFFF
 9423 7846 488DBDE8 		leaq	-3096(%rbp), %rdi
 9423      F3FFFF
 9424 784d 488D8DB4 		leaq	-3404(%rbp), %rcx
 9424      F2FFFF
 9425 7854 488D95B4 		leaq	-3404(%rbp), %rdx
 9425      F2FFFF
 9426 785b 488DB5F0 		leaq	-3088(%rbp), %rsi
 9426      F3FFFF
 9427 7862 4989F8   		movq	%rdi, %r8
 9428 7865 4889C7   		movq	%rax, %rdi
 9429 7868 E8000000 		call	flReadChannelAsyncAwait
 9429      00
 9430 786d 8985BCF2 		movl	%eax, -3396(%rbp)
 9430      FFFF
2139:main.c        **** 							CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9431              		.loc 1 2139 0
 9432 7873 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9432      FFFF00
 9433 787a 740F     		je	.L491
 9434              		.loc 1 2139 0 is_stmt 0 discriminator 1
 9435 787c C785B8F2 		movl	$1, -3400(%rbp)
 9435      FFFF0100 
 9435      0000
 9436 7886 E9B90100 		jmp	.L480
 9436      00
 9437              	.L491:
2140:main.c        **** 							if(updaterFPGA[3] == reset) 
 9438              		.loc 1 2140 0 is_stmt 1
 9439 788b 0FB645D3 		movzbl	-45(%rbp), %eax
 9440 788f 3A85AFF2 		cmpb	-3409(%rbp), %al
 9440      FFFF
 9441 7895 751D     		jne	.L492
2141:main.c        **** 							{
2142:main.c        **** 								k--; 
 9442              		.loc 1 2142 0
 9443 7897 83ADC8F2 		subl	$1, -3384(%rbp)
 9443      FFFF01
2143:main.c        **** 								breaker3++;
 9444              		.loc 1 2143 0
 9445 789e 838588F3 		addl	$1, -3192(%rbp)
 9445      FFFF01
2144:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------"); 
 9446              		.loc 1 2144 0
 9447 78a5 BF000000 		movl	$.LC155, %edi
 9447      00
 9448 78aa E8000000 		call	puts
 9448      00
2145:main.c        **** 								break;
 9449              		.loc 1 2145 0
 9450 78af E9950100 		jmp	.L476
 9450      00
 9451              	.L492:
2146:main.c        **** 							}
2147:main.c        **** 
2148:main.c        **** 							printf("%s\n", "Encrypted Data received successfully from the FPGA, it is as in uint8 format
 9452              		.loc 1 2148 0
 9453 78b4 BF000000 		movl	$.LC237, %edi
 9453      00
 9454 78b9 E8000000 		call	puts
 9454      00
 9455              	.LBB97:
2149:main.c        **** 							for (int i = 0; i < 4; ++i)
 9456              		.loc 1 2149 0
 9457 78be C7858CF3 		movl	$0, -3188(%rbp)
 9457      FFFF0000 
 9457      0000
 9458 78c8 EB2D     		jmp	.L493
 9459              	.L494:
2150:main.c        **** 							{
2151:main.c        **** 								printf("%d ", updaterFPGA[3-i]);
 9460              		.loc 1 2151 0 discriminator 3
 9461 78ca B8030000 		movl	$3, %eax
 9461      00
 9462 78cf 2B858CF3 		subl	-3188(%rbp), %eax
 9462      FFFF
 9463 78d5 4898     		cltq
 9464 78d7 0FB64405 		movzbl	-48(%rbp,%rax), %eax
 9464      D0
 9465 78dc 0FB6C0   		movzbl	%al, %eax
 9466 78df 89C6     		movl	%eax, %esi
 9467 78e1 BF000000 		movl	$.LC10, %edi
 9467      00
 9468 78e6 B8000000 		movl	$0, %eax
 9468      00
 9469 78eb E8000000 		call	printf
 9469      00
2149:main.c        **** 							for (int i = 0; i < 4; ++i)
 9470              		.loc 1 2149 0 discriminator 3
 9471 78f0 83858CF3 		addl	$1, -3188(%rbp)
 9471      FFFF01
 9472              	.L493:
2149:main.c        **** 							for (int i = 0; i < 4; ++i)
 9473              		.loc 1 2149 0 is_stmt 0 discriminator 1
 9474 78f7 83BD8CF3 		cmpl	$3, -3188(%rbp)
 9474      FFFF03
 9475 78fe 7ECA     		jle	.L494
 9476              	.LBE97:
2152:main.c        **** 							}
2153:main.c        **** 							printf("\n");
 9477              		.loc 1 2153 0 is_stmt 1
 9478 7900 BF0A0000 		movl	$10, %edi
 9478      00
 9479 7905 E8000000 		call	putchar
 9479      00
2154:main.c        **** 
2155:main.c        **** 							
2156:main.c        **** 							printf("%s\n", "Converting uint8 data to binary");
 9480              		.loc 1 2156 0
 9481 790a BF000000 		movl	$.LC238, %edi
 9481      00
 9482 790f E8000000 		call	puts
 9482      00
2157:main.c        **** 							uint8ToBin(updaterFPGA, updatesFromFPGA);
 9483              		.loc 1 2157 0
 9484 7914 488D95D0 		leaq	-816(%rbp), %rdx
 9484      FCFFFF
 9485 791b 488D45D0 		leaq	-48(%rbp), %rax
 9486 791f 4889D6   		movq	%rdx, %rsi
 9487 7922 4889C7   		movq	%rax, %rdi
 9488 7925 E8000000 		call	uint8ToBin
 9488      00
2158:main.c        **** 							printf("%s\n", "Converted uint8 data to binary, it is as-----");
 9489              		.loc 1 2158 0
 9490 792a BF000000 		movl	$.LC239, %edi
 9490      00
 9491 792f E8000000 		call	puts
 9491      00
 9492              	.LBB98:
2159:main.c        **** 
2160:main.c        **** 							for (int i = 0; i < 32; ++i)
 9493              		.loc 1 2160 0
 9494 7934 C78590F3 		movl	$0, -3184(%rbp)
 9494      FFFF0000 
 9494      0000
 9495 793e EB2C     		jmp	.L495
 9496              	.L496:
2161:main.c        **** 							{
2162:main.c        **** 								printf("%d ", updatesFromFPGA[31-i]);
 9497              		.loc 1 2162 0 discriminator 3
 9498 7940 B81F0000 		movl	$31, %eax
 9498      00
 9499 7945 2B8590F3 		subl	-3184(%rbp), %eax
 9499      FFFF
 9500 794b 4898     		cltq
 9501 794d 8B8485D0 		movl	-816(%rbp,%rax,4), %eax
 9501      FCFFFF
 9502 7954 89C6     		movl	%eax, %esi
 9503 7956 BF000000 		movl	$.LC10, %edi
 9503      00
 9504 795b B8000000 		movl	$0, %eax
 9504      00
 9505 7960 E8000000 		call	printf
 9505      00
2160:main.c        **** 							{
 9506              		.loc 1 2160 0 discriminator 3
 9507 7965 838590F3 		addl	$1, -3184(%rbp)
 9507      FFFF01
 9508              	.L495:
2160:main.c        **** 							{
 9509              		.loc 1 2160 0 is_stmt 0 discriminator 1
 9510 796c 83BD90F3 		cmpl	$31, -3184(%rbp)
 9510      FFFF1F
 9511 7973 7ECB     		jle	.L496
 9512              	.LBE98:
2163:main.c        **** 							}
2164:main.c        **** 							printf("\n");
 9513              		.loc 1 2164 0 is_stmt 1
 9514 7975 BF0A0000 		movl	$10, %edi
 9514      00
 9515 797a E8000000 		call	putchar
 9515      00
2165:main.c        **** 							printf("%s\n", "Decrypting the data");
 9516              		.loc 1 2165 0
 9517 797f BF000000 		movl	$.LC240, %edi
 9517      00
 9518 7984 E8000000 		call	puts
 9518      00
2166:main.c        **** 							int decryptedUpdates[32];
2167:main.c        **** 							decrypter(updatesFromFPGA, K, decryptedUpdates);
 9519              		.loc 1 2167 0
 9520 7989 488D9550 		leaq	-688(%rbp), %rdx
 9520      FDFFFF
 9521 7990 488D8DD0 		leaq	-2608(%rbp), %rcx
 9521      F5FFFF
 9522 7997 488D85D0 		leaq	-816(%rbp), %rax
 9522      FCFFFF
 9523 799e 4889CE   		movq	%rcx, %rsi
 9524 79a1 4889C7   		movq	%rax, %rdi
 9525 79a4 E8000000 		call	decrypter
 9525      00
2168:main.c        **** 							printf("%s\n", "Data decrypted successfully, it is as----");
 9526              		.loc 1 2168 0
 9527 79a9 BF000000 		movl	$.LC241, %edi
 9527      00
 9528 79ae E8000000 		call	puts
 9528      00
 9529              	.LBB99:
2169:main.c        **** 							for (int i = 0; i < 32; ++i)
 9530              		.loc 1 2169 0
 9531 79b3 C78594F3 		movl	$0, -3180(%rbp)
 9531      FFFF0000 
 9531      0000
 9532 79bd EB2C     		jmp	.L497
 9533              	.L498:
2170:main.c        **** 							{
2171:main.c        **** 								printf("%d ", decryptedUpdates[31-i]);
 9534              		.loc 1 2171 0 discriminator 3
 9535 79bf B81F0000 		movl	$31, %eax
 9535      00
 9536 79c4 2B8594F3 		subl	-3180(%rbp), %eax
 9536      FFFF
 9537 79ca 4898     		cltq
 9538 79cc 8B848550 		movl	-688(%rbp,%rax,4), %eax
 9538      FDFFFF
 9539 79d3 89C6     		movl	%eax, %esi
 9540 79d5 BF000000 		movl	$.LC10, %edi
 9540      00
 9541 79da B8000000 		movl	$0, %eax
 9541      00
 9542 79df E8000000 		call	printf
 9542      00
2169:main.c        **** 							for (int i = 0; i < 32; ++i)
 9543              		.loc 1 2169 0 discriminator 3
 9544 79e4 838594F3 		addl	$1, -3180(%rbp)
 9544      FFFF01
 9545              	.L497:
2169:main.c        **** 							for (int i = 0; i < 32; ++i)
 9546              		.loc 1 2169 0 is_stmt 0 discriminator 1
 9547 79eb 83BD94F3 		cmpl	$31, -3180(%rbp)
 9547      FFFF1F
 9548 79f2 7ECB     		jle	.L498
 9549              	.LBE99:
2172:main.c        **** 							}
2173:main.c        **** 							printf("\n");
 9550              		.loc 1 2173 0 is_stmt 1
 9551 79f4 BF0A0000 		movl	$10, %edi
 9551      00
 9552 79f9 E8000000 		call	putchar
 9552      00
2174:main.c        **** 							printf("%s\n", "Getting ready to update CSV");
 9553              		.loc 1 2174 0
 9554 79fe BF000000 		movl	$.LC242, %edi
 9554      00
 9555 7a03 E8000000 		call	puts
 9555      00
 9556              	.LBB100:
2175:main.c        **** 							
2176:main.c        **** 							
2177:main.c        **** 							for (int i = 0; i < 8; ++i)
 9557              		.loc 1 2177 0
 9558 7a08 C78598F3 		movl	$0, -3176(%rbp)
 9558      FFFF0000 
 9558      0000
 9559 7a12 EB25     		jmp	.L499
 9560              	.L500:
2178:main.c        **** 								updatesForCSV[i] = decryptedUpdates[i];
 9561              		.loc 1 2178 0 discriminator 3
 9562 7a14 8B8598F3 		movl	-3176(%rbp), %eax
 9562      FFFF
 9563 7a1a 4898     		cltq
 9564 7a1c 8B948550 		movl	-688(%rbp,%rax,4), %edx
 9564      FDFFFF
 9565 7a23 8B8598F3 		movl	-3176(%rbp), %eax
 9565      FFFF
 9566 7a29 4898     		cltq
 9567 7a2b 89948570 		movl	%edx, -2704(%rbp,%rax,4)
 9567      F5FFFF
2177:main.c        **** 								updatesForCSV[i] = decryptedUpdates[i];
 9568              		.loc 1 2177 0 discriminator 3
 9569 7a32 838598F3 		addl	$1, -3176(%rbp)
 9569      FFFF01
 9570              	.L499:
2177:main.c        **** 								updatesForCSV[i] = decryptedUpdates[i];
 9571              		.loc 1 2177 0 is_stmt 0 discriminator 1
 9572 7a39 83BD98F3 		cmpl	$7, -3176(%rbp)
 9572      FFFF07
 9573 7a40 7ED2     		jle	.L500
 9574              	.LBE100:
2179:main.c        **** 
2180:main.c        **** 							// exists = updatesForCSV[7];
2181:main.c        **** 							// ok = updatesForCSV[6];
2182:main.c        **** 							// dir = 4*updatesForCSV[5] + 2*updatesForCSV[4] + updatesForCSV[3];
2183:main.c        **** 							// nxt = 4*updatesForCSV[2] + 2*updatesForCSV[1] + updatesForCSV[0];
2184:main.c        **** 
2185:main.c        **** 							// printf("%s\n", "The information received from FPGA");
2186:main.c        **** 							// printf("%s ", "Track exists   ---->   ");
2187:main.c        **** 							// printf("%d\n", exists);
2188:main.c        **** 							// printf("%s ", "Track ok   ----->   ");
2189:main.c        **** 							// printf("%d\n", ok);
2190:main.c        **** 							// printf("%s ", "Direction   ----->   ");
2191:main.c        **** 							// printf("%d\n", dir);
2192:main.c        **** 							// printf("%s ", "Next signal   ------>    ");
2193:main.c        **** 							// printf("%d\n", nxt);
2194:main.c        **** 
2195:main.c        **** 							// printf("%s\n", "Overwriting the CSV file with the updated information");
2196:main.c        **** 							// writecsv(x_cord, y_cord, ok, dir, nxt);
2197:main.c        **** 							// printf("%s\n", "CSV file overwritten successfully");
2198:main.c        **** 							 break;
 9575              		.loc 1 2198 0 is_stmt 1
 9576 7a42 EB05     		jmp	.L476
 9577              	.L480:
 9578              	.LBE96:
 9579              	.LBE95:
 9580              	.LBE104:
 9581              	.LBE108:
 9582              	.LBE112:
1294:main.c        **** 			fStatus = flIsFPGARunning(handle, &isRunning, &error);
 9583              		.loc 1 1294 0 discriminator 2
 9584 7a44 E9D70300 		jmp	.L230
 9584      00
 9585              	.L476:
 9586              	.LBB113:
 9587              	.LBB109:
 9588              	.LBB105:
2199:main.c        **** 						}
2200:main.c        **** 					}
2201:main.c        **** 
2202:main.c        **** 					if(breaker3 >= 1) continue;
 9589              		.loc 1 2202 0
 9590 7a49 83BD88F3 		cmpl	$0, -3192(%rbp)
 9590      FFFF00
 9591 7a50 0F8F5803 		jg	.L526
 9591      0000
2203:main.c        **** 
2204:main.c        **** 					printf("%s\n", "-------------------------UART PART----------------------------");
 9592              		.loc 1 2204 0
 9593 7a56 BF000000 		movl	$.LC243, %edi
 9593      00
 9594 7a5b E8000000 		call	puts
 9594      00
2205:main.c        **** 					int Z[8] = {1,0,0,0,0,0,0,0};
 9595              		.loc 1 2205 0
 9596 7a60 48C78550 		movq	$0, -688(%rbp)
 9596      FDFFFF00 
 9596      000000
 9597 7a6b 48C78558 		movq	$0, -680(%rbp)
 9597      FDFFFF00 
 9597      000000
 9598 7a76 48C78560 		movq	$0, -672(%rbp)
 9598      FDFFFF00 
 9598      000000
 9599 7a81 48C78568 		movq	$0, -664(%rbp)
 9599      FDFFFF00 
 9599      000000
 9600 7a8c C78550FD 		movl	$1, -688(%rbp)
 9600      FFFF0100 
 9600      0000
2206:main.c        **** 					//int W[8] = {0,0,0,0,0,0,0,0};
2207:main.c        **** 					int decZ = bitArrayToInt(Z, 8);
 9601              		.loc 1 2207 0
 9602 7a96 488D8550 		leaq	-688(%rbp), %rax
 9602      FDFFFF
 9603 7a9d BE080000 		movl	$8, %esi
 9603      00
 9604 7aa2 4889C7   		movq	%rax, %rdi
 9605 7aa5 E8000000 		call	bitArrayToInt
 9605      00
 9606 7aaa 8985C8F3 		movl	%eax, -3128(%rbp)
 9606      FFFF
2208:main.c        **** 					//int decW = bitArrayToInt(W, 8);
2209:main.c        **** 
2210:main.c        **** 					uint8 direct2;
2211:main.c        **** 					int breaker4 = 0;
 9607              		.loc 1 2211 0
 9608 7ab0 C7859CF3 		movl	$0, -3172(%rbp)
 9608      FFFF0000 
 9608      0000
 9609              	.L508:
 9610              	.LBB101:
2212:main.c        **** 
2213:main.c        **** 					while(1)
2214:main.c        **** 					{	
2215:main.c        **** 						//printf("%s", " UART Count " );
2216:main.c        **** 						cnt2++;
 9611              		.loc 1 2216 0
 9612 7aba 838584F3 		addl	$1, -3196(%rbp)
 9612      FFFF01
2217:main.c        **** 						//printf("%d\n", cnt2);
2218:main.c        **** 						//printf("%s\n", "Waiting for UART signal ");
2219:main.c        **** 						delay(del);
 9613              		.loc 1 2219 0
 9614 7ac1 8B85B0F3 		movl	-3152(%rbp), %eax
 9614      FFFF
 9615 7ac7 89C7     		movl	%eax, %edi
 9616 7ac9 E8000000 		call	delay
 9616      00
2220:main.c        **** 						fStatus = flReadChannelAsyncSubmit(handle, 2*k, 1, &direct2, &error);
 9617              		.loc 1 2220 0
 9618 7ace 8B85C8F2 		movl	-3384(%rbp), %eax
 9618      FFFF
 9619 7ad4 01C0     		addl	%eax, %eax
 9620 7ad6 0FB6F0   		movzbl	%al, %esi
 9621 7ad9 488B85E0 		movq	-3104(%rbp), %rax
 9621      F3FFFF
 9622 7ae0 488D8DE8 		leaq	-3096(%rbp), %rcx
 9622      F3FFFF
 9623 7ae7 488D95AA 		leaq	-3414(%rbp), %rdx
 9623      F2FFFF
 9624 7aee 4989C8   		movq	%rcx, %r8
 9625 7af1 4889D1   		movq	%rdx, %rcx
 9626 7af4 BA010000 		movl	$1, %edx
 9626      00
 9627 7af9 4889C7   		movq	%rax, %rdi
 9628 7afc E8000000 		call	flReadChannelAsyncSubmit
 9628      00
 9629 7b01 8985BCF2 		movl	%eax, -3396(%rbp)
 9629      FFFF
2221:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9630              		.loc 1 2221 0
 9631 7b07 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9631      FFFF00
 9632 7b0e 740F     		je	.L503
 9633              		.loc 1 2221 0 is_stmt 0 discriminator 1
 9634 7b10 C785B8F2 		movl	$1, -3400(%rbp)
 9634      FFFF0100 
 9634      0000
 9635 7b1a E9010300 		jmp	.L230
 9635      00
 9636              	.L503:
2222:main.c        **** 						fStatus = flReadChannelAsyncAwait(handle, &recvData, &actualLength, &actualLength, &error);
 9637              		.loc 1 2222 0 is_stmt 1
 9638 7b1f 488B85E0 		movq	-3104(%rbp), %rax
 9638      F3FFFF
 9639 7b26 488DBDE8 		leaq	-3096(%rbp), %rdi
 9639      F3FFFF
 9640 7b2d 488D8DB4 		leaq	-3404(%rbp), %rcx
 9640      F2FFFF
 9641 7b34 488D95B4 		leaq	-3404(%rbp), %rdx
 9641      F2FFFF
 9642 7b3b 488DB5F0 		leaq	-3088(%rbp), %rsi
 9642      F3FFFF
 9643 7b42 4989F8   		movq	%rdi, %r8
 9644 7b45 4889C7   		movq	%rax, %rdi
 9645 7b48 E8000000 		call	flReadChannelAsyncAwait
 9645      00
 9646 7b4d 8985BCF2 		movl	%eax, -3396(%rbp)
 9646      FFFF
2223:main.c        **** 						CHECK_STATUS(fStatus, FLP_LIBERR, cleanup);
 9647              		.loc 1 2223 0
 9648 7b53 83BDBCF2 		cmpl	$0, -3396(%rbp)
 9648      FFFF00
 9649 7b5a 740F     		je	.L504
 9650              		.loc 1 2223 0 is_stmt 0 discriminator 1
 9651 7b5c C785B8F2 		movl	$1, -3400(%rbp)
 9651      FFFF0100 
 9651      0000
 9652 7b66 E9B50200 		jmp	.L230
 9652      00
 9653              	.L504:
2224:main.c        **** 						if(direct2 == reset) 
 9654              		.loc 1 2224 0 is_stmt 1
 9655 7b6b 0FB685AA 		movzbl	-3414(%rbp), %eax
 9655      F2FFFF
 9656 7b72 3A85AFF2 		cmpb	-3409(%rbp), %al
 9656      FFFF
 9657 7b78 751A     		jne	.L505
2225:main.c        **** 							{
2226:main.c        **** 								k--; 
 9658              		.loc 1 2226 0
 9659 7b7a 83ADC8F2 		subl	$1, -3384(%rbp)
 9659      FFFF01
2227:main.c        **** 								breaker4++; 
 9660              		.loc 1 2227 0
 9661 7b81 83859CF3 		addl	$1, -3172(%rbp)
 9661      FFFF01
2228:main.c        **** 								printf("%s\n", "-------------------------RESET------------------------");
 9662              		.loc 1 2228 0
 9663 7b88 BF000000 		movl	$.LC155, %edi
 9663      00
 9664 7b8d E8000000 		call	puts
 9664      00
2229:main.c        **** 								break;
 9665              		.loc 1 2229 0
 9666 7b92 EB2C     		jmp	.L506
 9667              	.L505:
2230:main.c        **** 							}
2231:main.c        **** 						//printf("%s\n", "Controlling signal received from UART, it is-----");
2232:main.c        **** 						//printf("%d\n", direct2);
2233:main.c        **** 						//printf("%s\n", "Checking the controlling singal, whether it is to update CSV data or not");
2234:main.c        **** 						int director = (int)direct2;
 9668              		.loc 1 2234 0
 9669 7b94 0FB685AA 		movzbl	-3414(%rbp), %eax
 9669      F2FFFF
 9670 7b9b 0FB6C0   		movzbl	%al, %eax
 9671 7b9e 8985CCF3 		movl	%eax, -3124(%rbp)
 9671      FFFF
2235:main.c        **** 						if(director==decZ) 
 9672              		.loc 1 2235 0
 9673 7ba4 8B85CCF3 		movl	-3124(%rbp), %eax
 9673      FFFF
 9674 7baa 3B85C8F3 		cmpl	-3128(%rbp), %eax
 9674      FFFF
 9675 7bb0 0F8504FF 		jne	.L508
 9675      FFFF
2236:main.c        **** 							{
2237:main.c        **** 								printf("%s\n", "UART part done");
 9676              		.loc 1 2237 0
 9677 7bb6 BF000000 		movl	$.LC244, %edi
 9677      00
 9678 7bbb E8000000 		call	puts
 9678      00
 9679              	.L506:
 9680              	.LBE101:
2238:main.c        **** 								break;
2239:main.c        **** 							}
2240:main.c        **** 						// if(director==decW)
2241:main.c        **** 						// {
2242:main.c        **** 						// 	printf("%s\n", "Controlling signal is to update the CSV data");
2243:main.c        **** 						// 	printf("%s\n", "Receiving encrypted data from the UART update CSV");
2244:main.c        **** 						// 	delay(del);
2245:main.c        **** 						// 	fStatus = flReadChannel(handle, 2*k, 1, &direct2, &error);
2246:main.c        **** 						// 	if(direct2 == reset) 
2247:main.c        **** 						// 	{
2248:main.c        **** 						// 		k--; 
2249:main.c        **** 						// 		breaker4++;
2250:main.c        **** 						// 		printf("%s\n", "-------------------------RESET------------------------"); 
2251:main.c        **** 						// 		break;
2252:main.c        **** 						// 	}
2253:main.c        **** 		 			// 		// delay(del);
2254:main.c        **** 		 			// 		// fStatus = flReadChannel(handle, 2*k, 1, &updaterUART[1], &error);
2255:main.c        **** 		 			// 		// delay(del);
2256:main.c        **** 		 			// 		// fStatus = flReadChannel(handle, 2*k, 1, &updaterUART[2], &error);
2257:main.c        **** 		 			// 		// delay(del);
2258:main.c        **** 		 			// 		// fStatus = flReadChannel(handle, 2*k, 1, &updaterUART[3], &error);
2259:main.c        **** 
2260:main.c        **** 		 			// 		// printf("%s\n", "Encrypted Data received successfully from the UART, it is as in uint8
2261:main.c        **** 		 			// 		// for (int i = 0; i < 4; ++i)
2262:main.c        **** 		 			// 		// {
2263:main.c        **** 		 			// 		// 	printf("%d ", updaterUART[i]);
2264:main.c        **** 		 			// 		// }
2265:main.c        **** 						// 	printf("%d\n", direct2);
2266:main.c        **** 
2267:main.c        **** 						// 	int updatesFromUART[8];
2268:main.c        **** 						// 	printf("%s\n", "Converting uint8 data to binary");
2269:main.c        **** 						// 	decToBinary(direct2, updatesFromUART, 8);
2270:main.c        **** 						// 	printf("%s\n", "Converted uint8 data to binary, it is as-----");
2271:main.c        **** 
2272:main.c        **** 						// 	for (int i = 0; i < 8; ++i)
2273:main.c        **** 						// 	{
2274:main.c        **** 						// 		printf("%d ", updatesFromUART[7-i]);
2275:main.c        **** 						// 	}
2276:main.c        **** 						// 	printf("\n");
2277:main.c        **** 		 			// 		// printf("%s\n", "Decrypting the data");
2278:main.c        **** 		 			// 		// int decryptedUpdates[32];
2279:main.c        **** 		 			// 		// decrypter(updatesFromUART, K, decryptedUpdates);
2280:main.c        **** 		 			// 		// printf("%s\n", "Data decrypted successfully, it is as----");
2281:main.c        **** 		 			// 		// for (int i = 0; i < 32; ++i)
2282:main.c        **** 		 			// 		// {
2283:main.c        **** 		 			// 		// 	printf("%d ", decryptedUpdates[i]);
2284:main.c        **** 		 			// 		// }
2285:main.c        **** 		 			// 		// printf("\n");
2286:main.c        **** 						// 	printf("%s\n", "Getting ready to update CSV");
2287:main.c        **** 		 			// 		// int updatesForCSV[8];
2288:main.c        **** 						// 	int exists, ok, dir, nxt;
2289:main.c        **** 		 			// 		// for (int i = 0; i < 8; ++i)
2290:main.c        **** 		 			// 		// 	updatesForCSV[i] = decryptedUpdates[i];
2291:main.c        **** 
2292:main.c        **** 						// 	exists = updatesFromUART[7];
2293:main.c        **** 						// 	ok = updatesFromUART[6];
2294:main.c        **** 						// 	dir = 4*updatesFromUART[5] + 2*updatesFromUART[4] + updatesFromUART[3];
2295:main.c        **** 						// 	nxt = 4*updatesFromUART[2] + 2*updatesFromUART[1] + updatesFromUART[0];
2296:main.c        **** 
2297:main.c        **** 						// 	printf("%s\n", "The information received from UART");
2298:main.c        **** 						// 	printf("%s ", "Track exists   ---->   ");
2299:main.c        **** 						// 	printf("%d\n", exists);
2300:main.c        **** 						// 	printf("%s ", "Track ok   ----->   ");
2301:main.c        **** 						// 	printf("%d\n", ok);
2302:main.c        **** 						// 	printf("%s ", "Direction   ----->   ");
2303:main.c        **** 						// 	printf("%d\n", dir);
2304:main.c        **** 						// 	printf("%s ", "Next signal   ------>    ");
2305:main.c        **** 						// 	printf("%d\n", nxt);
2306:main.c        **** 
2307:main.c        **** 						// 	printf("%s\n", "Overwriting the CSV file with the updated information");
2308:main.c        **** 						// 	writecsv(x_cord, y_cord, ok, dir, nxt);
2309:main.c        **** 						// 	printf("%s\n", "CSV file overwritten successfully");
2310:main.c        **** 						// 	break;
2311:main.c        **** 						// }
2312:main.c        **** 					}
2313:main.c        **** 
2314:main.c        **** 					if(breaker4 >= 1)
 9681              		.loc 1 2314 0
 9682 7bc0 83BD9CF3 		cmpl	$0, -3172(%rbp)
 9682      FFFF00
 9683 7bc7 0F8FE401 		jg	.L527
 9683      0000
2315:main.c        **** 					{
2316:main.c        **** 						continue;
2317:main.c        **** 					}
2318:main.c        **** 					
2319:main.c        **** 					if(updateCSV==true){
 9684              		.loc 1 2319 0
 9685 7bcd 80BDACF2 		cmpb	$0, -3412(%rbp)
 9685      FFFF00
 9686 7bd4 0F84AB01 		je	.L510
 9686      0000
2320:main.c        **** 						exists = updatesForCSV[7];
 9687              		.loc 1 2320 0
 9688 7bda 8B858CF5 		movl	-2676(%rbp), %eax
 9688      FFFF
 9689 7be0 8985D0F3 		movl	%eax, -3120(%rbp)
 9689      FFFF
2321:main.c        **** 						ok = updatesForCSV[6];
 9690              		.loc 1 2321 0
 9691 7be6 8B8588F5 		movl	-2680(%rbp), %eax
 9691      FFFF
 9692 7bec 8985D4F3 		movl	%eax, -3116(%rbp)
 9692      FFFF
2322:main.c        **** 						dir = 4*updatesForCSV[5] + 2*updatesForCSV[4] + updatesForCSV[3];
 9693              		.loc 1 2322 0
 9694 7bf2 8B8584F5 		movl	-2684(%rbp), %eax
 9694      FFFF
 9695 7bf8 8D1400   		leal	(%rax,%rax), %edx
 9696 7bfb 8B8580F5 		movl	-2688(%rbp), %eax
 9696      FFFF
 9697 7c01 01D0     		addl	%edx, %eax
 9698 7c03 8D1400   		leal	(%rax,%rax), %edx
 9699 7c06 8B857CF5 		movl	-2692(%rbp), %eax
 9699      FFFF
 9700 7c0c 01D0     		addl	%edx, %eax
 9701 7c0e 8985D8F3 		movl	%eax, -3112(%rbp)
 9701      FFFF
2323:main.c        **** 						nxt = 4*updatesForCSV[2] + 2*updatesForCSV[1] + updatesForCSV[0];
 9702              		.loc 1 2323 0
 9703 7c14 8B8578F5 		movl	-2696(%rbp), %eax
 9703      FFFF
 9704 7c1a 8D1400   		leal	(%rax,%rax), %edx
 9705 7c1d 8B8574F5 		movl	-2700(%rbp), %eax
 9705      FFFF
 9706 7c23 01D0     		addl	%edx, %eax
 9707 7c25 8D1400   		leal	(%rax,%rax), %edx
 9708 7c28 8B8570F5 		movl	-2704(%rbp), %eax
 9708      FFFF
 9709 7c2e 01D0     		addl	%edx, %eax
 9710 7c30 8985DCF3 		movl	%eax, -3108(%rbp)
 9710      FFFF
2324:main.c        **** 
2325:main.c        **** 						printf("%s\n", "The information received from FPGA");
 9711              		.loc 1 2325 0
 9712 7c36 BF000000 		movl	$.LC245, %edi
 9712      00
 9713 7c3b E8000000 		call	puts
 9713      00
2326:main.c        **** 						printf("%s", "The x_cord ----->");
 9714              		.loc 1 2326 0
 9715 7c40 BE000000 		movl	$.LC246, %esi
 9715      00
 9716 7c45 BF000000 		movl	$.LC151, %edi
 9716      00
 9717 7c4a B8000000 		movl	$0, %eax
 9717      00
 9718 7c4f E8000000 		call	printf
 9718      00
2327:main.c        **** 						printf("%d\n", x_cord);
 9719              		.loc 1 2327 0
 9720 7c54 8B85B4F3 		movl	-3148(%rbp), %eax
 9720      FFFF
 9721 7c5a 89C6     		movl	%eax, %esi
 9722 7c5c BF000000 		movl	$.LC152, %edi
 9722      00
 9723 7c61 B8000000 		movl	$0, %eax
 9723      00
 9724 7c66 E8000000 		call	printf
 9724      00
2328:main.c        **** 						printf("%s", "The y_cord ----->");
 9725              		.loc 1 2328 0
 9726 7c6b BE000000 		movl	$.LC247, %esi
 9726      00
 9727 7c70 BF000000 		movl	$.LC151, %edi
 9727      00
 9728 7c75 B8000000 		movl	$0, %eax
 9728      00
 9729 7c7a E8000000 		call	printf
 9729      00
2329:main.c        **** 						printf("%d\n", y_cord);
 9730              		.loc 1 2329 0
 9731 7c7f 8B85B8F3 		movl	-3144(%rbp), %eax
 9731      FFFF
 9732 7c85 89C6     		movl	%eax, %esi
 9733 7c87 BF000000 		movl	$.LC152, %edi
 9733      00
 9734 7c8c B8000000 		movl	$0, %eax
 9734      00
 9735 7c91 E8000000 		call	printf
 9735      00
2330:main.c        **** 						printf("%s ", "Track exists   ---->   ");
 9736              		.loc 1 2330 0
 9737 7c96 BE000000 		movl	$.LC248, %esi
 9737      00
 9738 7c9b BF000000 		movl	$.LC249, %edi
 9738      00
 9739 7ca0 B8000000 		movl	$0, %eax
 9739      00
 9740 7ca5 E8000000 		call	printf
 9740      00
2331:main.c        **** 						printf("%d\n", exists);
 9741              		.loc 1 2331 0
 9742 7caa 8B85D0F3 		movl	-3120(%rbp), %eax
 9742      FFFF
 9743 7cb0 89C6     		movl	%eax, %esi
 9744 7cb2 BF000000 		movl	$.LC152, %edi
 9744      00
 9745 7cb7 B8000000 		movl	$0, %eax
 9745      00
 9746 7cbc E8000000 		call	printf
 9746      00
2332:main.c        **** 						printf("%s ", "Track ok   ----->   ");
 9747              		.loc 1 2332 0
 9748 7cc1 BE000000 		movl	$.LC250, %esi
 9748      00
 9749 7cc6 BF000000 		movl	$.LC249, %edi
 9749      00
 9750 7ccb B8000000 		movl	$0, %eax
 9750      00
 9751 7cd0 E8000000 		call	printf
 9751      00
2333:main.c        **** 						printf("%d\n", ok);
 9752              		.loc 1 2333 0
 9753 7cd5 8B85D4F3 		movl	-3116(%rbp), %eax
 9753      FFFF
 9754 7cdb 89C6     		movl	%eax, %esi
 9755 7cdd BF000000 		movl	$.LC152, %edi
 9755      00
 9756 7ce2 B8000000 		movl	$0, %eax
 9756      00
 9757 7ce7 E8000000 		call	printf
 9757      00
2334:main.c        **** 						printf("%s ", "Direction   ----->   ");
 9758              		.loc 1 2334 0
 9759 7cec BE000000 		movl	$.LC251, %esi
 9759      00
 9760 7cf1 BF000000 		movl	$.LC249, %edi
 9760      00
 9761 7cf6 B8000000 		movl	$0, %eax
 9761      00
 9762 7cfb E8000000 		call	printf
 9762      00
2335:main.c        **** 						printf("%d\n", dir);
 9763              		.loc 1 2335 0
 9764 7d00 8B85D8F3 		movl	-3112(%rbp), %eax
 9764      FFFF
 9765 7d06 89C6     		movl	%eax, %esi
 9766 7d08 BF000000 		movl	$.LC152, %edi
 9766      00
 9767 7d0d B8000000 		movl	$0, %eax
 9767      00
 9768 7d12 E8000000 		call	printf
 9768      00
2336:main.c        **** 						printf("%s ", "Next signal   ------>    ");
 9769              		.loc 1 2336 0
 9770 7d17 BE000000 		movl	$.LC252, %esi
 9770      00
 9771 7d1c BF000000 		movl	$.LC249, %edi
 9771      00
 9772 7d21 B8000000 		movl	$0, %eax
 9772      00
 9773 7d26 E8000000 		call	printf
 9773      00
2337:main.c        **** 						printf("%d\n", nxt);
 9774              		.loc 1 2337 0
 9775 7d2b 8B85DCF3 		movl	-3108(%rbp), %eax
 9775      FFFF
 9776 7d31 89C6     		movl	%eax, %esi
 9777 7d33 BF000000 		movl	$.LC152, %edi
 9777      00
 9778 7d38 B8000000 		movl	$0, %eax
 9778      00
 9779 7d3d E8000000 		call	printf
 9779      00
2338:main.c        **** 						printf("%s\n", "Overwriting the CSV file with the updated information");
 9780              		.loc 1 2338 0
 9781 7d42 BF000000 		movl	$.LC253, %edi
 9781      00
 9782 7d47 E8000000 		call	puts
 9782      00
2339:main.c        **** 						writecsv(x_cord, y_cord, ok, dir, nxt);
 9783              		.loc 1 2339 0
 9784 7d4c 8BBDDCF3 		movl	-3108(%rbp), %edi
 9784      FFFF
 9785 7d52 8B8DD8F3 		movl	-3112(%rbp), %ecx
 9785      FFFF
 9786 7d58 8B95D4F3 		movl	-3116(%rbp), %edx
 9786      FFFF
 9787 7d5e 8BB5B8F3 		movl	-3144(%rbp), %esi
 9787      FFFF
 9788 7d64 8B85B4F3 		movl	-3148(%rbp), %eax
 9788      FFFF
 9789 7d6a 4189F8   		movl	%edi, %r8d
 9790 7d6d 89C7     		movl	%eax, %edi
 9791 7d6f E8000000 		call	writecsv
 9791      00
2340:main.c        **** 						printf("%s\n", "CSV file overwritten successfully");
 9792              		.loc 1 2340 0
 9793 7d74 BF000000 		movl	$.LC254, %edi
 9793      00
 9794 7d79 E8000000 		call	puts
 9794      00
2341:main.c        **** 								
2342:main.c        **** 			 			//delay(32000000);
2343:main.c        **** 						
2344:main.c        **** 						updateCSV=false;						
 9795              		.loc 1 2344 0
 9796 7d7e C685ACF2 		movb	$0, -3412(%rbp)
 9796      FFFF00
 9797              	.L510:
2345:main.c        **** 					}
2346:main.c        **** 					k = k-1;
 9798              		.loc 1 2346 0
 9799 7d85 83ADC8F2 		subl	$1, -3384(%rbp)
 9799      FFFF01
2347:main.c        **** 					delay(5*del);
 9800              		.loc 1 2347 0
 9801 7d8c 8B95B0F3 		movl	-3152(%rbp), %edx
 9801      FFFF
 9802 7d92 89D0     		movl	%edx, %eax
 9803 7d94 C1E002   		sall	$2, %eax
 9804 7d97 01D0     		addl	%edx, %eax
 9805 7d99 89C7     		movl	%eax, %edi
 9806 7d9b E8000000 		call	delay
 9806      00
2348:main.c        **** 					continue;
 9807              		.loc 1 2348 0
 9808 7da0 EB10     		jmp	.L305
 9809              	.L521:
1596:main.c        **** 					}
 9810              		.loc 1 1596 0
 9811 7da2 90       		nop
 9812 7da3 EB0D     		jmp	.L305
 9813              	.L523:
1842:main.c        **** 
 9814              		.loc 1 1842 0
 9815 7da5 90       		nop
 9816 7da6 EB0A     		jmp	.L305
 9817              	.L524:
1846:main.c        **** 					}
 9818              		.loc 1 1846 0
 9819 7da8 90       		nop
 9820 7da9 EB07     		jmp	.L305
 9821              	.L525:
1987:main.c        **** 
 9822              		.loc 1 1987 0
 9823 7dab 90       		nop
 9824 7dac EB04     		jmp	.L305
 9825              	.L526:
2202:main.c        **** 
 9826              		.loc 1 2202 0
 9827 7dae 90       		nop
 9828 7daf EB01     		jmp	.L305
 9829              	.L527:
2316:main.c        **** 					}
 9830              		.loc 1 2316 0
 9831 7db1 90       		nop
 9832              	.L305:
 9833              	.LBE105:
1309:main.c        **** 				{	printf("%s","Channel = " );
 9834              		.loc 1 1309 0 discriminator 1
 9835 7db2 8385C8F2 		addl	$1, -3384(%rbp)
 9835      FFFF01
 9836              	.L300:
 9837 7db9 83BDC8F2 		cmpl	$63, -3384(%rbp)
 9837      FFFF3F
 9838 7dc0 0F8EA1CC 		jle	.L511
 9838      FFFF
 9839 7dc6 EB58     		jmp	.L230
 9840              	.L299:
 9841              	.LBE109:
 9842              	.LBE113:
2349:main.c        **** 
2350:main.c        **** 
2351:main.c        **** 				}
2352:main.c        **** 
2353:main.c        **** 			} 
2354:main.c        **** 			else 
2355:main.c        **** 			{
2356:main.c        **** 				fprintf(stderr, "The FPGALink device at %s is not ready to talk - did you forget --xsvf?\n", vp
 9843              		.loc 1 2356 0
 9844 7dc8 488B0500 		movq	stderr(%rip), %rax
 9844      000000
 9845 7dcf 488B95B8 		movq	-2888(%rbp), %rdx
 9845      F4FFFF
 9846 7dd6 BE000000 		movl	$.LC148, %esi
 9846      00
 9847 7ddb 4889C7   		movq	%rax, %rdi
 9848 7dde B8000000 		movl	$0, %eax
 9848      00
 9849 7de3 E8000000 		call	fprintf
 9849      00
2357:main.c        **** 				FAIL(FLP_ARGS, cleanup);
 9850              		.loc 1 2357 0
 9851 7de8 C785B8F2 		movl	$12, -3400(%rbp)
 9851      FFFF0C00 
 9851      0000
 9852 7df2 90       		nop
 9853 7df3 EB2B     		jmp	.L230
 9854              	.L295:
 9855              	.LBE50:
2358:main.c        **** 			}
2359:main.c        **** 		} 
2360:main.c        **** 		else 
2361:main.c        **** 		{
2362:main.c        **** 			fprintf(stderr, "Shell requested but device at %s does not support CommFPGA\n", vp);
 9856              		.loc 1 2362 0
 9857 7df5 488B0500 		movq	stderr(%rip), %rax
 9857      000000
 9858 7dfc 488B95B8 		movq	-2888(%rbp), %rdx
 9858      F4FFFF
 9859 7e03 BE000000 		movl	$.LC149, %esi
 9859      00
 9860 7e08 4889C7   		movq	%rax, %rdi
 9861 7e0b B8000000 		movl	$0, %eax
 9861      00
 9862 7e10 E8000000 		call	fprintf
 9862      00
2363:main.c        **** 			FAIL(FLP_ARGS, cleanup);
 9863              		.loc 1 2363 0
 9864 7e15 C785B8F2 		movl	$12, -3400(%rbp)
 9864      FFFF0C00 
 9864      0000
 9865 7e1f 90       		nop
 9866              	.L230:
2364:main.c        **** 		}
2365:main.c        **** 
2366:main.c        **** 
2367:main.c        **** 	}
2368:main.c        **** 
2369:main.c        **** ///////////////////////////////////////////////////////////////////////////////////////////////////
2370:main.c        **** ///////////////////////////////////////////////////////////////////////////////////////////////////
2371:main.c        **** 
2372:main.c        **** 	cleanup:
2373:main.c        **** 	free((void*)line);
 9867              		.loc 1 2373 0
 9868 7e20 488B8518 		movq	-3048(%rbp), %rax
 9868      F4FFFF
 9869 7e27 4889C7   		movq	%rax, %rdi
 9870 7e2a E8000000 		call	free
 9870      00
2374:main.c        **** 	flClose(handle);
 9871              		.loc 1 2374 0
 9872 7e2f 488B85E0 		movq	-3104(%rbp), %rax
 9872      F3FFFF
 9873 7e36 4889C7   		movq	%rax, %rdi
 9874 7e39 E8000000 		call	flClose
 9874      00
2375:main.c        **** 	if ( error ) {
 9875              		.loc 1 2375 0
 9876 7e3e 488B85E8 		movq	-3096(%rbp), %rax
 9876      F3FFFF
 9877 7e45 4885C0   		testq	%rax, %rax
 9878 7e48 742F     		je	.L512
2376:main.c        **** 		fprintf(stderr, "%s\n", error);
 9879              		.loc 1 2376 0
 9880 7e4a 488B95E8 		movq	-3096(%rbp), %rdx
 9880      F3FFFF
 9881 7e51 488B0500 		movq	stderr(%rip), %rax
 9881      000000
 9882 7e58 BE000000 		movl	$.LC255, %esi
 9882      00
 9883 7e5d 4889C7   		movq	%rax, %rdi
 9884 7e60 B8000000 		movl	$0, %eax
 9884      00
 9885 7e65 E8000000 		call	fprintf
 9885      00
2377:main.c        **** 		flFreeError(error);
 9886              		.loc 1 2377 0
 9887 7e6a 488B85E8 		movq	-3096(%rbp), %rax
 9887      F3FFFF
 9888 7e71 4889C7   		movq	%rax, %rdi
 9889 7e74 E8000000 		call	flFreeError
 9889      00
 9890              	.L512:
2378:main.c        **** 	}
2379:main.c        **** 	return retVal;
 9891              		.loc 1 2379 0
 9892 7e79 8B85B8F2 		movl	-3400(%rbp), %eax
 9892      FFFF
2380:main.c        **** }
 9893              		.loc 1 2380 0
 9894 7e7f 488B5DE8 		movq	-24(%rbp), %rbx
 9895 7e83 6448331C 		xorq	%fs:40, %rbx
 9895      25280000 
 9895      00
 9896 7e8c 7405     		je	.L514
 9897 7e8e E8000000 		call	__stack_chk_fail
 9897      00
 9898              	.L514:
 9899 7e93 4881C468 		addq	$3432, %rsp
 9899      0D0000
 9900 7e9a 5B       		popq	%rbx
 9901 7e9b 5D       		popq	%rbp
 9902              		.cfi_def_cfa 7, 8
 9903 7e9c C3       		ret
 9904              		.cfi_endproc
 9905              	.LFE23:
 9907              		.section	.rodata
 9908 20ae 0000     		.align 8
 9909              	.LC29:
 9910 20b0 00000000 		.long	0
 9911 20b4 80842E41 		.long	1093567616
 9912              		.align 8
 9913              	.LC30:
 9914 20b8 00000000 		.long	0
 9915 20bc 00003041 		.long	1093664768
 9916              		.align 8
 9917              	.LC213:
 9918 20c0 00000000 		.long	0
 9919 20c4 00007040 		.long	1081081856
 9920              		.text
 9921              	.Letext0:
 9922              		.file 2 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
 9923              		.file 3 "/usr/include/x86_64-linux-gnu/bits/types.h"
 9924              		.file 4 "/usr/include/stdio.h"
 9925              		.file 5 "/usr/include/libio.h"
 9926              		.file 6 "/usr/include/time.h"
 9927              		.file 7 "/home/shubham/20140524/makestuff/common/makestuff.h"
 9928              		.file 8 "/home/shubham/20140524/makestuff/libs/libfpgalink/libfpgalink.h"
 9929              		.file 9 "/home/shubham/20140524/makestuff/libs/libbuffer/libbuffer.h"
 9930              		.file 10 "/home/shubham/20140524/makestuff/libs/libargtable2/argtable2.h"
 9931              		.file 11 "/usr/include/x86_64-linux-gnu/bits/time.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc8h0MM4.s:5      .bss:0000000000000000 ptr
     /tmp/cc8h0MM4.s:5      .bss:0000000000000008 enableBenchmarking
     /tmp/cc8h0MM4.s:10     .text:0000000000000000 delay
     /tmp/cc8h0MM4.s:48     .text:000000000000002f myxor
     /tmp/cc8h0MM4.s:109    .text:0000000000000091 bitArrayToInt
     /tmp/cc8h0MM4.s:165    .text:00000000000000ee BinTouint8
     /tmp/cc8h0MM4.s:287    .text:0000000000000281 decToBinary
     /tmp/cc8h0MM4.s:424    .text:00000000000003c7 encrypter
     /tmp/cc8h0MM4.s:687    .text:000000000000074b decrypter
     /tmp/cc8h0MM4.s:971    .text:0000000000000b10 convert_to_binary
     /tmp/cc8h0MM4.s:1045   .text:0000000000000b72 print
     /tmp/cc8h0MM4.s:1592   .text:00000000000012f6 uint8ToBin
     /tmp/cc8h0MM4.s:1687   .text:0000000000001388 writecsv
     /tmp/cc8h0MM4.s:2123   .text:0000000000001971 isHexDigit
     /tmp/cc8h0MM4.s:2172   .text:00000000000019af calcChecksum
     /tmp/cc8h0MM4.s:2212   .text:00000000000019f0 getHexNibble
     /tmp/cc8h0MM4.s:2280   .text:0000000000001a64 getHexByte
     /tmp/cc8h0MM4.s:2376   .rodata:00000000000001a0 errMessages
     /tmp/cc8h0MM4.s:2396   .text:0000000000001b08 doRead
     /tmp/cc8h0MM4.s:2647   .text:0000000000001dba doWrite
     /tmp/cc8h0MM4.s:2796   .text:0000000000001fae parseLine
     /tmp/cc8h0MM4.s:4035   .data:0000000000000000 nibbles
     /tmp/cc8h0MM4.s:4062   .text:000000000000305d asciiToBinary
     /tmp/cc8h0MM4.s:4646   .text:00000000000030b8 main

UNDEFINED SYMBOLS
clock
__stack_chk_fail
stderr
fwrite
puts
__isoc99_fscanf
printf
fopen
putchar
fprintf
fclose
flReadChannelAsyncSubmit
errPrefix
flReadChannelAsyncAwait
fread
flWriteChannelAsync
flAwaitAsyncWrites
bufInitialise
__errno_location
strtoul
malloc
strncpy
free
gettimeofday
bufAppendConst
flReadChannel
flWriteChannel
flSelectConduit
dump
bufDestroy
fputc
arg_str0
arg_str1
arg_uint0
arg_lit0
arg_end
arg_nullcheck
arg_parse
stdout
arg_print_syntax
arg_print_glossary
arg_print_errors
flInitialise
flOpen
flLoadCustomFirmware
flLoadStandardFirmware
flSleep
fflush
flIsDeviceAvailable
flGetFirmwareVersion
flGetFirmwareID
strcmp
flFlashStandardFirmware
flFlashCustomFirmware
flSaveFirmware
flResetToggle
flIsNeroCapable
flIsCommCapable
flMultiBitPortAccess
sprintf
jtagScanChain
flProgram
flIsFPGARunning
sigRegisterHandler
sigIsRaised
readline
add_history
time
difftime
flClose
flFreeError
