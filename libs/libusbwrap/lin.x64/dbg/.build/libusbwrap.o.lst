   1              		.file	"libusbwrap.c"
   2              		.text
   3              	.Ltext0:
   5              	queueSize:
   6              	.LFB6:
   7              		.file 1 "unbounded_queue.h"
   1:unbounded_queue.h **** #ifndef UNBOUNDED_QUEUE_H
   2:unbounded_queue.h **** #define UNBOUNDED_QUEUE_H
   3:unbounded_queue.h **** 
   4:unbounded_queue.h **** #include "libusbwrap.h"
   5:unbounded_queue.h **** 
   6:unbounded_queue.h **** #ifdef __cplusplus
   7:unbounded_queue.h **** extern "C" {
   8:unbounded_queue.h **** #endif
   9:unbounded_queue.h **** 
  10:unbounded_queue.h **** 	typedef const void* Item;
  11:unbounded_queue.h **** 	typedef Item (*CreateFunc)(void);
  12:unbounded_queue.h **** 	typedef void (*DestroyFunc)(Item);
  13:unbounded_queue.h **** 
  14:unbounded_queue.h **** 	struct UnboundedQueue {
  15:unbounded_queue.h **** 		Item *itemArray;
  16:unbounded_queue.h **** 		size_t capacity;
  17:unbounded_queue.h **** 		size_t putIndex;
  18:unbounded_queue.h **** 		size_t takeIndex;
  19:unbounded_queue.h **** 		size_t numItems;
  20:unbounded_queue.h **** 		CreateFunc createFunc;
  21:unbounded_queue.h **** 		DestroyFunc destroyFunc;
  22:unbounded_queue.h **** 	};
  23:unbounded_queue.h **** 
  24:unbounded_queue.h **** 	USBStatus queueInit(
  25:unbounded_queue.h **** 		struct UnboundedQueue *self, size_t capacity, CreateFunc createFunc, DestroyFunc destroyFunc
  26:unbounded_queue.h **** 	);
  27:unbounded_queue.h **** 	USBStatus queuePut(
  28:unbounded_queue.h **** 		struct UnboundedQueue *self, Item *item  // never blocks, can ENOMEM
  29:unbounded_queue.h **** 	);
  30:unbounded_queue.h **** 	void queueCommitPut(
  31:unbounded_queue.h **** 		struct UnboundedQueue *self
  32:unbounded_queue.h **** 	);
  33:unbounded_queue.h **** 	USBStatus queueTake(
  34:unbounded_queue.h **** 		struct UnboundedQueue *self, Item *item  // returns NULL on empty
  35:unbounded_queue.h **** 	);
  36:unbounded_queue.h **** 	void queueCommitTake(
  37:unbounded_queue.h **** 		struct UnboundedQueue *self
  38:unbounded_queue.h **** 	);
  39:unbounded_queue.h **** 	void queueDestroy(
  40:unbounded_queue.h **** 		struct UnboundedQueue *self
  41:unbounded_queue.h **** 	);
  42:unbounded_queue.h **** 	static inline size_t queueSize(const struct UnboundedQueue *self) {
   8              		.loc 1 42 0
   9              		.cfi_startproc
  10 0000 55       		pushq	%rbp
  11              		.cfi_def_cfa_offset 16
  12              		.cfi_offset 6, -16
  13 0001 4889E5   		movq	%rsp, %rbp
  14              		.cfi_def_cfa_register 6
  15 0004 48897DF8 		movq	%rdi, -8(%rbp)
  43:unbounded_queue.h **** 		return self->numItems;
  16              		.loc 1 43 0
  17 0008 488B45F8 		movq	-8(%rbp), %rax
  18 000c 488B4020 		movq	32(%rax), %rax
  44:unbounded_queue.h **** 	}
  19              		.loc 1 44 0
  20 0010 5D       		popq	%rbp
  21              		.cfi_def_cfa 7, 8
  22 0011 C3       		ret
  23              		.cfi_endproc
  24              	.LFE6:
  27              	libusb_fill_bulk_transfer:
  28              	.LFB12:
  29              		.file 2 "/usr/include/libusb-1.0/libusb.h"
   1:/usr/include/libusb-1.0/libusb.h **** /*
   2:/usr/include/libusb-1.0/libusb.h ****  * Public libusb header file
   3:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2001 Johannes Erdfelt <johannes@erdfelt.com>
   4:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2007-2008 Daniel Drake <dsd@gentoo.org>
   5:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2012 Pete Batard <pete@akeo.ie>
   6:/usr/include/libusb-1.0/libusb.h ****  * Copyright © 2012 Nathan Hjelm <hjelmn@cs.unm.edu>
   7:/usr/include/libusb-1.0/libusb.h ****  * For more information, please visit: http://libusb.info
   8:/usr/include/libusb-1.0/libusb.h ****  *
   9:/usr/include/libusb-1.0/libusb.h ****  * This library is free software; you can redistribute it and/or
  10:/usr/include/libusb-1.0/libusb.h ****  * modify it under the terms of the GNU Lesser General Public
  11:/usr/include/libusb-1.0/libusb.h ****  * License as published by the Free Software Foundation; either
  12:/usr/include/libusb-1.0/libusb.h ****  * version 2.1 of the License, or (at your option) any later version.
  13:/usr/include/libusb-1.0/libusb.h ****  *
  14:/usr/include/libusb-1.0/libusb.h ****  * This library is distributed in the hope that it will be useful,
  15:/usr/include/libusb-1.0/libusb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:/usr/include/libusb-1.0/libusb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17:/usr/include/libusb-1.0/libusb.h ****  * Lesser General Public License for more details.
  18:/usr/include/libusb-1.0/libusb.h ****  *
  19:/usr/include/libusb-1.0/libusb.h ****  * You should have received a copy of the GNU Lesser General Public
  20:/usr/include/libusb-1.0/libusb.h ****  * License along with this library; if not, write to the Free Software
  21:/usr/include/libusb-1.0/libusb.h ****  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  22:/usr/include/libusb-1.0/libusb.h ****  */
  23:/usr/include/libusb-1.0/libusb.h **** 
  24:/usr/include/libusb-1.0/libusb.h **** #ifndef LIBUSB_H
  25:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_H
  26:/usr/include/libusb-1.0/libusb.h **** 
  27:/usr/include/libusb-1.0/libusb.h **** #ifdef _MSC_VER
  28:/usr/include/libusb-1.0/libusb.h **** /* on MS environments, the inline keyword is available in C++ only */
  29:/usr/include/libusb-1.0/libusb.h **** #if !defined(__cplusplus)
  30:/usr/include/libusb-1.0/libusb.h **** #define inline __inline
  31:/usr/include/libusb-1.0/libusb.h **** #endif
  32:/usr/include/libusb-1.0/libusb.h **** /* ssize_t is also not available (copy/paste from MinGW) */
  33:/usr/include/libusb-1.0/libusb.h **** #ifndef _SSIZE_T_DEFINED
  34:/usr/include/libusb-1.0/libusb.h **** #define _SSIZE_T_DEFINED
  35:/usr/include/libusb-1.0/libusb.h **** #undef ssize_t
  36:/usr/include/libusb-1.0/libusb.h **** #ifdef _WIN64
  37:/usr/include/libusb-1.0/libusb.h ****   typedef __int64 ssize_t;
  38:/usr/include/libusb-1.0/libusb.h **** #else
  39:/usr/include/libusb-1.0/libusb.h ****   typedef int ssize_t;
  40:/usr/include/libusb-1.0/libusb.h **** #endif /* _WIN64 */
  41:/usr/include/libusb-1.0/libusb.h **** #endif /* _SSIZE_T_DEFINED */
  42:/usr/include/libusb-1.0/libusb.h **** #endif /* _MSC_VER */
  43:/usr/include/libusb-1.0/libusb.h **** 
  44:/usr/include/libusb-1.0/libusb.h **** /* stdint.h is not available on older MSVC */
  45:/usr/include/libusb-1.0/libusb.h **** #if defined(_MSC_VER) && (_MSC_VER < 1600) && (!defined(_STDINT)) && (!defined(_STDINT_H))
  46:/usr/include/libusb-1.0/libusb.h **** typedef unsigned __int8   uint8_t;
  47:/usr/include/libusb-1.0/libusb.h **** typedef unsigned __int16  uint16_t;
  48:/usr/include/libusb-1.0/libusb.h **** typedef unsigned __int32  uint32_t;
  49:/usr/include/libusb-1.0/libusb.h **** #else
  50:/usr/include/libusb-1.0/libusb.h **** #include <stdint.h>
  51:/usr/include/libusb-1.0/libusb.h **** #endif
  52:/usr/include/libusb-1.0/libusb.h **** 
  53:/usr/include/libusb-1.0/libusb.h **** #if !defined(_WIN32_WCE)
  54:/usr/include/libusb-1.0/libusb.h **** #include <sys/types.h>
  55:/usr/include/libusb-1.0/libusb.h **** #endif
  56:/usr/include/libusb-1.0/libusb.h **** 
  57:/usr/include/libusb-1.0/libusb.h **** #if defined(__linux) || defined(__APPLE__) || defined(__CYGWIN__) || defined(__HAIKU__)
  58:/usr/include/libusb-1.0/libusb.h **** #include <sys/time.h>
  59:/usr/include/libusb-1.0/libusb.h **** #endif
  60:/usr/include/libusb-1.0/libusb.h **** 
  61:/usr/include/libusb-1.0/libusb.h **** #include <time.h>
  62:/usr/include/libusb-1.0/libusb.h **** #include <limits.h>
  63:/usr/include/libusb-1.0/libusb.h **** 
  64:/usr/include/libusb-1.0/libusb.h **** /* 'interface' might be defined as a macro on Windows, so we need to
  65:/usr/include/libusb-1.0/libusb.h ****  * undefine it so as not to break the current libusb API, because
  66:/usr/include/libusb-1.0/libusb.h ****  * libusb_config_descriptor has an 'interface' member
  67:/usr/include/libusb-1.0/libusb.h ****  * As this can be problematic if you include windows.h after libusb.h
  68:/usr/include/libusb-1.0/libusb.h ****  * in your sources, we force windows.h to be included first. */
  69:/usr/include/libusb-1.0/libusb.h **** #if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
  70:/usr/include/libusb-1.0/libusb.h **** #include <windows.h>
  71:/usr/include/libusb-1.0/libusb.h **** #if defined(interface)
  72:/usr/include/libusb-1.0/libusb.h **** #undef interface
  73:/usr/include/libusb-1.0/libusb.h **** #endif
  74:/usr/include/libusb-1.0/libusb.h **** #if !defined(__CYGWIN__)
  75:/usr/include/libusb-1.0/libusb.h **** #include <winsock.h>
  76:/usr/include/libusb-1.0/libusb.h **** #endif
  77:/usr/include/libusb-1.0/libusb.h **** #endif
  78:/usr/include/libusb-1.0/libusb.h **** 
  79:/usr/include/libusb-1.0/libusb.h **** #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
  80:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DEPRECATED_FOR(f) \
  81:/usr/include/libusb-1.0/libusb.h ****   __attribute__((deprecated("Use " #f " instead")))
  82:/usr/include/libusb-1.0/libusb.h **** #else
  83:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DEPRECATED_FOR(f)
  84:/usr/include/libusb-1.0/libusb.h **** #endif /* __GNUC__ */
  85:/usr/include/libusb-1.0/libusb.h **** 
  86:/usr/include/libusb-1.0/libusb.h **** /** \def LIBUSB_CALL
  87:/usr/include/libusb-1.0/libusb.h ****  * \ingroup misc
  88:/usr/include/libusb-1.0/libusb.h ****  * libusb's Windows calling convention.
  89:/usr/include/libusb-1.0/libusb.h ****  *
  90:/usr/include/libusb-1.0/libusb.h ****  * Under Windows, the selection of available compilers and configurations
  91:/usr/include/libusb-1.0/libusb.h ****  * means that, unlike other platforms, there is not <em>one true calling
  92:/usr/include/libusb-1.0/libusb.h ****  * convention</em> (calling convention: the manner in which parameters are
  93:/usr/include/libusb-1.0/libusb.h ****  * passed to functions in the generated assembly code).
  94:/usr/include/libusb-1.0/libusb.h ****  *
  95:/usr/include/libusb-1.0/libusb.h ****  * Matching the Windows API itself, libusb uses the WINAPI convention (which
  96:/usr/include/libusb-1.0/libusb.h ****  * translates to the <tt>stdcall</tt> convention) and guarantees that the
  97:/usr/include/libusb-1.0/libusb.h ****  * library is compiled in this way. The public header file also includes
  98:/usr/include/libusb-1.0/libusb.h ****  * appropriate annotations so that your own software will use the right
  99:/usr/include/libusb-1.0/libusb.h ****  * convention, even if another convention is being used by default within
 100:/usr/include/libusb-1.0/libusb.h ****  * your codebase.
 101:/usr/include/libusb-1.0/libusb.h ****  *
 102:/usr/include/libusb-1.0/libusb.h ****  * The one consideration that you must apply in your software is to mark
 103:/usr/include/libusb-1.0/libusb.h ****  * all functions which you use as libusb callbacks with this LIBUSB_CALL
 104:/usr/include/libusb-1.0/libusb.h ****  * annotation, so that they too get compiled for the correct calling
 105:/usr/include/libusb-1.0/libusb.h ****  * convention.
 106:/usr/include/libusb-1.0/libusb.h ****  *
 107:/usr/include/libusb-1.0/libusb.h ****  * On non-Windows operating systems, this macro is defined as nothing. This
 108:/usr/include/libusb-1.0/libusb.h ****  * means that you can apply it to your code without worrying about
 109:/usr/include/libusb-1.0/libusb.h ****  * cross-platform compatibility.
 110:/usr/include/libusb-1.0/libusb.h ****  */
 111:/usr/include/libusb-1.0/libusb.h **** /* LIBUSB_CALL must be defined on both definition and declaration of libusb
 112:/usr/include/libusb-1.0/libusb.h ****  * functions. You'd think that declaration would be enough, but cygwin will
 113:/usr/include/libusb-1.0/libusb.h ****  * complain about conflicting types unless both are marked this way.
 114:/usr/include/libusb-1.0/libusb.h ****  * The placement of this macro is important too; it must appear after the
 115:/usr/include/libusb-1.0/libusb.h ****  * return type, before the function name. See internal documentation for
 116:/usr/include/libusb-1.0/libusb.h ****  * API_EXPORTED.
 117:/usr/include/libusb-1.0/libusb.h ****  */
 118:/usr/include/libusb-1.0/libusb.h **** #if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
 119:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CALL WINAPI
 120:/usr/include/libusb-1.0/libusb.h **** #else
 121:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CALL
 122:/usr/include/libusb-1.0/libusb.h **** #endif
 123:/usr/include/libusb-1.0/libusb.h **** 
 124:/usr/include/libusb-1.0/libusb.h **** /** \def LIBUSB_API_VERSION
 125:/usr/include/libusb-1.0/libusb.h ****  * \ingroup misc
 126:/usr/include/libusb-1.0/libusb.h ****  * libusb's API version.
 127:/usr/include/libusb-1.0/libusb.h ****  *
 128:/usr/include/libusb-1.0/libusb.h ****  * Since version 1.0.13, to help with feature detection, libusb defines
 129:/usr/include/libusb-1.0/libusb.h ****  * a LIBUSB_API_VERSION macro that gets increased every time there is a
 130:/usr/include/libusb-1.0/libusb.h ****  * significant change to the API, such as the introduction of a new call,
 131:/usr/include/libusb-1.0/libusb.h ****  * the definition of a new macro/enum member, or any other element that
 132:/usr/include/libusb-1.0/libusb.h ****  * libusb applications may want to detect at compilation time.
 133:/usr/include/libusb-1.0/libusb.h ****  *
 134:/usr/include/libusb-1.0/libusb.h ****  * The macro is typically used in an application as follows:
 135:/usr/include/libusb-1.0/libusb.h ****  * \code
 136:/usr/include/libusb-1.0/libusb.h ****  * #if defined(LIBUSB_API_VERSION) && (LIBUSB_API_VERSION >= 0x01001234)
 137:/usr/include/libusb-1.0/libusb.h ****  * // Use one of the newer features from the libusb API
 138:/usr/include/libusb-1.0/libusb.h ****  * #endif
 139:/usr/include/libusb-1.0/libusb.h ****  * \endcode
 140:/usr/include/libusb-1.0/libusb.h ****  *
 141:/usr/include/libusb-1.0/libusb.h ****  * Internally, LIBUSB_API_VERSION is defined as follows:
 142:/usr/include/libusb-1.0/libusb.h ****  * (libusb major << 24) | (libusb minor << 16) | (16 bit incremental)
 143:/usr/include/libusb-1.0/libusb.h ****  */
 144:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_API_VERSION 0x01000104
 145:/usr/include/libusb-1.0/libusb.h **** 
 146:/usr/include/libusb-1.0/libusb.h **** /* The following is kept for compatibility, but will be deprecated in the future */
 147:/usr/include/libusb-1.0/libusb.h **** #define LIBUSBX_API_VERSION LIBUSB_API_VERSION
 148:/usr/include/libusb-1.0/libusb.h **** 
 149:/usr/include/libusb-1.0/libusb.h **** #ifdef __cplusplus
 150:/usr/include/libusb-1.0/libusb.h **** extern "C" {
 151:/usr/include/libusb-1.0/libusb.h **** #endif
 152:/usr/include/libusb-1.0/libusb.h **** 
 153:/usr/include/libusb-1.0/libusb.h **** /**
 154:/usr/include/libusb-1.0/libusb.h ****  * \ingroup misc
 155:/usr/include/libusb-1.0/libusb.h ****  * Convert a 16-bit value from host-endian to little-endian format. On
 156:/usr/include/libusb-1.0/libusb.h ****  * little endian systems, this function does nothing. On big endian systems,
 157:/usr/include/libusb-1.0/libusb.h ****  * the bytes are swapped.
 158:/usr/include/libusb-1.0/libusb.h ****  * \param x the host-endian value to convert
 159:/usr/include/libusb-1.0/libusb.h ****  * \returns the value in little-endian byte order
 160:/usr/include/libusb-1.0/libusb.h ****  */
 161:/usr/include/libusb-1.0/libusb.h **** static inline uint16_t libusb_cpu_to_le16(const uint16_t x)
 162:/usr/include/libusb-1.0/libusb.h **** {
 163:/usr/include/libusb-1.0/libusb.h **** 	union {
 164:/usr/include/libusb-1.0/libusb.h **** 		uint8_t  b8[2];
 165:/usr/include/libusb-1.0/libusb.h **** 		uint16_t b16;
 166:/usr/include/libusb-1.0/libusb.h **** 	} _tmp;
 167:/usr/include/libusb-1.0/libusb.h **** 	_tmp.b8[1] = (uint8_t) (x >> 8);
 168:/usr/include/libusb-1.0/libusb.h **** 	_tmp.b8[0] = (uint8_t) (x & 0xff);
 169:/usr/include/libusb-1.0/libusb.h **** 	return _tmp.b16;
 170:/usr/include/libusb-1.0/libusb.h **** }
 171:/usr/include/libusb-1.0/libusb.h **** 
 172:/usr/include/libusb-1.0/libusb.h **** /** \def libusb_le16_to_cpu
 173:/usr/include/libusb-1.0/libusb.h ****  * \ingroup misc
 174:/usr/include/libusb-1.0/libusb.h ****  * Convert a 16-bit value from little-endian to host-endian format. On
 175:/usr/include/libusb-1.0/libusb.h ****  * little endian systems, this function does nothing. On big endian systems,
 176:/usr/include/libusb-1.0/libusb.h ****  * the bytes are swapped.
 177:/usr/include/libusb-1.0/libusb.h ****  * \param x the little-endian value to convert
 178:/usr/include/libusb-1.0/libusb.h ****  * \returns the value in host-endian byte order
 179:/usr/include/libusb-1.0/libusb.h ****  */
 180:/usr/include/libusb-1.0/libusb.h **** #define libusb_le16_to_cpu libusb_cpu_to_le16
 181:/usr/include/libusb-1.0/libusb.h **** 
 182:/usr/include/libusb-1.0/libusb.h **** /* standard USB stuff */
 183:/usr/include/libusb-1.0/libusb.h **** 
 184:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 185:/usr/include/libusb-1.0/libusb.h ****  * Device and/or Interface Class codes */
 186:/usr/include/libusb-1.0/libusb.h **** enum libusb_class_code {
 187:/usr/include/libusb-1.0/libusb.h **** 	/** In the context of a \ref libusb_device_descriptor "device descriptor",
 188:/usr/include/libusb-1.0/libusb.h **** 	 * this bDeviceClass value indicates that each interface specifies its
 189:/usr/include/libusb-1.0/libusb.h **** 	 * own class information and all interfaces operate independently.
 190:/usr/include/libusb-1.0/libusb.h **** 	 */
 191:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PER_INTERFACE = 0,
 192:/usr/include/libusb-1.0/libusb.h **** 
 193:/usr/include/libusb-1.0/libusb.h **** 	/** Audio class */
 194:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_AUDIO = 1,
 195:/usr/include/libusb-1.0/libusb.h **** 
 196:/usr/include/libusb-1.0/libusb.h **** 	/** Communications class */
 197:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_COMM = 2,
 198:/usr/include/libusb-1.0/libusb.h **** 
 199:/usr/include/libusb-1.0/libusb.h **** 	/** Human Interface Device class */
 200:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_HID = 3,
 201:/usr/include/libusb-1.0/libusb.h **** 
 202:/usr/include/libusb-1.0/libusb.h **** 	/** Physical */
 203:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PHYSICAL = 5,
 204:/usr/include/libusb-1.0/libusb.h **** 
 205:/usr/include/libusb-1.0/libusb.h **** 	/** Printer class */
 206:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PRINTER = 7,
 207:/usr/include/libusb-1.0/libusb.h **** 
 208:/usr/include/libusb-1.0/libusb.h **** 	/** Image class */
 209:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PTP = 6, /* legacy name from libusb-0.1 usb.h */
 210:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_IMAGE = 6,
 211:/usr/include/libusb-1.0/libusb.h **** 
 212:/usr/include/libusb-1.0/libusb.h **** 	/** Mass storage class */
 213:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_MASS_STORAGE = 8,
 214:/usr/include/libusb-1.0/libusb.h **** 
 215:/usr/include/libusb-1.0/libusb.h **** 	/** Hub class */
 216:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_HUB = 9,
 217:/usr/include/libusb-1.0/libusb.h **** 
 218:/usr/include/libusb-1.0/libusb.h **** 	/** Data class */
 219:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_DATA = 10,
 220:/usr/include/libusb-1.0/libusb.h **** 
 221:/usr/include/libusb-1.0/libusb.h **** 	/** Smart Card */
 222:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_SMART_CARD = 0x0b,
 223:/usr/include/libusb-1.0/libusb.h **** 
 224:/usr/include/libusb-1.0/libusb.h **** 	/** Content Security */
 225:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_CONTENT_SECURITY = 0x0d,
 226:/usr/include/libusb-1.0/libusb.h **** 
 227:/usr/include/libusb-1.0/libusb.h **** 	/** Video */
 228:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_VIDEO = 0x0e,
 229:/usr/include/libusb-1.0/libusb.h **** 
 230:/usr/include/libusb-1.0/libusb.h **** 	/** Personal Healthcare */
 231:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_PERSONAL_HEALTHCARE = 0x0f,
 232:/usr/include/libusb-1.0/libusb.h **** 
 233:/usr/include/libusb-1.0/libusb.h **** 	/** Diagnostic Device */
 234:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_DIAGNOSTIC_DEVICE = 0xdc,
 235:/usr/include/libusb-1.0/libusb.h **** 
 236:/usr/include/libusb-1.0/libusb.h **** 	/** Wireless class */
 237:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_WIRELESS = 0xe0,
 238:/usr/include/libusb-1.0/libusb.h **** 
 239:/usr/include/libusb-1.0/libusb.h **** 	/** Application class */
 240:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_APPLICATION = 0xfe,
 241:/usr/include/libusb-1.0/libusb.h **** 
 242:/usr/include/libusb-1.0/libusb.h **** 	/** Class is vendor-specific */
 243:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CLASS_VENDOR_SPEC = 0xff
 244:/usr/include/libusb-1.0/libusb.h **** };
 245:/usr/include/libusb-1.0/libusb.h **** 
 246:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 247:/usr/include/libusb-1.0/libusb.h ****  * Descriptor types as defined by the USB specification. */
 248:/usr/include/libusb-1.0/libusb.h **** enum libusb_descriptor_type {
 249:/usr/include/libusb-1.0/libusb.h **** 	/** Device descriptor. See libusb_device_descriptor. */
 250:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_DEVICE = 0x01,
 251:/usr/include/libusb-1.0/libusb.h **** 
 252:/usr/include/libusb-1.0/libusb.h **** 	/** Configuration descriptor. See libusb_config_descriptor. */
 253:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_CONFIG = 0x02,
 254:/usr/include/libusb-1.0/libusb.h **** 
 255:/usr/include/libusb-1.0/libusb.h **** 	/** String descriptor */
 256:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_STRING = 0x03,
 257:/usr/include/libusb-1.0/libusb.h **** 
 258:/usr/include/libusb-1.0/libusb.h **** 	/** Interface descriptor. See libusb_interface_descriptor. */
 259:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_INTERFACE = 0x04,
 260:/usr/include/libusb-1.0/libusb.h **** 
 261:/usr/include/libusb-1.0/libusb.h **** 	/** Endpoint descriptor. See libusb_endpoint_descriptor. */
 262:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_ENDPOINT = 0x05,
 263:/usr/include/libusb-1.0/libusb.h **** 
 264:/usr/include/libusb-1.0/libusb.h **** 	/** BOS descriptor */
 265:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_BOS = 0x0f,
 266:/usr/include/libusb-1.0/libusb.h **** 
 267:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability descriptor */
 268:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_DEVICE_CAPABILITY = 0x10,
 269:/usr/include/libusb-1.0/libusb.h **** 
 270:/usr/include/libusb-1.0/libusb.h **** 	/** HID descriptor */
 271:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_HID = 0x21,
 272:/usr/include/libusb-1.0/libusb.h **** 
 273:/usr/include/libusb-1.0/libusb.h **** 	/** HID report descriptor */
 274:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_REPORT = 0x22,
 275:/usr/include/libusb-1.0/libusb.h **** 
 276:/usr/include/libusb-1.0/libusb.h **** 	/** Physical descriptor */
 277:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_PHYSICAL = 0x23,
 278:/usr/include/libusb-1.0/libusb.h **** 
 279:/usr/include/libusb-1.0/libusb.h **** 	/** Hub descriptor */
 280:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_HUB = 0x29,
 281:/usr/include/libusb-1.0/libusb.h **** 
 282:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed Hub descriptor */
 283:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_SUPERSPEED_HUB = 0x2a,
 284:/usr/include/libusb-1.0/libusb.h **** 
 285:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed Endpoint Companion descriptor */
 286:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_DT_SS_ENDPOINT_COMPANION = 0x30
 287:/usr/include/libusb-1.0/libusb.h **** };
 288:/usr/include/libusb-1.0/libusb.h **** 
 289:/usr/include/libusb-1.0/libusb.h **** /* Descriptor sizes per descriptor type */
 290:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_DEVICE_SIZE			18
 291:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_CONFIG_SIZE			9
 292:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_INTERFACE_SIZE		9
 293:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_ENDPOINT_SIZE			7
 294:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_ENDPOINT_AUDIO_SIZE		9	/* Audio extension */
 295:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_HUB_NONVAR_SIZE		7
 296:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE	6
 297:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_BOS_SIZE			5
 298:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_DEVICE_CAPABILITY_SIZE	3
 299:/usr/include/libusb-1.0/libusb.h **** 
 300:/usr/include/libusb-1.0/libusb.h **** /* BOS descriptor sizes */
 301:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_USB_2_0_EXTENSION_SIZE	7
 302:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE	10
 303:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_BT_CONTAINER_ID_SIZE		20
 304:/usr/include/libusb-1.0/libusb.h **** 
 305:/usr/include/libusb-1.0/libusb.h **** /* We unwrap the BOS => define its max size */
 306:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_DT_BOS_MAX_SIZE		((LIBUSB_DT_BOS_SIZE)     +\
 307:/usr/include/libusb-1.0/libusb.h **** 					(LIBUSB_BT_USB_2_0_EXTENSION_SIZE)       +\
 308:/usr/include/libusb-1.0/libusb.h **** 					(LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE) +\
 309:/usr/include/libusb-1.0/libusb.h **** 					(LIBUSB_BT_CONTAINER_ID_SIZE))
 310:/usr/include/libusb-1.0/libusb.h **** 
 311:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ENDPOINT_ADDRESS_MASK	0x0f    /* in bEndpointAddress */
 312:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ENDPOINT_DIR_MASK		0x80
 313:/usr/include/libusb-1.0/libusb.h **** 
 314:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 315:/usr/include/libusb-1.0/libusb.h ****  * Endpoint direction. Values for bit 7 of the
 316:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bEndpointAddress "endpoint address" scheme.
 317:/usr/include/libusb-1.0/libusb.h ****  */
 318:/usr/include/libusb-1.0/libusb.h **** enum libusb_endpoint_direction {
 319:/usr/include/libusb-1.0/libusb.h **** 	/** In: device-to-host */
 320:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_IN = 0x80,
 321:/usr/include/libusb-1.0/libusb.h **** 
 322:/usr/include/libusb-1.0/libusb.h **** 	/** Out: host-to-device */
 323:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ENDPOINT_OUT = 0x00
 324:/usr/include/libusb-1.0/libusb.h **** };
 325:/usr/include/libusb-1.0/libusb.h **** 
 326:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_TRANSFER_TYPE_MASK			0x03    /* in bmAttributes */
 327:/usr/include/libusb-1.0/libusb.h **** 
 328:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 329:/usr/include/libusb-1.0/libusb.h ****  * Endpoint transfer type. Values for bits 0:1 of the
 330:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "endpoint attributes" field.
 331:/usr/include/libusb-1.0/libusb.h ****  */
 332:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_type {
 333:/usr/include/libusb-1.0/libusb.h **** 	/** Control endpoint */
 334:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_CONTROL = 0,
 335:/usr/include/libusb-1.0/libusb.h **** 
 336:/usr/include/libusb-1.0/libusb.h **** 	/** Isochronous endpoint */
 337:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_ISOCHRONOUS = 1,
 338:/usr/include/libusb-1.0/libusb.h **** 
 339:/usr/include/libusb-1.0/libusb.h **** 	/** Bulk endpoint */
 340:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_BULK = 2,
 341:/usr/include/libusb-1.0/libusb.h **** 
 342:/usr/include/libusb-1.0/libusb.h **** 	/** Interrupt endpoint */
 343:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_INTERRUPT = 3,
 344:/usr/include/libusb-1.0/libusb.h **** 
 345:/usr/include/libusb-1.0/libusb.h **** 	/** Stream endpoint */
 346:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TYPE_BULK_STREAM = 4,
 347:/usr/include/libusb-1.0/libusb.h **** };
 348:/usr/include/libusb-1.0/libusb.h **** 
 349:/usr/include/libusb-1.0/libusb.h **** /** \ingroup misc
 350:/usr/include/libusb-1.0/libusb.h ****  * Standard requests, as defined in table 9-5 of the USB 3.0 specifications */
 351:/usr/include/libusb-1.0/libusb.h **** enum libusb_standard_request {
 352:/usr/include/libusb-1.0/libusb.h **** 	/** Request status of the specific recipient */
 353:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_STATUS = 0x00,
 354:/usr/include/libusb-1.0/libusb.h **** 
 355:/usr/include/libusb-1.0/libusb.h **** 	/** Clear or disable a specific feature */
 356:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_CLEAR_FEATURE = 0x01,
 357:/usr/include/libusb-1.0/libusb.h **** 
 358:/usr/include/libusb-1.0/libusb.h **** 	/* 0x02 is reserved */
 359:/usr/include/libusb-1.0/libusb.h **** 
 360:/usr/include/libusb-1.0/libusb.h **** 	/** Set or enable a specific feature */
 361:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_FEATURE = 0x03,
 362:/usr/include/libusb-1.0/libusb.h **** 
 363:/usr/include/libusb-1.0/libusb.h **** 	/* 0x04 is reserved */
 364:/usr/include/libusb-1.0/libusb.h **** 
 365:/usr/include/libusb-1.0/libusb.h **** 	/** Set device address for all future accesses */
 366:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_ADDRESS = 0x05,
 367:/usr/include/libusb-1.0/libusb.h **** 
 368:/usr/include/libusb-1.0/libusb.h **** 	/** Get the specified descriptor */
 369:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_DESCRIPTOR = 0x06,
 370:/usr/include/libusb-1.0/libusb.h **** 
 371:/usr/include/libusb-1.0/libusb.h **** 	/** Used to update existing descriptors or add new descriptors */
 372:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_DESCRIPTOR = 0x07,
 373:/usr/include/libusb-1.0/libusb.h **** 
 374:/usr/include/libusb-1.0/libusb.h **** 	/** Get the current device configuration value */
 375:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_CONFIGURATION = 0x08,
 376:/usr/include/libusb-1.0/libusb.h **** 
 377:/usr/include/libusb-1.0/libusb.h **** 	/** Set device configuration */
 378:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_CONFIGURATION = 0x09,
 379:/usr/include/libusb-1.0/libusb.h **** 
 380:/usr/include/libusb-1.0/libusb.h **** 	/** Return the selected alternate setting for the specified interface */
 381:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_GET_INTERFACE = 0x0A,
 382:/usr/include/libusb-1.0/libusb.h **** 
 383:/usr/include/libusb-1.0/libusb.h **** 	/** Select an alternate interface for the specified interface */
 384:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_INTERFACE = 0x0B,
 385:/usr/include/libusb-1.0/libusb.h **** 
 386:/usr/include/libusb-1.0/libusb.h **** 	/** Set then report an endpoint's synchronization frame */
 387:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SYNCH_FRAME = 0x0C,
 388:/usr/include/libusb-1.0/libusb.h **** 
 389:/usr/include/libusb-1.0/libusb.h **** 	/** Sets both the U1 and U2 Exit Latency */
 390:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_SET_SEL = 0x30,
 391:/usr/include/libusb-1.0/libusb.h **** 
 392:/usr/include/libusb-1.0/libusb.h **** 	/** Delay from the time a host transmits a packet to the time it is
 393:/usr/include/libusb-1.0/libusb.h **** 	  * received by the device. */
 394:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SET_ISOCH_DELAY = 0x31,
 395:/usr/include/libusb-1.0/libusb.h **** };
 396:/usr/include/libusb-1.0/libusb.h **** 
 397:/usr/include/libusb-1.0/libusb.h **** /** \ingroup misc
 398:/usr/include/libusb-1.0/libusb.h ****  * Request type bits of the
 399:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 400:/usr/include/libusb-1.0/libusb.h ****  * transfers. */
 401:/usr/include/libusb-1.0/libusb.h **** enum libusb_request_type {
 402:/usr/include/libusb-1.0/libusb.h **** 	/** Standard */
 403:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_STANDARD = (0x00 << 5),
 404:/usr/include/libusb-1.0/libusb.h **** 
 405:/usr/include/libusb-1.0/libusb.h **** 	/** Class */
 406:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5),
 407:/usr/include/libusb-1.0/libusb.h **** 
 408:/usr/include/libusb-1.0/libusb.h **** 	/** Vendor */
 409:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_VENDOR = (0x02 << 5),
 410:/usr/include/libusb-1.0/libusb.h **** 
 411:/usr/include/libusb-1.0/libusb.h **** 	/** Reserved */
 412:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_REQUEST_TYPE_RESERVED = (0x03 << 5)
 413:/usr/include/libusb-1.0/libusb.h **** };
 414:/usr/include/libusb-1.0/libusb.h **** 
 415:/usr/include/libusb-1.0/libusb.h **** /** \ingroup misc
 416:/usr/include/libusb-1.0/libusb.h ****  * Recipient bits of the
 417:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 418:/usr/include/libusb-1.0/libusb.h ****  * transfers. Values 4 through 31 are reserved. */
 419:/usr/include/libusb-1.0/libusb.h **** enum libusb_request_recipient {
 420:/usr/include/libusb-1.0/libusb.h **** 	/** Device */
 421:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_DEVICE = 0x00,
 422:/usr/include/libusb-1.0/libusb.h **** 
 423:/usr/include/libusb-1.0/libusb.h **** 	/** Interface */
 424:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_INTERFACE = 0x01,
 425:/usr/include/libusb-1.0/libusb.h **** 
 426:/usr/include/libusb-1.0/libusb.h **** 	/** Endpoint */
 427:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_ENDPOINT = 0x02,
 428:/usr/include/libusb-1.0/libusb.h **** 
 429:/usr/include/libusb-1.0/libusb.h **** 	/** Other */
 430:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_RECIPIENT_OTHER = 0x03,
 431:/usr/include/libusb-1.0/libusb.h **** };
 432:/usr/include/libusb-1.0/libusb.h **** 
 433:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ISO_SYNC_TYPE_MASK		0x0C
 434:/usr/include/libusb-1.0/libusb.h **** 
 435:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 436:/usr/include/libusb-1.0/libusb.h ****  * Synchronization type for isochronous endpoints. Values for bits 2:3 of the
 437:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 438:/usr/include/libusb-1.0/libusb.h ****  * libusb_endpoint_descriptor.
 439:/usr/include/libusb-1.0/libusb.h ****  */
 440:/usr/include/libusb-1.0/libusb.h **** enum libusb_iso_sync_type {
 441:/usr/include/libusb-1.0/libusb.h **** 	/** No synchronization */
 442:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_NONE = 0,
 443:/usr/include/libusb-1.0/libusb.h **** 
 444:/usr/include/libusb-1.0/libusb.h **** 	/** Asynchronous */
 445:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_ASYNC = 1,
 446:/usr/include/libusb-1.0/libusb.h **** 
 447:/usr/include/libusb-1.0/libusb.h **** 	/** Adaptive */
 448:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_ADAPTIVE = 2,
 449:/usr/include/libusb-1.0/libusb.h **** 
 450:/usr/include/libusb-1.0/libusb.h **** 	/** Synchronous */
 451:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_SYNC_TYPE_SYNC = 3
 452:/usr/include/libusb-1.0/libusb.h **** };
 453:/usr/include/libusb-1.0/libusb.h **** 
 454:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ISO_USAGE_TYPE_MASK 0x30
 455:/usr/include/libusb-1.0/libusb.h **** 
 456:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 457:/usr/include/libusb-1.0/libusb.h ****  * Usage type for isochronous endpoints. Values for bits 4:5 of the
 458:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 459:/usr/include/libusb-1.0/libusb.h ****  * libusb_endpoint_descriptor.
 460:/usr/include/libusb-1.0/libusb.h ****  */
 461:/usr/include/libusb-1.0/libusb.h **** enum libusb_iso_usage_type {
 462:/usr/include/libusb-1.0/libusb.h **** 	/** Data endpoint */
 463:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_DATA = 0,
 464:/usr/include/libusb-1.0/libusb.h **** 
 465:/usr/include/libusb-1.0/libusb.h **** 	/** Feedback endpoint */
 466:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_FEEDBACK = 1,
 467:/usr/include/libusb-1.0/libusb.h **** 
 468:/usr/include/libusb-1.0/libusb.h **** 	/** Implicit feedback Data endpoint */
 469:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ISO_USAGE_TYPE_IMPLICIT = 2,
 470:/usr/include/libusb-1.0/libusb.h **** };
 471:/usr/include/libusb-1.0/libusb.h **** 
 472:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 473:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB device descriptor. This
 474:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.1 of the USB 3.0 specification.
 475:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 476:/usr/include/libusb-1.0/libusb.h ****  */
 477:/usr/include/libusb-1.0/libusb.h **** struct libusb_device_descriptor {
 478:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 479:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 480:/usr/include/libusb-1.0/libusb.h **** 
 481:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 482:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE LIBUSB_DT_DEVICE in this
 483:/usr/include/libusb-1.0/libusb.h **** 	 * context. */
 484:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 485:/usr/include/libusb-1.0/libusb.h **** 
 486:/usr/include/libusb-1.0/libusb.h **** 	/** USB specification release number in binary-coded decimal. A value of
 487:/usr/include/libusb-1.0/libusb.h **** 	 * 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc. */
 488:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bcdUSB;
 489:/usr/include/libusb-1.0/libusb.h **** 
 490:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF class code for the device. See \ref libusb_class_code. */
 491:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceClass;
 492:/usr/include/libusb-1.0/libusb.h **** 
 493:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF subclass code for the device, qualified by the bDeviceClass
 494:/usr/include/libusb-1.0/libusb.h **** 	 * value */
 495:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceSubClass;
 496:/usr/include/libusb-1.0/libusb.h **** 
 497:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF protocol code for the device, qualified by the bDeviceClass and
 498:/usr/include/libusb-1.0/libusb.h **** 	 * bDeviceSubClass values */
 499:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDeviceProtocol;
 500:/usr/include/libusb-1.0/libusb.h **** 
 501:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum packet size for endpoint 0 */
 502:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bMaxPacketSize0;
 503:/usr/include/libusb-1.0/libusb.h **** 
 504:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF vendor ID */
 505:/usr/include/libusb-1.0/libusb.h **** 	uint16_t idVendor;
 506:/usr/include/libusb-1.0/libusb.h **** 
 507:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF product ID */
 508:/usr/include/libusb-1.0/libusb.h **** 	uint16_t idProduct;
 509:/usr/include/libusb-1.0/libusb.h **** 
 510:/usr/include/libusb-1.0/libusb.h **** 	/** Device release number in binary-coded decimal */
 511:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bcdDevice;
 512:/usr/include/libusb-1.0/libusb.h **** 
 513:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing manufacturer */
 514:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iManufacturer;
 515:/usr/include/libusb-1.0/libusb.h **** 
 516:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing product */
 517:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iProduct;
 518:/usr/include/libusb-1.0/libusb.h **** 
 519:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor containing device serial number */
 520:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iSerialNumber;
 521:/usr/include/libusb-1.0/libusb.h **** 
 522:/usr/include/libusb-1.0/libusb.h **** 	/** Number of possible configurations */
 523:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumConfigurations;
 524:/usr/include/libusb-1.0/libusb.h **** };
 525:/usr/include/libusb-1.0/libusb.h **** 
 526:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 527:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB endpoint descriptor. This
 528:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.6 of the USB 3.0 specification.
 529:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 530:/usr/include/libusb-1.0/libusb.h ****  */
 531:/usr/include/libusb-1.0/libusb.h **** struct libusb_endpoint_descriptor {
 532:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 533:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 534:/usr/include/libusb-1.0/libusb.h **** 
 535:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 536:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_ENDPOINT LIBUSB_DT_ENDPOINT in
 537:/usr/include/libusb-1.0/libusb.h **** 	 * this context. */
 538:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 539:/usr/include/libusb-1.0/libusb.h **** 
 540:/usr/include/libusb-1.0/libusb.h **** 	/** The address of the endpoint described by this descriptor. Bits 0:3 are
 541:/usr/include/libusb-1.0/libusb.h **** 	 * the endpoint number. Bits 4:6 are reserved. Bit 7 indicates direction,
 542:/usr/include/libusb-1.0/libusb.h **** 	 * see \ref libusb_endpoint_direction.
 543:/usr/include/libusb-1.0/libusb.h **** 	 */
 544:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bEndpointAddress;
 545:/usr/include/libusb-1.0/libusb.h **** 
 546:/usr/include/libusb-1.0/libusb.h **** 	/** Attributes which apply to the endpoint when it is configured using
 547:/usr/include/libusb-1.0/libusb.h **** 	 * the bConfigurationValue. Bits 0:1 determine the transfer type and
 548:/usr/include/libusb-1.0/libusb.h **** 	 * correspond to \ref libusb_transfer_type. Bits 2:3 are only used for
 549:/usr/include/libusb-1.0/libusb.h **** 	 * isochronous endpoints and correspond to \ref libusb_iso_sync_type.
 550:/usr/include/libusb-1.0/libusb.h **** 	 * Bits 4:5 are also only used for isochronous endpoints and correspond to
 551:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_iso_usage_type. Bits 6:7 are reserved.
 552:/usr/include/libusb-1.0/libusb.h **** 	 */
 553:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 554:/usr/include/libusb-1.0/libusb.h **** 
 555:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum packet size this endpoint is capable of sending/receiving. */
 556:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wMaxPacketSize;
 557:/usr/include/libusb-1.0/libusb.h **** 
 558:/usr/include/libusb-1.0/libusb.h **** 	/** Interval for polling endpoint for data transfers. */
 559:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterval;
 560:/usr/include/libusb-1.0/libusb.h **** 
 561:/usr/include/libusb-1.0/libusb.h **** 	/** For audio devices only: the rate at which synchronization feedback
 562:/usr/include/libusb-1.0/libusb.h **** 	 * is provided. */
 563:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bRefresh;
 564:/usr/include/libusb-1.0/libusb.h **** 
 565:/usr/include/libusb-1.0/libusb.h **** 	/** For audio devices only: the address if the synch endpoint */
 566:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bSynchAddress;
 567:/usr/include/libusb-1.0/libusb.h **** 
 568:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusb encounters unknown endpoint descriptors,
 569:/usr/include/libusb-1.0/libusb.h **** 	 * it will store them here, should you wish to parse them. */
 570:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 571:/usr/include/libusb-1.0/libusb.h **** 
 572:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. */
 573:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 574:/usr/include/libusb-1.0/libusb.h **** };
 575:/usr/include/libusb-1.0/libusb.h **** 
 576:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 577:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB interface descriptor. This
 578:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.5 of the USB 3.0 specification.
 579:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 580:/usr/include/libusb-1.0/libusb.h ****  */
 581:/usr/include/libusb-1.0/libusb.h **** struct libusb_interface_descriptor {
 582:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 583:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 584:/usr/include/libusb-1.0/libusb.h **** 
 585:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 586:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_INTERFACE LIBUSB_DT_INTERFACE
 587:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 588:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 589:/usr/include/libusb-1.0/libusb.h **** 
 590:/usr/include/libusb-1.0/libusb.h **** 	/** Number of this interface */
 591:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceNumber;
 592:/usr/include/libusb-1.0/libusb.h **** 
 593:/usr/include/libusb-1.0/libusb.h **** 	/** Value used to select this alternate setting for this interface */
 594:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bAlternateSetting;
 595:/usr/include/libusb-1.0/libusb.h **** 
 596:/usr/include/libusb-1.0/libusb.h **** 	/** Number of endpoints used by this interface (excluding the control
 597:/usr/include/libusb-1.0/libusb.h **** 	 * endpoint). */
 598:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumEndpoints;
 599:/usr/include/libusb-1.0/libusb.h **** 
 600:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF class code for this interface. See \ref libusb_class_code. */
 601:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceClass;
 602:/usr/include/libusb-1.0/libusb.h **** 
 603:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF subclass code for this interface, qualified by the
 604:/usr/include/libusb-1.0/libusb.h **** 	 * bInterfaceClass value */
 605:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceSubClass;
 606:/usr/include/libusb-1.0/libusb.h **** 
 607:/usr/include/libusb-1.0/libusb.h **** 	/** USB-IF protocol code for this interface, qualified by the
 608:/usr/include/libusb-1.0/libusb.h **** 	 * bInterfaceClass and bInterfaceSubClass values */
 609:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bInterfaceProtocol;
 610:/usr/include/libusb-1.0/libusb.h **** 
 611:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing this interface */
 612:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iInterface;
 613:/usr/include/libusb-1.0/libusb.h **** 
 614:/usr/include/libusb-1.0/libusb.h **** 	/** Array of endpoint descriptors. This length of this array is determined
 615:/usr/include/libusb-1.0/libusb.h **** 	 * by the bNumEndpoints field. */
 616:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_endpoint_descriptor *endpoint;
 617:/usr/include/libusb-1.0/libusb.h **** 
 618:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusb encounters unknown interface descriptors,
 619:/usr/include/libusb-1.0/libusb.h **** 	 * it will store them here, should you wish to parse them. */
 620:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 621:/usr/include/libusb-1.0/libusb.h **** 
 622:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. */
 623:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 624:/usr/include/libusb-1.0/libusb.h **** };
 625:/usr/include/libusb-1.0/libusb.h **** 
 626:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 627:/usr/include/libusb-1.0/libusb.h ****  * A collection of alternate settings for a particular USB interface.
 628:/usr/include/libusb-1.0/libusb.h ****  */
 629:/usr/include/libusb-1.0/libusb.h **** struct libusb_interface {
 630:/usr/include/libusb-1.0/libusb.h **** 	/** Array of interface descriptors. The length of this array is determined
 631:/usr/include/libusb-1.0/libusb.h **** 	 * by the num_altsetting field. */
 632:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_interface_descriptor *altsetting;
 633:/usr/include/libusb-1.0/libusb.h **** 
 634:/usr/include/libusb-1.0/libusb.h **** 	/** The number of alternate settings that belong to this interface */
 635:/usr/include/libusb-1.0/libusb.h **** 	int num_altsetting;
 636:/usr/include/libusb-1.0/libusb.h **** };
 637:/usr/include/libusb-1.0/libusb.h **** 
 638:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 639:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the standard USB configuration descriptor. This
 640:/usr/include/libusb-1.0/libusb.h ****  * descriptor is documented in section 9.6.3 of the USB 3.0 specification.
 641:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 642:/usr/include/libusb-1.0/libusb.h ****  */
 643:/usr/include/libusb-1.0/libusb.h **** struct libusb_config_descriptor {
 644:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 645:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 646:/usr/include/libusb-1.0/libusb.h **** 
 647:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 648:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_CONFIG LIBUSB_DT_CONFIG
 649:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 650:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 651:/usr/include/libusb-1.0/libusb.h **** 
 652:/usr/include/libusb-1.0/libusb.h **** 	/** Total length of data returned for this configuration */
 653:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wTotalLength;
 654:/usr/include/libusb-1.0/libusb.h **** 
 655:/usr/include/libusb-1.0/libusb.h **** 	/** Number of interfaces supported by this configuration */
 656:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumInterfaces;
 657:/usr/include/libusb-1.0/libusb.h **** 
 658:/usr/include/libusb-1.0/libusb.h **** 	/** Identifier value for this configuration */
 659:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bConfigurationValue;
 660:/usr/include/libusb-1.0/libusb.h **** 
 661:/usr/include/libusb-1.0/libusb.h **** 	/** Index of string descriptor describing this configuration */
 662:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  iConfiguration;
 663:/usr/include/libusb-1.0/libusb.h **** 
 664:/usr/include/libusb-1.0/libusb.h **** 	/** Configuration characteristics */
 665:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 666:/usr/include/libusb-1.0/libusb.h **** 
 667:/usr/include/libusb-1.0/libusb.h **** 	/** Maximum power consumption of the USB device from this bus in this
 668:/usr/include/libusb-1.0/libusb.h **** 	 * configuration when the device is fully operation. Expressed in units
 669:/usr/include/libusb-1.0/libusb.h **** 	 * of 2 mA when the device is operating in high-speed mode and in units
 670:/usr/include/libusb-1.0/libusb.h **** 	 * of 8 mA when the device is operating in super-speed mode. */
 671:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  MaxPower;
 672:/usr/include/libusb-1.0/libusb.h **** 
 673:/usr/include/libusb-1.0/libusb.h **** 	/** Array of interfaces supported by this configuration. The length of
 674:/usr/include/libusb-1.0/libusb.h **** 	 * this array is determined by the bNumInterfaces field. */
 675:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_interface *interface;
 676:/usr/include/libusb-1.0/libusb.h **** 
 677:/usr/include/libusb-1.0/libusb.h **** 	/** Extra descriptors. If libusb encounters unknown configuration
 678:/usr/include/libusb-1.0/libusb.h **** 	 * descriptors, it will store them here, should you wish to parse them. */
 679:/usr/include/libusb-1.0/libusb.h **** 	const unsigned char *extra;
 680:/usr/include/libusb-1.0/libusb.h **** 
 681:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the extra descriptors, in bytes. */
 682:/usr/include/libusb-1.0/libusb.h **** 	int extra_length;
 683:/usr/include/libusb-1.0/libusb.h **** };
 684:/usr/include/libusb-1.0/libusb.h **** 
 685:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 686:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the superspeed endpoint companion
 687:/usr/include/libusb-1.0/libusb.h ****  * descriptor. This descriptor is documented in section 9.6.7 of
 688:/usr/include/libusb-1.0/libusb.h ****  * the USB 3.0 specification. All multiple-byte fields are represented in
 689:/usr/include/libusb-1.0/libusb.h ****  * host-endian format.
 690:/usr/include/libusb-1.0/libusb.h ****  */
 691:/usr/include/libusb-1.0/libusb.h **** struct libusb_ss_endpoint_companion_descriptor {
 692:/usr/include/libusb-1.0/libusb.h **** 
 693:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 694:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 695:/usr/include/libusb-1.0/libusb.h **** 
 696:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 697:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_SS_ENDPOINT_COMPANION in
 698:/usr/include/libusb-1.0/libusb.h **** 	 * this context. */
 699:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 700:/usr/include/libusb-1.0/libusb.h **** 
 701:/usr/include/libusb-1.0/libusb.h **** 
 702:/usr/include/libusb-1.0/libusb.h **** 	/** The maximum number of packets the endpoint can send or
 703:/usr/include/libusb-1.0/libusb.h **** 	 *  recieve as part of a burst. */
 704:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bMaxBurst;
 705:/usr/include/libusb-1.0/libusb.h **** 
 706:/usr/include/libusb-1.0/libusb.h **** 	/** In bulk EP:	bits 4:0 represents the	maximum	number of
 707:/usr/include/libusb-1.0/libusb.h **** 	 *  streams the	EP supports. In	isochronous EP:	bits 1:0
 708:/usr/include/libusb-1.0/libusb.h **** 	 *  represents the Mult	- a zero based value that determines
 709:/usr/include/libusb-1.0/libusb.h **** 	 *  the	maximum	number of packets within a service interval  */
 710:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 711:/usr/include/libusb-1.0/libusb.h **** 
 712:/usr/include/libusb-1.0/libusb.h **** 	/** The	total number of bytes this EP will transfer every
 713:/usr/include/libusb-1.0/libusb.h **** 	 *  service interval. valid only for periodic EPs. */
 714:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wBytesPerInterval;
 715:/usr/include/libusb-1.0/libusb.h **** };
 716:/usr/include/libusb-1.0/libusb.h **** 
 717:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 718:/usr/include/libusb-1.0/libusb.h ****  * A generic representation of a BOS Device Capability descriptor. It is
 719:/usr/include/libusb-1.0/libusb.h ****  * advised to check bDevCapabilityType and call the matching
 720:/usr/include/libusb-1.0/libusb.h ****  * libusb_get_*_descriptor function to get a structure fully matching the type.
 721:/usr/include/libusb-1.0/libusb.h ****  */
 722:/usr/include/libusb-1.0/libusb.h **** struct libusb_bos_dev_capability_descriptor {
 723:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 724:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bLength;
 725:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 726:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 727:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 728:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bDescriptorType;
 729:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability type */
 730:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bDevCapabilityType;
 731:/usr/include/libusb-1.0/libusb.h **** 	/** Device Capability data (bLength - 3 bytes) */
 732:/usr/include/libusb-1.0/libusb.h **** 	uint8_t dev_capability_data
 733:/usr/include/libusb-1.0/libusb.h **** #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
 734:/usr/include/libusb-1.0/libusb.h **** 	[] /* valid C99 code */
 735:/usr/include/libusb-1.0/libusb.h **** #else
 736:/usr/include/libusb-1.0/libusb.h **** 	[0] /* non-standard, but usually working code */
 737:/usr/include/libusb-1.0/libusb.h **** #endif
 738:/usr/include/libusb-1.0/libusb.h **** 	;
 739:/usr/include/libusb-1.0/libusb.h **** };
 740:/usr/include/libusb-1.0/libusb.h **** 
 741:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 742:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the Binary Device Object Store (BOS) descriptor.
 743:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2 of the USB 3.0 specification.
 744:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 745:/usr/include/libusb-1.0/libusb.h ****  */
 746:/usr/include/libusb-1.0/libusb.h **** struct libusb_bos_descriptor {
 747:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 748:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 749:/usr/include/libusb-1.0/libusb.h **** 
 750:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 751:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_BOS LIBUSB_DT_BOS
 752:/usr/include/libusb-1.0/libusb.h **** 	 * in this context. */
 753:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 754:/usr/include/libusb-1.0/libusb.h **** 
 755:/usr/include/libusb-1.0/libusb.h **** 	/** Length of this descriptor and all of its sub descriptors */
 756:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wTotalLength;
 757:/usr/include/libusb-1.0/libusb.h **** 
 758:/usr/include/libusb-1.0/libusb.h **** 	/** The number of separate device capability descriptors in
 759:/usr/include/libusb-1.0/libusb.h **** 	 * the BOS */
 760:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bNumDeviceCaps;
 761:/usr/include/libusb-1.0/libusb.h **** 
 762:/usr/include/libusb-1.0/libusb.h **** 	/** bNumDeviceCap Device Capability Descriptors */
 763:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_capability
 764:/usr/include/libusb-1.0/libusb.h **** #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
 765:/usr/include/libusb-1.0/libusb.h **** 	[] /* valid C99 code */
 766:/usr/include/libusb-1.0/libusb.h **** #else
 767:/usr/include/libusb-1.0/libusb.h **** 	[0] /* non-standard, but usually working code */
 768:/usr/include/libusb-1.0/libusb.h **** #endif
 769:/usr/include/libusb-1.0/libusb.h **** 	;
 770:/usr/include/libusb-1.0/libusb.h **** };
 771:/usr/include/libusb-1.0/libusb.h **** 
 772:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 773:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the USB 2.0 Extension descriptor
 774:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.1 of the USB 3.0 specification.
 775:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 776:/usr/include/libusb-1.0/libusb.h ****  */
 777:/usr/include/libusb-1.0/libusb.h **** struct libusb_usb_2_0_extension_descriptor {
 778:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 779:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 780:/usr/include/libusb-1.0/libusb.h **** 
 781:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 782:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 783:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 784:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 785:/usr/include/libusb-1.0/libusb.h **** 
 786:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 787:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_USB_2_0_EXTENSION
 788:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_USB_2_0_EXTENSION in this context. */
 789:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 790:/usr/include/libusb-1.0/libusb.h **** 
 791:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of supported device level features.
 792:/usr/include/libusb-1.0/libusb.h **** 	 * A value of one in a bit location indicates a feature is
 793:/usr/include/libusb-1.0/libusb.h **** 	 * supported; a value of zero indicates it is not supported.
 794:/usr/include/libusb-1.0/libusb.h **** 	 * See \ref libusb_usb_2_0_extension_attributes. */
 795:/usr/include/libusb-1.0/libusb.h **** 	uint32_t  bmAttributes;
 796:/usr/include/libusb-1.0/libusb.h **** };
 797:/usr/include/libusb-1.0/libusb.h **** 
 798:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 799:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the SuperSpeed USB Device Capability descriptor
 800:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.2 of the USB 3.0 specification.
 801:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields are represented in host-endian format.
 802:/usr/include/libusb-1.0/libusb.h ****  */
 803:/usr/include/libusb-1.0/libusb.h **** struct libusb_ss_usb_device_capability_descriptor {
 804:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 805:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 806:/usr/include/libusb-1.0/libusb.h **** 
 807:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 808:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 809:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 810:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 811:/usr/include/libusb-1.0/libusb.h **** 
 812:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 813:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_SS_USB_DEVICE_CAPABILITY
 814:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_SS_USB_DEVICE_CAPABILITY in this context. */
 815:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 816:/usr/include/libusb-1.0/libusb.h **** 
 817:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of supported device level features.
 818:/usr/include/libusb-1.0/libusb.h **** 	 * A value of one in a bit location indicates a feature is
 819:/usr/include/libusb-1.0/libusb.h **** 	 * supported; a value of zero indicates it is not supported.
 820:/usr/include/libusb-1.0/libusb.h **** 	 * See \ref libusb_ss_usb_device_capability_attributes. */
 821:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmAttributes;
 822:/usr/include/libusb-1.0/libusb.h **** 
 823:/usr/include/libusb-1.0/libusb.h **** 	/** Bitmap encoding of the speed supported by this device when
 824:/usr/include/libusb-1.0/libusb.h **** 	 * operating in SuperSpeed mode. See \ref libusb_supported_speed. */
 825:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wSpeedSupported;
 826:/usr/include/libusb-1.0/libusb.h **** 
 827:/usr/include/libusb-1.0/libusb.h **** 	/** The lowest speed at which all the functionality supported
 828:/usr/include/libusb-1.0/libusb.h **** 	 * by the device is available to the user. For example if the
 829:/usr/include/libusb-1.0/libusb.h **** 	 * device supports all its functionality when connected at
 830:/usr/include/libusb-1.0/libusb.h **** 	 * full speed and above then it sets this value to 1. */
 831:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bFunctionalitySupport;
 832:/usr/include/libusb-1.0/libusb.h **** 
 833:/usr/include/libusb-1.0/libusb.h **** 	/** U1 Device Exit Latency. */
 834:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bU1DevExitLat;
 835:/usr/include/libusb-1.0/libusb.h **** 
 836:/usr/include/libusb-1.0/libusb.h **** 	/** U2 Device Exit Latency. */
 837:/usr/include/libusb-1.0/libusb.h **** 	uint16_t bU2DevExitLat;
 838:/usr/include/libusb-1.0/libusb.h **** };
 839:/usr/include/libusb-1.0/libusb.h **** 
 840:/usr/include/libusb-1.0/libusb.h **** /** \ingroup desc
 841:/usr/include/libusb-1.0/libusb.h ****  * A structure representing the Container ID descriptor.
 842:/usr/include/libusb-1.0/libusb.h ****  * This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification.
 843:/usr/include/libusb-1.0/libusb.h ****  * All multiple-byte fields, except UUIDs, are represented in host-endian format.
 844:/usr/include/libusb-1.0/libusb.h ****  */
 845:/usr/include/libusb-1.0/libusb.h **** struct libusb_container_id_descriptor {
 846:/usr/include/libusb-1.0/libusb.h **** 	/** Size of this descriptor (in bytes) */
 847:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bLength;
 848:/usr/include/libusb-1.0/libusb.h **** 
 849:/usr/include/libusb-1.0/libusb.h **** 	/** Descriptor type. Will have value
 850:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
 851:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 852:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDescriptorType;
 853:/usr/include/libusb-1.0/libusb.h **** 
 854:/usr/include/libusb-1.0/libusb.h **** 	/** Capability type. Will have value
 855:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_capability_type::LIBUSB_BT_CONTAINER_ID
 856:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_BT_CONTAINER_ID in this context. */
 857:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bDevCapabilityType;
 858:/usr/include/libusb-1.0/libusb.h **** 
 859:/usr/include/libusb-1.0/libusb.h **** 	/** Reserved field */
 860:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bReserved;
 861:/usr/include/libusb-1.0/libusb.h **** 
 862:/usr/include/libusb-1.0/libusb.h **** 	/** 128 bit UUID */
 863:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  ContainerID[16];
 864:/usr/include/libusb-1.0/libusb.h **** };
 865:/usr/include/libusb-1.0/libusb.h **** 
 866:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
 867:/usr/include/libusb-1.0/libusb.h ****  * Setup packet for control transfers. */
 868:/usr/include/libusb-1.0/libusb.h **** struct libusb_control_setup {
 869:/usr/include/libusb-1.0/libusb.h **** 	/** Request type. Bits 0:4 determine recipient, see
 870:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_recipient. Bits 5:6 determine type, see
 871:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_type. Bit 7 determines data transfer direction, see
 872:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_endpoint_direction.
 873:/usr/include/libusb-1.0/libusb.h **** 	 */
 874:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bmRequestType;
 875:/usr/include/libusb-1.0/libusb.h **** 
 876:/usr/include/libusb-1.0/libusb.h **** 	/** Request. If the type bits of bmRequestType are equal to
 877:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_request_type::LIBUSB_REQUEST_TYPE_STANDARD
 878:/usr/include/libusb-1.0/libusb.h **** 	 * "LIBUSB_REQUEST_TYPE_STANDARD" then this field refers to
 879:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_standard_request. For other cases, use of this field is
 880:/usr/include/libusb-1.0/libusb.h **** 	 * application-specific. */
 881:/usr/include/libusb-1.0/libusb.h **** 	uint8_t  bRequest;
 882:/usr/include/libusb-1.0/libusb.h **** 
 883:/usr/include/libusb-1.0/libusb.h **** 	/** Value. Varies according to request */
 884:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wValue;
 885:/usr/include/libusb-1.0/libusb.h **** 
 886:/usr/include/libusb-1.0/libusb.h **** 	/** Index. Varies according to request, typically used to pass an index
 887:/usr/include/libusb-1.0/libusb.h **** 	 * or offset */
 888:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wIndex;
 889:/usr/include/libusb-1.0/libusb.h **** 
 890:/usr/include/libusb-1.0/libusb.h **** 	/** Number of bytes to transfer */
 891:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wLength;
 892:/usr/include/libusb-1.0/libusb.h **** };
 893:/usr/include/libusb-1.0/libusb.h **** 
 894:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_CONTROL_SETUP_SIZE (sizeof(struct libusb_control_setup))
 895:/usr/include/libusb-1.0/libusb.h **** 
 896:/usr/include/libusb-1.0/libusb.h **** /* libusb */
 897:/usr/include/libusb-1.0/libusb.h **** 
 898:/usr/include/libusb-1.0/libusb.h **** struct libusb_context;
 899:/usr/include/libusb-1.0/libusb.h **** struct libusb_device;
 900:/usr/include/libusb-1.0/libusb.h **** struct libusb_device_handle;
 901:/usr/include/libusb-1.0/libusb.h **** 
 902:/usr/include/libusb-1.0/libusb.h **** /** \ingroup lib
 903:/usr/include/libusb-1.0/libusb.h ****  * Structure providing the version of the libusb runtime
 904:/usr/include/libusb-1.0/libusb.h ****  */
 905:/usr/include/libusb-1.0/libusb.h **** struct libusb_version {
 906:/usr/include/libusb-1.0/libusb.h **** 	/** Library major version. */
 907:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t major;
 908:/usr/include/libusb-1.0/libusb.h **** 
 909:/usr/include/libusb-1.0/libusb.h **** 	/** Library minor version. */
 910:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t minor;
 911:/usr/include/libusb-1.0/libusb.h **** 
 912:/usr/include/libusb-1.0/libusb.h **** 	/** Library micro version. */
 913:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t micro;
 914:/usr/include/libusb-1.0/libusb.h **** 
 915:/usr/include/libusb-1.0/libusb.h **** 	/** Library nano version. */
 916:/usr/include/libusb-1.0/libusb.h **** 	const uint16_t nano;
 917:/usr/include/libusb-1.0/libusb.h **** 
 918:/usr/include/libusb-1.0/libusb.h **** 	/** Library release candidate suffix string, e.g. "-rc4". */
 919:/usr/include/libusb-1.0/libusb.h **** 	const char *rc;
 920:/usr/include/libusb-1.0/libusb.h **** 
 921:/usr/include/libusb-1.0/libusb.h **** 	/** For ABI compatibility only. */
 922:/usr/include/libusb-1.0/libusb.h **** 	const char* describe;
 923:/usr/include/libusb-1.0/libusb.h **** };
 924:/usr/include/libusb-1.0/libusb.h **** 
 925:/usr/include/libusb-1.0/libusb.h **** /** \ingroup lib
 926:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a libusb session. The concept of individual libusb
 927:/usr/include/libusb-1.0/libusb.h ****  * sessions allows for your program to use two libraries (or dynamically
 928:/usr/include/libusb-1.0/libusb.h ****  * load two modules) which both independently use libusb. This will prevent
 929:/usr/include/libusb-1.0/libusb.h ****  * interference between the individual libusb users - for example
 930:/usr/include/libusb-1.0/libusb.h ****  * libusb_set_debug() will not affect the other user of the library, and
 931:/usr/include/libusb-1.0/libusb.h ****  * libusb_exit() will not destroy resources that the other user is still
 932:/usr/include/libusb-1.0/libusb.h ****  * using.
 933:/usr/include/libusb-1.0/libusb.h ****  *
 934:/usr/include/libusb-1.0/libusb.h ****  * Sessions are created by libusb_init() and destroyed through libusb_exit().
 935:/usr/include/libusb-1.0/libusb.h ****  * If your application is guaranteed to only ever include a single libusb
 936:/usr/include/libusb-1.0/libusb.h ****  * user (i.e. you), you do not have to worry about contexts: pass NULL in
 937:/usr/include/libusb-1.0/libusb.h ****  * every function call where a context is required. The default context
 938:/usr/include/libusb-1.0/libusb.h ****  * will be used.
 939:/usr/include/libusb-1.0/libusb.h ****  *
 940:/usr/include/libusb-1.0/libusb.h ****  * For more information, see \ref contexts.
 941:/usr/include/libusb-1.0/libusb.h ****  */
 942:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_context libusb_context;
 943:/usr/include/libusb-1.0/libusb.h **** 
 944:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
 945:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a USB device detected on the system. This is an
 946:/usr/include/libusb-1.0/libusb.h ****  * opaque type for which you are only ever provided with a pointer, usually
 947:/usr/include/libusb-1.0/libusb.h ****  * originating from libusb_get_device_list().
 948:/usr/include/libusb-1.0/libusb.h ****  *
 949:/usr/include/libusb-1.0/libusb.h ****  * Certain operations can be performed on a device, but in order to do any
 950:/usr/include/libusb-1.0/libusb.h ****  * I/O you will have to first obtain a device handle using libusb_open().
 951:/usr/include/libusb-1.0/libusb.h ****  *
 952:/usr/include/libusb-1.0/libusb.h ****  * Devices are reference counted with libusb_ref_device() and
 953:/usr/include/libusb-1.0/libusb.h ****  * libusb_unref_device(), and are freed when the reference count reaches 0.
 954:/usr/include/libusb-1.0/libusb.h ****  * New devices presented by libusb_get_device_list() have a reference count of
 955:/usr/include/libusb-1.0/libusb.h ****  * 1, and libusb_free_device_list() can optionally decrease the reference count
 956:/usr/include/libusb-1.0/libusb.h ****  * on all devices in the list. libusb_open() adds another reference which is
 957:/usr/include/libusb-1.0/libusb.h ****  * later destroyed by libusb_close().
 958:/usr/include/libusb-1.0/libusb.h ****  */
 959:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_device libusb_device;
 960:/usr/include/libusb-1.0/libusb.h **** 
 961:/usr/include/libusb-1.0/libusb.h **** 
 962:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
 963:/usr/include/libusb-1.0/libusb.h ****  * Structure representing a handle on a USB device. This is an opaque type for
 964:/usr/include/libusb-1.0/libusb.h ****  * which you are only ever provided with a pointer, usually originating from
 965:/usr/include/libusb-1.0/libusb.h ****  * libusb_open().
 966:/usr/include/libusb-1.0/libusb.h ****  *
 967:/usr/include/libusb-1.0/libusb.h ****  * A device handle is used to perform I/O and other operations. When finished
 968:/usr/include/libusb-1.0/libusb.h ****  * with a device handle, you should call libusb_close().
 969:/usr/include/libusb-1.0/libusb.h ****  */
 970:/usr/include/libusb-1.0/libusb.h **** typedef struct libusb_device_handle libusb_device_handle;
 971:/usr/include/libusb-1.0/libusb.h **** 
 972:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
 973:/usr/include/libusb-1.0/libusb.h ****  * Speed codes. Indicates the speed at which the device is operating.
 974:/usr/include/libusb-1.0/libusb.h ****  */
 975:/usr/include/libusb-1.0/libusb.h **** enum libusb_speed {
 976:/usr/include/libusb-1.0/libusb.h **** 	/** The OS doesn't report or know the device speed. */
 977:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_UNKNOWN = 0,
 978:/usr/include/libusb-1.0/libusb.h **** 
 979:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at low speed (1.5MBit/s). */
 980:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_LOW = 1,
 981:/usr/include/libusb-1.0/libusb.h **** 
 982:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at full speed (12MBit/s). */
 983:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_FULL = 2,
 984:/usr/include/libusb-1.0/libusb.h **** 
 985:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at high speed (480MBit/s). */
 986:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_HIGH = 3,
 987:/usr/include/libusb-1.0/libusb.h **** 
 988:/usr/include/libusb-1.0/libusb.h **** 	/** The device is operating at super speed (5000MBit/s). */
 989:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SPEED_SUPER = 4,
 990:/usr/include/libusb-1.0/libusb.h **** };
 991:/usr/include/libusb-1.0/libusb.h **** 
 992:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
 993:/usr/include/libusb-1.0/libusb.h ****  * Supported speeds (wSpeedSupported) bitfield. Indicates what
 994:/usr/include/libusb-1.0/libusb.h ****  * speeds the device supports.
 995:/usr/include/libusb-1.0/libusb.h ****  */
 996:/usr/include/libusb-1.0/libusb.h **** enum libusb_supported_speed {
 997:/usr/include/libusb-1.0/libusb.h **** 	/** Low speed operation supported (1.5MBit/s). */
 998:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOW_SPEED_OPERATION   = 1,
 999:/usr/include/libusb-1.0/libusb.h **** 
1000:/usr/include/libusb-1.0/libusb.h **** 	/** Full speed operation supported (12MBit/s). */
1001:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_FULL_SPEED_OPERATION  = 2,
1002:/usr/include/libusb-1.0/libusb.h **** 
1003:/usr/include/libusb-1.0/libusb.h **** 	/** High speed operation supported (480MBit/s). */
1004:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_HIGH_SPEED_OPERATION  = 4,
1005:/usr/include/libusb-1.0/libusb.h **** 
1006:/usr/include/libusb-1.0/libusb.h **** 	/** Superspeed operation supported (5000MBit/s). */
1007:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SUPER_SPEED_OPERATION = 8,
1008:/usr/include/libusb-1.0/libusb.h **** };
1009:/usr/include/libusb-1.0/libusb.h **** 
1010:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
1011:/usr/include/libusb-1.0/libusb.h ****  * Masks for the bits of the
1012:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_usb_2_0_extension_descriptor::bmAttributes "bmAttributes" field
1013:/usr/include/libusb-1.0/libusb.h ****  * of the USB 2.0 Extension descriptor.
1014:/usr/include/libusb-1.0/libusb.h ****  */
1015:/usr/include/libusb-1.0/libusb.h **** enum libusb_usb_2_0_extension_attributes {
1016:/usr/include/libusb-1.0/libusb.h **** 	/** Supports Link Power Management (LPM) */
1017:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BM_LPM_SUPPORT = 2,
1018:/usr/include/libusb-1.0/libusb.h **** };
1019:/usr/include/libusb-1.0/libusb.h **** 
1020:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
1021:/usr/include/libusb-1.0/libusb.h ****  * Masks for the bits of the
1022:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_ss_usb_device_capability_descriptor::bmAttributes "bmAttributes" field
1023:/usr/include/libusb-1.0/libusb.h ****  * field of the SuperSpeed USB Device Capability descriptor.
1024:/usr/include/libusb-1.0/libusb.h ****  */
1025:/usr/include/libusb-1.0/libusb.h **** enum libusb_ss_usb_device_capability_attributes {
1026:/usr/include/libusb-1.0/libusb.h **** 	/** Supports Latency Tolerance Messages (LTM) */
1027:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BM_LTM_SUPPORT = 2,
1028:/usr/include/libusb-1.0/libusb.h **** };
1029:/usr/include/libusb-1.0/libusb.h **** 
1030:/usr/include/libusb-1.0/libusb.h **** /** \ingroup dev
1031:/usr/include/libusb-1.0/libusb.h ****  * USB capability types
1032:/usr/include/libusb-1.0/libusb.h ****  */
1033:/usr/include/libusb-1.0/libusb.h **** enum libusb_bos_type {
1034:/usr/include/libusb-1.0/libusb.h **** 	/** Wireless USB device capability */
1035:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY	= 1,
1036:/usr/include/libusb-1.0/libusb.h **** 
1037:/usr/include/libusb-1.0/libusb.h **** 	/** USB 2.0 extensions */
1038:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_USB_2_0_EXTENSION			= 2,
1039:/usr/include/libusb-1.0/libusb.h **** 
1040:/usr/include/libusb-1.0/libusb.h **** 	/** SuperSpeed USB device capability */
1041:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_SS_USB_DEVICE_CAPABILITY		= 3,
1042:/usr/include/libusb-1.0/libusb.h **** 
1043:/usr/include/libusb-1.0/libusb.h **** 	/** Container ID type */
1044:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_BT_CONTAINER_ID				= 4,
1045:/usr/include/libusb-1.0/libusb.h **** };
1046:/usr/include/libusb-1.0/libusb.h **** 
1047:/usr/include/libusb-1.0/libusb.h **** /** \ingroup misc
1048:/usr/include/libusb-1.0/libusb.h ****  * Error codes. Most libusb functions return 0 on success or one of these
1049:/usr/include/libusb-1.0/libusb.h ****  * codes on failure.
1050:/usr/include/libusb-1.0/libusb.h ****  * You can call libusb_error_name() to retrieve a string representation of an
1051:/usr/include/libusb-1.0/libusb.h ****  * error code or libusb_strerror() to get an end-user suitable description of
1052:/usr/include/libusb-1.0/libusb.h ****  * an error code.
1053:/usr/include/libusb-1.0/libusb.h ****  */
1054:/usr/include/libusb-1.0/libusb.h **** enum libusb_error {
1055:/usr/include/libusb-1.0/libusb.h **** 	/** Success (no error) */
1056:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_SUCCESS = 0,
1057:/usr/include/libusb-1.0/libusb.h **** 
1058:/usr/include/libusb-1.0/libusb.h **** 	/** Input/output error */
1059:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_IO = -1,
1060:/usr/include/libusb-1.0/libusb.h **** 
1061:/usr/include/libusb-1.0/libusb.h **** 	/** Invalid parameter */
1062:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_INVALID_PARAM = -2,
1063:/usr/include/libusb-1.0/libusb.h **** 
1064:/usr/include/libusb-1.0/libusb.h **** 	/** Access denied (insufficient permissions) */
1065:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_ACCESS = -3,
1066:/usr/include/libusb-1.0/libusb.h **** 
1067:/usr/include/libusb-1.0/libusb.h **** 	/** No such device (it may have been disconnected) */
1068:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NO_DEVICE = -4,
1069:/usr/include/libusb-1.0/libusb.h **** 
1070:/usr/include/libusb-1.0/libusb.h **** 	/** Entity not found */
1071:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NOT_FOUND = -5,
1072:/usr/include/libusb-1.0/libusb.h **** 
1073:/usr/include/libusb-1.0/libusb.h **** 	/** Resource busy */
1074:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_BUSY = -6,
1075:/usr/include/libusb-1.0/libusb.h **** 
1076:/usr/include/libusb-1.0/libusb.h **** 	/** Operation timed out */
1077:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_TIMEOUT = -7,
1078:/usr/include/libusb-1.0/libusb.h **** 
1079:/usr/include/libusb-1.0/libusb.h **** 	/** Overflow */
1080:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_OVERFLOW = -8,
1081:/usr/include/libusb-1.0/libusb.h **** 
1082:/usr/include/libusb-1.0/libusb.h **** 	/** Pipe error */
1083:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_PIPE = -9,
1084:/usr/include/libusb-1.0/libusb.h **** 
1085:/usr/include/libusb-1.0/libusb.h **** 	/** System call interrupted (perhaps due to signal) */
1086:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_INTERRUPTED = -10,
1087:/usr/include/libusb-1.0/libusb.h **** 
1088:/usr/include/libusb-1.0/libusb.h **** 	/** Insufficient memory */
1089:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NO_MEM = -11,
1090:/usr/include/libusb-1.0/libusb.h **** 
1091:/usr/include/libusb-1.0/libusb.h **** 	/** Operation not supported or unimplemented on this platform */
1092:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_NOT_SUPPORTED = -12,
1093:/usr/include/libusb-1.0/libusb.h **** 
1094:/usr/include/libusb-1.0/libusb.h **** 	/* NB: Remember to update LIBUSB_ERROR_COUNT below as well as the
1095:/usr/include/libusb-1.0/libusb.h **** 	   message strings in strerror.c when adding new error codes here. */
1096:/usr/include/libusb-1.0/libusb.h **** 
1097:/usr/include/libusb-1.0/libusb.h **** 	/** Other error */
1098:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_ERROR_OTHER = -99,
1099:/usr/include/libusb-1.0/libusb.h **** };
1100:/usr/include/libusb-1.0/libusb.h **** 
1101:/usr/include/libusb-1.0/libusb.h **** /* Total number of error codes in enum libusb_error */
1102:/usr/include/libusb-1.0/libusb.h **** #define LIBUSB_ERROR_COUNT 14
1103:/usr/include/libusb-1.0/libusb.h **** 
1104:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1105:/usr/include/libusb-1.0/libusb.h ****  * Transfer status codes */
1106:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_status {
1107:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer completed without error. Note that this does not indicate
1108:/usr/include/libusb-1.0/libusb.h **** 	 * that the entire amount of requested data was transferred. */
1109:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_COMPLETED,
1110:/usr/include/libusb-1.0/libusb.h **** 
1111:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer failed */
1112:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_ERROR,
1113:/usr/include/libusb-1.0/libusb.h **** 
1114:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer timed out */
1115:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_TIMED_OUT,
1116:/usr/include/libusb-1.0/libusb.h **** 
1117:/usr/include/libusb-1.0/libusb.h **** 	/** Transfer was cancelled */
1118:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_CANCELLED,
1119:/usr/include/libusb-1.0/libusb.h **** 
1120:/usr/include/libusb-1.0/libusb.h **** 	/** For bulk/interrupt endpoints: halt condition detected (endpoint
1121:/usr/include/libusb-1.0/libusb.h **** 	 * stalled). For control endpoints: control request not supported. */
1122:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_STALL,
1123:/usr/include/libusb-1.0/libusb.h **** 
1124:/usr/include/libusb-1.0/libusb.h **** 	/** Device was disconnected */
1125:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_NO_DEVICE,
1126:/usr/include/libusb-1.0/libusb.h **** 
1127:/usr/include/libusb-1.0/libusb.h **** 	/** Device sent more data than requested */
1128:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_OVERFLOW,
1129:/usr/include/libusb-1.0/libusb.h **** 
1130:/usr/include/libusb-1.0/libusb.h **** 	/* NB! Remember to update libusb_error_name()
1131:/usr/include/libusb-1.0/libusb.h **** 	   when adding new status codes here. */
1132:/usr/include/libusb-1.0/libusb.h **** };
1133:/usr/include/libusb-1.0/libusb.h **** 
1134:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1135:/usr/include/libusb-1.0/libusb.h ****  * libusb_transfer.flags values */
1136:/usr/include/libusb-1.0/libusb.h **** enum libusb_transfer_flags {
1137:/usr/include/libusb-1.0/libusb.h **** 	/** Report short frames as errors */
1138:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_SHORT_NOT_OK = 1<<0,
1139:/usr/include/libusb-1.0/libusb.h **** 
1140:/usr/include/libusb-1.0/libusb.h **** 	/** Automatically free() transfer buffer during libusb_free_transfer() */
1141:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_FREE_BUFFER = 1<<1,
1142:/usr/include/libusb-1.0/libusb.h **** 
1143:/usr/include/libusb-1.0/libusb.h **** 	/** Automatically call libusb_free_transfer() after callback returns.
1144:/usr/include/libusb-1.0/libusb.h **** 	 * If this flag is set, it is illegal to call libusb_free_transfer()
1145:/usr/include/libusb-1.0/libusb.h **** 	 * from your transfer callback, as this will result in a double-free
1146:/usr/include/libusb-1.0/libusb.h **** 	 * when this flag is acted upon. */
1147:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_FREE_TRANSFER = 1<<2,
1148:/usr/include/libusb-1.0/libusb.h **** 
1149:/usr/include/libusb-1.0/libusb.h **** 	/** Terminate transfers that are a multiple of the endpoint's
1150:/usr/include/libusb-1.0/libusb.h **** 	 * wMaxPacketSize with an extra zero length packet. This is useful
1151:/usr/include/libusb-1.0/libusb.h **** 	 * when a device protocol mandates that each logical request is
1152:/usr/include/libusb-1.0/libusb.h **** 	 * terminated by an incomplete packet (i.e. the logical requests are
1153:/usr/include/libusb-1.0/libusb.h **** 	 * not separated by other means).
1154:/usr/include/libusb-1.0/libusb.h **** 	 *
1155:/usr/include/libusb-1.0/libusb.h **** 	 * This flag only affects host-to-device transfers to bulk and interrupt
1156:/usr/include/libusb-1.0/libusb.h **** 	 * endpoints. In other situations, it is ignored.
1157:/usr/include/libusb-1.0/libusb.h **** 	 *
1158:/usr/include/libusb-1.0/libusb.h **** 	 * This flag only affects transfers with a length that is a multiple of
1159:/usr/include/libusb-1.0/libusb.h **** 	 * the endpoint's wMaxPacketSize. On transfers of other lengths, this
1160:/usr/include/libusb-1.0/libusb.h **** 	 * flag has no effect. Therefore, if you are working with a device that
1161:/usr/include/libusb-1.0/libusb.h **** 	 * needs a ZLP whenever the end of the logical request falls on a packet
1162:/usr/include/libusb-1.0/libusb.h **** 	 * boundary, then it is sensible to set this flag on <em>every</em>
1163:/usr/include/libusb-1.0/libusb.h **** 	 * transfer (you do not have to worry about only setting it on transfers
1164:/usr/include/libusb-1.0/libusb.h **** 	 * that end on the boundary).
1165:/usr/include/libusb-1.0/libusb.h **** 	 *
1166:/usr/include/libusb-1.0/libusb.h **** 	 * This flag is currently only supported on Linux.
1167:/usr/include/libusb-1.0/libusb.h **** 	 * On other systems, libusb_submit_transfer() will return
1168:/usr/include/libusb-1.0/libusb.h **** 	 * LIBUSB_ERROR_NOT_SUPPORTED for every transfer where this flag is set.
1169:/usr/include/libusb-1.0/libusb.h **** 	 *
1170:/usr/include/libusb-1.0/libusb.h **** 	 * Available since libusb-1.0.9.
1171:/usr/include/libusb-1.0/libusb.h **** 	 */
1172:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_TRANSFER_ADD_ZERO_PACKET = 1 << 3,
1173:/usr/include/libusb-1.0/libusb.h **** };
1174:/usr/include/libusb-1.0/libusb.h **** 
1175:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1176:/usr/include/libusb-1.0/libusb.h ****  * Isochronous packet descriptor. */
1177:/usr/include/libusb-1.0/libusb.h **** struct libusb_iso_packet_descriptor {
1178:/usr/include/libusb-1.0/libusb.h **** 	/** Length of data to request in this packet */
1179:/usr/include/libusb-1.0/libusb.h **** 	unsigned int length;
1180:/usr/include/libusb-1.0/libusb.h **** 
1181:/usr/include/libusb-1.0/libusb.h **** 	/** Amount of data that was actually transferred */
1182:/usr/include/libusb-1.0/libusb.h **** 	unsigned int actual_length;
1183:/usr/include/libusb-1.0/libusb.h **** 
1184:/usr/include/libusb-1.0/libusb.h **** 	/** Status code for this packet */
1185:/usr/include/libusb-1.0/libusb.h **** 	enum libusb_transfer_status status;
1186:/usr/include/libusb-1.0/libusb.h **** };
1187:/usr/include/libusb-1.0/libusb.h **** 
1188:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer;
1189:/usr/include/libusb-1.0/libusb.h **** 
1190:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1191:/usr/include/libusb-1.0/libusb.h ****  * Asynchronous transfer callback function type. When submitting asynchronous
1192:/usr/include/libusb-1.0/libusb.h ****  * transfers, you pass a pointer to a callback function of this type via the
1193:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_transfer::callback "callback" member of the libusb_transfer
1194:/usr/include/libusb-1.0/libusb.h ****  * structure. libusb will call this function later, when the transfer has
1195:/usr/include/libusb-1.0/libusb.h ****  * completed or failed. See \ref asyncio for more information.
1196:/usr/include/libusb-1.0/libusb.h ****  * \param transfer The libusb_transfer struct the callback function is being
1197:/usr/include/libusb-1.0/libusb.h ****  * notified about.
1198:/usr/include/libusb-1.0/libusb.h ****  */
1199:/usr/include/libusb-1.0/libusb.h **** typedef void (LIBUSB_CALL *libusb_transfer_cb_fn)(struct libusb_transfer *transfer);
1200:/usr/include/libusb-1.0/libusb.h **** 
1201:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1202:/usr/include/libusb-1.0/libusb.h ****  * The generic USB transfer structure. The user populates this structure and
1203:/usr/include/libusb-1.0/libusb.h ****  * then submits it in order to request a transfer. After the transfer has
1204:/usr/include/libusb-1.0/libusb.h ****  * completed, the library populates the transfer with the results and passes
1205:/usr/include/libusb-1.0/libusb.h ****  * it back to the user.
1206:/usr/include/libusb-1.0/libusb.h ****  */
1207:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer {
1208:/usr/include/libusb-1.0/libusb.h **** 	/** Handle of the device that this transfer will be submitted to */
1209:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev_handle;
1210:/usr/include/libusb-1.0/libusb.h **** 
1211:/usr/include/libusb-1.0/libusb.h **** 	/** A bitwise OR combination of \ref libusb_transfer_flags. */
1212:/usr/include/libusb-1.0/libusb.h **** 	uint8_t flags;
1213:/usr/include/libusb-1.0/libusb.h **** 
1214:/usr/include/libusb-1.0/libusb.h **** 	/** Address of the endpoint where this transfer will be sent. */
1215:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint;
1216:/usr/include/libusb-1.0/libusb.h **** 
1217:/usr/include/libusb-1.0/libusb.h **** 	/** Type of the endpoint from \ref libusb_transfer_type */
1218:/usr/include/libusb-1.0/libusb.h **** 	unsigned char type;
1219:/usr/include/libusb-1.0/libusb.h **** 
1220:/usr/include/libusb-1.0/libusb.h **** 	/** Timeout for this transfer in millseconds. A value of 0 indicates no
1221:/usr/include/libusb-1.0/libusb.h **** 	 * timeout. */
1222:/usr/include/libusb-1.0/libusb.h **** 	unsigned int timeout;
1223:/usr/include/libusb-1.0/libusb.h **** 
1224:/usr/include/libusb-1.0/libusb.h **** 	/** The status of the transfer. Read-only, and only for use within
1225:/usr/include/libusb-1.0/libusb.h **** 	 * transfer callback function.
1226:/usr/include/libusb-1.0/libusb.h **** 	 *
1227:/usr/include/libusb-1.0/libusb.h **** 	 * If this is an isochronous transfer, this field may read COMPLETED even
1228:/usr/include/libusb-1.0/libusb.h **** 	 * if there were errors in the frames. Use the
1229:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_iso_packet_descriptor::status "status" field in each packet
1230:/usr/include/libusb-1.0/libusb.h **** 	 * to determine if errors occurred. */
1231:/usr/include/libusb-1.0/libusb.h **** 	enum libusb_transfer_status status;
1232:/usr/include/libusb-1.0/libusb.h **** 
1233:/usr/include/libusb-1.0/libusb.h **** 	/** Length of the data buffer */
1234:/usr/include/libusb-1.0/libusb.h **** 	int length;
1235:/usr/include/libusb-1.0/libusb.h **** 
1236:/usr/include/libusb-1.0/libusb.h **** 	/** Actual length of data that was transferred. Read-only, and only for
1237:/usr/include/libusb-1.0/libusb.h **** 	 * use within transfer callback function. Not valid for isochronous
1238:/usr/include/libusb-1.0/libusb.h **** 	 * endpoint transfers. */
1239:/usr/include/libusb-1.0/libusb.h **** 	int actual_length;
1240:/usr/include/libusb-1.0/libusb.h **** 
1241:/usr/include/libusb-1.0/libusb.h **** 	/** Callback function. This will be invoked when the transfer completes,
1242:/usr/include/libusb-1.0/libusb.h **** 	 * fails, or is cancelled. */
1243:/usr/include/libusb-1.0/libusb.h **** 	libusb_transfer_cb_fn callback;
1244:/usr/include/libusb-1.0/libusb.h **** 
1245:/usr/include/libusb-1.0/libusb.h **** 	/** User context data to pass to the callback function. */
1246:/usr/include/libusb-1.0/libusb.h **** 	void *user_data;
1247:/usr/include/libusb-1.0/libusb.h **** 
1248:/usr/include/libusb-1.0/libusb.h **** 	/** Data buffer */
1249:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer;
1250:/usr/include/libusb-1.0/libusb.h **** 
1251:/usr/include/libusb-1.0/libusb.h **** 	/** Number of isochronous packets. Only used for I/O with isochronous
1252:/usr/include/libusb-1.0/libusb.h **** 	 * endpoints. */
1253:/usr/include/libusb-1.0/libusb.h **** 	int num_iso_packets;
1254:/usr/include/libusb-1.0/libusb.h **** 
1255:/usr/include/libusb-1.0/libusb.h **** 	/** Isochronous packet descriptors, for isochronous transfers only. */
1256:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_iso_packet_descriptor iso_packet_desc
1257:/usr/include/libusb-1.0/libusb.h **** #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
1258:/usr/include/libusb-1.0/libusb.h **** 	[] /* valid C99 code */
1259:/usr/include/libusb-1.0/libusb.h **** #else
1260:/usr/include/libusb-1.0/libusb.h **** 	[0] /* non-standard, but usually working code */
1261:/usr/include/libusb-1.0/libusb.h **** #endif
1262:/usr/include/libusb-1.0/libusb.h **** 	;
1263:/usr/include/libusb-1.0/libusb.h **** };
1264:/usr/include/libusb-1.0/libusb.h **** 
1265:/usr/include/libusb-1.0/libusb.h **** /** \ingroup misc
1266:/usr/include/libusb-1.0/libusb.h ****  * Capabilities supported by an instance of libusb on the current running
1267:/usr/include/libusb-1.0/libusb.h ****  * platform. Test if the loaded library supports a given capability by calling
1268:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_has_capability().
1269:/usr/include/libusb-1.0/libusb.h ****  */
1270:/usr/include/libusb-1.0/libusb.h **** enum libusb_capability {
1271:/usr/include/libusb-1.0/libusb.h **** 	/** The libusb_has_capability() API is available. */
1272:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_CAPABILITY = 0x0000,
1273:/usr/include/libusb-1.0/libusb.h **** 	/** Hotplug support is available on this platform. */
1274:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_HOTPLUG = 0x0001,
1275:/usr/include/libusb-1.0/libusb.h **** 	/** The library can access HID devices without requiring user intervention.
1276:/usr/include/libusb-1.0/libusb.h **** 	 * Note that before being able to actually access an HID device, you may
1277:/usr/include/libusb-1.0/libusb.h **** 	 * still have to call additional libusb functions such as
1278:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_detach_kernel_driver(). */
1279:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_HAS_HID_ACCESS = 0x0100,
1280:/usr/include/libusb-1.0/libusb.h **** 	/** The library supports detaching of the default USB driver, using 
1281:/usr/include/libusb-1.0/libusb.h **** 	 * \ref libusb_detach_kernel_driver(), if one is set by the OS kernel */
1282:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER = 0x0101
1283:/usr/include/libusb-1.0/libusb.h **** };
1284:/usr/include/libusb-1.0/libusb.h **** 
1285:/usr/include/libusb-1.0/libusb.h **** /** \ingroup lib
1286:/usr/include/libusb-1.0/libusb.h ****  *  Log message levels.
1287:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_NONE (0)    : no messages ever printed by the library (default)
1288:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_ERROR (1)   : error messages are printed to stderr
1289:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_WARNING (2) : warning and error messages are printed to stderr
1290:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_INFO (3)    : informational messages are printed to stdout, warning
1291:/usr/include/libusb-1.0/libusb.h ****  *    and error messages are printed to stderr
1292:/usr/include/libusb-1.0/libusb.h ****  *  - LIBUSB_LOG_LEVEL_DEBUG (4)   : debug and informational messages are printed to stdout,
1293:/usr/include/libusb-1.0/libusb.h ****  *    warnings and errors to stderr
1294:/usr/include/libusb-1.0/libusb.h ****  */
1295:/usr/include/libusb-1.0/libusb.h **** enum libusb_log_level {
1296:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_NONE = 0,
1297:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_ERROR,
1298:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_WARNING,
1299:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_INFO,
1300:/usr/include/libusb-1.0/libusb.h **** 	LIBUSB_LOG_LEVEL_DEBUG,
1301:/usr/include/libusb-1.0/libusb.h **** };
1302:/usr/include/libusb-1.0/libusb.h **** 
1303:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_init(libusb_context **ctx);
1304:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_exit(libusb_context *ctx);
1305:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_set_debug(libusb_context *ctx, int level);
1306:/usr/include/libusb-1.0/libusb.h **** const struct libusb_version * LIBUSB_CALL libusb_get_version(void);
1307:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_has_capability(uint32_t capability);
1308:/usr/include/libusb-1.0/libusb.h **** const char * LIBUSB_CALL libusb_error_name(int errcode);
1309:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_setlocale(const char *locale);
1310:/usr/include/libusb-1.0/libusb.h **** const char * LIBUSB_CALL libusb_strerror(enum libusb_error errcode);
1311:/usr/include/libusb-1.0/libusb.h **** 
1312:/usr/include/libusb-1.0/libusb.h **** ssize_t LIBUSB_CALL libusb_get_device_list(libusb_context *ctx,
1313:/usr/include/libusb-1.0/libusb.h **** 	libusb_device ***list);
1314:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_device_list(libusb_device **list,
1315:/usr/include/libusb-1.0/libusb.h **** 	int unref_devices);
1316:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_ref_device(libusb_device *dev);
1317:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_unref_device(libusb_device *dev);
1318:/usr/include/libusb-1.0/libusb.h **** 
1319:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_configuration(libusb_device_handle *dev,
1320:/usr/include/libusb-1.0/libusb.h **** 	int *config);
1321:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_device_descriptor(libusb_device *dev,
1322:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_device_descriptor *desc);
1323:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_active_config_descriptor(libusb_device *dev,
1324:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_config_descriptor **config);
1325:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_config_descriptor(libusb_device *dev,
1326:/usr/include/libusb-1.0/libusb.h **** 	uint8_t config_index, struct libusb_config_descriptor **config);
1327:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_config_descriptor_by_value(libusb_device *dev,
1328:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bConfigurationValue, struct libusb_config_descriptor **config);
1329:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_config_descriptor(
1330:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_config_descriptor *config);
1331:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_ss_endpoint_companion_descriptor(
1332:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_context *ctx,
1333:/usr/include/libusb-1.0/libusb.h **** 	const struct libusb_endpoint_descriptor *endpoint,
1334:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_endpoint_companion_descriptor **ep_comp);
1335:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_ss_endpoint_companion_descriptor(
1336:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_endpoint_companion_descriptor *ep_comp);
1337:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_bos_descriptor(libusb_device_handle *handle,
1338:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_descriptor **bos);
1339:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_bos_descriptor(struct libusb_bos_descriptor *bos);
1340:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_usb_2_0_extension_descriptor(
1341:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_context *ctx,
1342:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1343:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_usb_2_0_extension_descriptor **usb_2_0_extension);
1344:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_usb_2_0_extension_descriptor(
1345:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_usb_2_0_extension_descriptor *usb_2_0_extension);
1346:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_ss_usb_device_capability_descriptor(
1347:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_context *ctx,
1348:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1349:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_usb_device_capability_descriptor **ss_usb_device_cap);
1350:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_ss_usb_device_capability_descriptor(
1351:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_ss_usb_device_capability_descriptor *ss_usb_device_cap);
1352:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_container_id_descriptor(struct libusb_context *ctx,
1353:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_bos_dev_capability_descriptor *dev_cap,
1354:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_container_id_descriptor **container_id);
1355:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_container_id_descriptor(
1356:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_container_id_descriptor *container_id);
1357:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_bus_number(libusb_device *dev);
1358:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_port_number(libusb_device *dev);
1359:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_port_numbers(libusb_device *dev, uint8_t* port_numbers, int port_numbers
1360:/usr/include/libusb-1.0/libusb.h **** LIBUSB_DEPRECATED_FOR(libusb_get_port_numbers)
1361:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_port_path(libusb_context *ctx, libusb_device *dev, uint8_t* path, uint8_
1362:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_get_parent(libusb_device *dev);
1363:/usr/include/libusb-1.0/libusb.h **** uint8_t LIBUSB_CALL libusb_get_device_address(libusb_device *dev);
1364:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_device_speed(libusb_device *dev);
1365:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_max_packet_size(libusb_device *dev,
1366:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1367:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_get_max_iso_packet_size(libusb_device *dev,
1368:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1369:/usr/include/libusb-1.0/libusb.h **** 
1370:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_open(libusb_device *dev, libusb_device_handle **handle);
1371:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_close(libusb_device_handle *dev_handle);
1372:/usr/include/libusb-1.0/libusb.h **** libusb_device * LIBUSB_CALL libusb_get_device(libusb_device_handle *dev_handle);
1373:/usr/include/libusb-1.0/libusb.h **** 
1374:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_configuration(libusb_device_handle *dev,
1375:/usr/include/libusb-1.0/libusb.h **** 	int configuration);
1376:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_claim_interface(libusb_device_handle *dev,
1377:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1378:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_release_interface(libusb_device_handle *dev,
1379:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1380:/usr/include/libusb-1.0/libusb.h **** 
1381:/usr/include/libusb-1.0/libusb.h **** libusb_device_handle * LIBUSB_CALL libusb_open_device_with_vid_pid(
1382:/usr/include/libusb-1.0/libusb.h **** 	libusb_context *ctx, uint16_t vendor_id, uint16_t product_id);
1383:/usr/include/libusb-1.0/libusb.h **** 
1384:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_interface_alt_setting(libusb_device_handle *dev,
1385:/usr/include/libusb-1.0/libusb.h **** 	int interface_number, int alternate_setting);
1386:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_clear_halt(libusb_device_handle *dev,
1387:/usr/include/libusb-1.0/libusb.h **** 	unsigned char endpoint);
1388:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_reset_device(libusb_device_handle *dev);
1389:/usr/include/libusb-1.0/libusb.h **** 
1390:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_alloc_streams(libusb_device_handle *dev,
1391:/usr/include/libusb-1.0/libusb.h **** 	uint32_t num_streams, unsigned char *endpoints, int num_endpoints);
1392:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_free_streams(libusb_device_handle *dev,
1393:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *endpoints, int num_endpoints);
1394:/usr/include/libusb-1.0/libusb.h **** 
1395:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_kernel_driver_active(libusb_device_handle *dev,
1396:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1397:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_detach_kernel_driver(libusb_device_handle *dev,
1398:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1399:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_attach_kernel_driver(libusb_device_handle *dev,
1400:/usr/include/libusb-1.0/libusb.h **** 	int interface_number);
1401:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_set_auto_detach_kernel_driver(
1402:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev, int enable);
1403:/usr/include/libusb-1.0/libusb.h **** 
1404:/usr/include/libusb-1.0/libusb.h **** /* async I/O */
1405:/usr/include/libusb-1.0/libusb.h **** 
1406:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1407:/usr/include/libusb-1.0/libusb.h ****  * Get the data section of a control transfer. This convenience function is here
1408:/usr/include/libusb-1.0/libusb.h ****  * to remind you that the data does not start until 8 bytes into the actual
1409:/usr/include/libusb-1.0/libusb.h ****  * buffer, as the setup packet comes first.
1410:/usr/include/libusb-1.0/libusb.h ****  *
1411:/usr/include/libusb-1.0/libusb.h ****  * Calling this function only makes sense from a transfer callback function,
1412:/usr/include/libusb-1.0/libusb.h ****  * or situations where you have already allocated a suitably sized buffer at
1413:/usr/include/libusb-1.0/libusb.h ****  * transfer->buffer.
1414:/usr/include/libusb-1.0/libusb.h ****  *
1415:/usr/include/libusb-1.0/libusb.h ****  * \param transfer a transfer
1416:/usr/include/libusb-1.0/libusb.h ****  * \returns pointer to the first byte of the data section
1417:/usr/include/libusb-1.0/libusb.h ****  */
1418:/usr/include/libusb-1.0/libusb.h **** static inline unsigned char *libusb_control_transfer_get_data(
1419:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer)
1420:/usr/include/libusb-1.0/libusb.h **** {
1421:/usr/include/libusb-1.0/libusb.h **** 	return transfer->buffer + LIBUSB_CONTROL_SETUP_SIZE;
1422:/usr/include/libusb-1.0/libusb.h **** }
1423:/usr/include/libusb-1.0/libusb.h **** 
1424:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1425:/usr/include/libusb-1.0/libusb.h ****  * Get the control setup packet of a control transfer. This convenience
1426:/usr/include/libusb-1.0/libusb.h ****  * function is here to remind you that the control setup occupies the first
1427:/usr/include/libusb-1.0/libusb.h ****  * 8 bytes of the transfer data buffer.
1428:/usr/include/libusb-1.0/libusb.h ****  *
1429:/usr/include/libusb-1.0/libusb.h ****  * Calling this function only makes sense from a transfer callback function,
1430:/usr/include/libusb-1.0/libusb.h ****  * or situations where you have already allocated a suitably sized buffer at
1431:/usr/include/libusb-1.0/libusb.h ****  * transfer->buffer.
1432:/usr/include/libusb-1.0/libusb.h ****  *
1433:/usr/include/libusb-1.0/libusb.h ****  * \param transfer a transfer
1434:/usr/include/libusb-1.0/libusb.h ****  * \returns a casted pointer to the start of the transfer data buffer
1435:/usr/include/libusb-1.0/libusb.h ****  */
1436:/usr/include/libusb-1.0/libusb.h **** static inline struct libusb_control_setup *libusb_control_transfer_get_setup(
1437:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer)
1438:/usr/include/libusb-1.0/libusb.h **** {
1439:/usr/include/libusb-1.0/libusb.h **** 	return (struct libusb_control_setup *)(void *) transfer->buffer;
1440:/usr/include/libusb-1.0/libusb.h **** }
1441:/usr/include/libusb-1.0/libusb.h **** 
1442:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1443:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the setup packet (first 8 bytes of the data
1444:/usr/include/libusb-1.0/libusb.h ****  * buffer) for a control transfer. The wIndex, wValue and wLength values should
1445:/usr/include/libusb-1.0/libusb.h ****  * be given in host-endian byte order.
1446:/usr/include/libusb-1.0/libusb.h ****  *
1447:/usr/include/libusb-1.0/libusb.h ****  * \param buffer buffer to output the setup packet into
1448:/usr/include/libusb-1.0/libusb.h ****  * This pointer must be aligned to at least 2 bytes boundary.
1449:/usr/include/libusb-1.0/libusb.h ****  * \param bmRequestType see the
1450:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bmRequestType "bmRequestType" field of
1451:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1452:/usr/include/libusb-1.0/libusb.h ****  * \param bRequest see the
1453:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::bRequest "bRequest" field of
1454:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1455:/usr/include/libusb-1.0/libusb.h ****  * \param wValue see the
1456:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wValue "wValue" field of
1457:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1458:/usr/include/libusb-1.0/libusb.h ****  * \param wIndex see the
1459:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wIndex "wIndex" field of
1460:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1461:/usr/include/libusb-1.0/libusb.h ****  * \param wLength see the
1462:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup::wLength "wLength" field of
1463:/usr/include/libusb-1.0/libusb.h ****  * \ref libusb_control_setup
1464:/usr/include/libusb-1.0/libusb.h ****  */
1465:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_control_setup(unsigned char *buffer,
1466:/usr/include/libusb-1.0/libusb.h **** 	uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex,
1467:/usr/include/libusb-1.0/libusb.h **** 	uint16_t wLength)
1468:/usr/include/libusb-1.0/libusb.h **** {
1469:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_control_setup *setup = (struct libusb_control_setup *)(void *) buffer;
1470:/usr/include/libusb-1.0/libusb.h **** 	setup->bmRequestType = bmRequestType;
1471:/usr/include/libusb-1.0/libusb.h **** 	setup->bRequest = bRequest;
1472:/usr/include/libusb-1.0/libusb.h **** 	setup->wValue = libusb_cpu_to_le16(wValue);
1473:/usr/include/libusb-1.0/libusb.h **** 	setup->wIndex = libusb_cpu_to_le16(wIndex);
1474:/usr/include/libusb-1.0/libusb.h **** 	setup->wLength = libusb_cpu_to_le16(wLength);
1475:/usr/include/libusb-1.0/libusb.h **** }
1476:/usr/include/libusb-1.0/libusb.h **** 
1477:/usr/include/libusb-1.0/libusb.h **** struct libusb_transfer * LIBUSB_CALL libusb_alloc_transfer(int iso_packets);
1478:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_submit_transfer(struct libusb_transfer *transfer);
1479:/usr/include/libusb-1.0/libusb.h **** int LIBUSB_CALL libusb_cancel_transfer(struct libusb_transfer *transfer);
1480:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_free_transfer(struct libusb_transfer *transfer);
1481:/usr/include/libusb-1.0/libusb.h **** void LIBUSB_CALL libusb_transfer_set_stream_id(
1482:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer, uint32_t stream_id);
1483:/usr/include/libusb-1.0/libusb.h **** uint32_t LIBUSB_CALL libusb_transfer_get_stream_id(
1484:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer);
1485:/usr/include/libusb-1.0/libusb.h **** 
1486:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1487:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the required \ref libusb_transfer fields
1488:/usr/include/libusb-1.0/libusb.h ****  * for a control transfer.
1489:/usr/include/libusb-1.0/libusb.h ****  *
1490:/usr/include/libusb-1.0/libusb.h ****  * If you pass a transfer buffer to this function, the first 8 bytes will
1491:/usr/include/libusb-1.0/libusb.h ****  * be interpreted as a control setup packet, and the wLength field will be
1492:/usr/include/libusb-1.0/libusb.h ****  * used to automatically populate the \ref libusb_transfer::length "length"
1493:/usr/include/libusb-1.0/libusb.h ****  * field of the transfer. Therefore the recommended approach is:
1494:/usr/include/libusb-1.0/libusb.h ****  * -# Allocate a suitably sized data buffer (including space for control setup)
1495:/usr/include/libusb-1.0/libusb.h ****  * -# Call libusb_fill_control_setup()
1496:/usr/include/libusb-1.0/libusb.h ****  * -# If this is a host-to-device transfer with a data stage, put the data
1497:/usr/include/libusb-1.0/libusb.h ****  *    in place after the setup packet
1498:/usr/include/libusb-1.0/libusb.h ****  * -# Call this function
1499:/usr/include/libusb-1.0/libusb.h ****  * -# Call libusb_submit_transfer()
1500:/usr/include/libusb-1.0/libusb.h ****  *
1501:/usr/include/libusb-1.0/libusb.h ****  * It is also legal to pass a NULL buffer to this function, in which case this
1502:/usr/include/libusb-1.0/libusb.h ****  * function will not attempt to populate the length field. Remember that you
1503:/usr/include/libusb-1.0/libusb.h ****  * must then populate the buffer and length fields later.
1504:/usr/include/libusb-1.0/libusb.h ****  *
1505:/usr/include/libusb-1.0/libusb.h ****  * \param transfer the transfer to populate
1506:/usr/include/libusb-1.0/libusb.h ****  * \param dev_handle handle of the device that will handle the transfer
1507:/usr/include/libusb-1.0/libusb.h ****  * \param buffer data buffer. If provided, this function will interpret the
1508:/usr/include/libusb-1.0/libusb.h ****  * first 8 bytes as a setup packet and infer the transfer length from that.
1509:/usr/include/libusb-1.0/libusb.h ****  * This pointer must be aligned to at least 2 bytes boundary.
1510:/usr/include/libusb-1.0/libusb.h ****  * \param callback callback function to be invoked on transfer completion
1511:/usr/include/libusb-1.0/libusb.h ****  * \param user_data user data to pass to callback function
1512:/usr/include/libusb-1.0/libusb.h ****  * \param timeout timeout for the transfer in milliseconds
1513:/usr/include/libusb-1.0/libusb.h ****  */
1514:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_control_transfer(
1515:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_transfer *transfer, libusb_device_handle *dev_handle,
1516:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer, libusb_transfer_cb_fn callback, void *user_data,
1517:/usr/include/libusb-1.0/libusb.h **** 	unsigned int timeout)
1518:/usr/include/libusb-1.0/libusb.h **** {
1519:/usr/include/libusb-1.0/libusb.h **** 	struct libusb_control_setup *setup = (struct libusb_control_setup *)(void *) buffer;
1520:/usr/include/libusb-1.0/libusb.h **** 	transfer->dev_handle = dev_handle;
1521:/usr/include/libusb-1.0/libusb.h **** 	transfer->endpoint = 0;
1522:/usr/include/libusb-1.0/libusb.h **** 	transfer->type = LIBUSB_TRANSFER_TYPE_CONTROL;
1523:/usr/include/libusb-1.0/libusb.h **** 	transfer->timeout = timeout;
1524:/usr/include/libusb-1.0/libusb.h **** 	transfer->buffer = buffer;
1525:/usr/include/libusb-1.0/libusb.h **** 	if (setup)
1526:/usr/include/libusb-1.0/libusb.h **** 		transfer->length = (int) (LIBUSB_CONTROL_SETUP_SIZE
1527:/usr/include/libusb-1.0/libusb.h **** 			+ libusb_le16_to_cpu(setup->wLength));
1528:/usr/include/libusb-1.0/libusb.h **** 	transfer->user_data = user_data;
1529:/usr/include/libusb-1.0/libusb.h **** 	transfer->callback = callback;
1530:/usr/include/libusb-1.0/libusb.h **** }
1531:/usr/include/libusb-1.0/libusb.h **** 
1532:/usr/include/libusb-1.0/libusb.h **** /** \ingroup asyncio
1533:/usr/include/libusb-1.0/libusb.h ****  * Helper function to populate the required \ref libusb_transfer fields
1534:/usr/include/libusb-1.0/libusb.h ****  * for a bulk transfer.
1535:/usr/include/libusb-1.0/libusb.h ****  *
1536:/usr/include/libusb-1.0/libusb.h ****  * \param transfer the transfer to populate
1537:/usr/include/libusb-1.0/libusb.h ****  * \param dev_handle handle of the device that will handle the transfer
1538:/usr/include/libusb-1.0/libusb.h ****  * \param endpoint address of the endpoint where this transfer will be sent
1539:/usr/include/libusb-1.0/libusb.h ****  * \param buffer data buffer
1540:/usr/include/libusb-1.0/libusb.h ****  * \param length length of data buffer
1541:/usr/include/libusb-1.0/libusb.h ****  * \param callback callback function to be invoked on transfer completion
1542:/usr/include/libusb-1.0/libusb.h ****  * \param user_data user data to pass to callback function
1543:/usr/include/libusb-1.0/libusb.h ****  * \param timeout timeout for the transfer in milliseconds
1544:/usr/include/libusb-1.0/libusb.h ****  */
1545:/usr/include/libusb-1.0/libusb.h **** static inline void libusb_fill_bulk_transfer(struct libusb_transfer *transfer,
1546:/usr/include/libusb-1.0/libusb.h **** 	libusb_device_handle *dev_handle, unsigned char endpoint,
1547:/usr/include/libusb-1.0/libusb.h **** 	unsigned char *buffer, int length, libusb_transfer_cb_fn callback,
1548:/usr/include/libusb-1.0/libusb.h **** 	void *user_data, unsigned int timeout)
1549:/usr/include/libusb-1.0/libusb.h **** {
  30              		.loc 2 1549 0
  31              		.cfi_startproc
  32 0012 55       		pushq	%rbp
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 6, -16
  35 0013 4889E5   		movq	%rsp, %rbp
  36              		.cfi_def_cfa_register 6
  37 0016 48897DF8 		movq	%rdi, -8(%rbp)
  38 001a 488975F0 		movq	%rsi, -16(%rbp)
  39 001e 89D0     		movl	%edx, %eax
  40 0020 48894DE0 		movq	%rcx, -32(%rbp)
  41 0024 448945E8 		movl	%r8d, -24(%rbp)
  42 0028 4C894DD8 		movq	%r9, -40(%rbp)
  43 002c 8845EC   		movb	%al, -20(%rbp)
1550:/usr/include/libusb-1.0/libusb.h **** 	transfer->dev_handle = dev_handle;
  44              		.loc 2 1550 0
  45 002f 488B45F8 		movq	-8(%rbp), %rax
  46 0033 488B55F0 		movq	-16(%rbp), %rdx
  47 0037 488910   		movq	%rdx, (%rax)
1551:/usr/include/libusb-1.0/libusb.h **** 	transfer->endpoint = endpoint;
  48              		.loc 2 1551 0
  49 003a 488B45F8 		movq	-8(%rbp), %rax
  50 003e 0FB655EC 		movzbl	-20(%rbp), %edx
  51 0042 885009   		movb	%dl, 9(%rax)
1552:/usr/include/libusb-1.0/libusb.h **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
  52              		.loc 2 1552 0
  53 0045 488B45F8 		movq	-8(%rbp), %rax
  54 0049 C6400A02 		movb	$2, 10(%rax)
1553:/usr/include/libusb-1.0/libusb.h **** 	transfer->timeout = timeout;
  55              		.loc 2 1553 0
  56 004d 488B45F8 		movq	-8(%rbp), %rax
  57 0051 8B5518   		movl	24(%rbp), %edx
  58 0054 89500C   		movl	%edx, 12(%rax)
1554:/usr/include/libusb-1.0/libusb.h **** 	transfer->buffer = buffer;
  59              		.loc 2 1554 0
  60 0057 488B45F8 		movq	-8(%rbp), %rax
  61 005b 488B55E0 		movq	-32(%rbp), %rdx
  62 005f 48895030 		movq	%rdx, 48(%rax)
1555:/usr/include/libusb-1.0/libusb.h **** 	transfer->length = length;
  63              		.loc 2 1555 0
  64 0063 488B45F8 		movq	-8(%rbp), %rax
  65 0067 8B55E8   		movl	-24(%rbp), %edx
  66 006a 895014   		movl	%edx, 20(%rax)
1556:/usr/include/libusb-1.0/libusb.h **** 	transfer->user_data = user_data;
  67              		.loc 2 1556 0
  68 006d 488B45F8 		movq	-8(%rbp), %rax
  69 0071 488B5510 		movq	16(%rbp), %rdx
  70 0075 48895028 		movq	%rdx, 40(%rax)
1557:/usr/include/libusb-1.0/libusb.h **** 	transfer->callback = callback;
  71              		.loc 2 1557 0
  72 0079 488B45F8 		movq	-8(%rbp), %rax
  73 007d 488B55D8 		movq	-40(%rbp), %rdx
  74 0081 48895020 		movq	%rdx, 32(%rax)
1558:/usr/include/libusb-1.0/libusb.h **** }
  75              		.loc 2 1558 0
  76 0085 90       		nop
  77 0086 5D       		popq	%rbp
  78              		.cfi_def_cfa 7, 8
  79 0087 C3       		ret
  80              		.cfi_endproc
  81              	.LFE12:
  83              		.local	m_ctx
  84              		.comm	m_ctx,8,8
  85              		.section	.rodata
  86              	.LC0:
  87 0000 64657669 		.string	"device not found"
  87      6365206E 
  87      6F742066 
  87      6F756E64 
  87      00
  88              		.text
  90              	libusbOpenWithVidPid:
  91              	.LFB21:
  92              		.file 3 "libusbwrap.c"
   1:libusbwrap.c  **** /*
   2:libusbwrap.c  ****  * Copyright (C) 2009-2012 Chris McClelland
   3:libusbwrap.c  ****  *
   4:libusbwrap.c  ****  * This program is free software: you can redistribute it and/or modify
   5:libusbwrap.c  ****  * it under the terms of the GNU Lesser General Public License as published by
   6:libusbwrap.c  ****  * the Free Software Foundation, either version 3 of the License, or
   7:libusbwrap.c  ****  * (at your option) any later version.
   8:libusbwrap.c  ****  *
   9:libusbwrap.c  ****  * This program is distributed in the hope that it will be useful,
  10:libusbwrap.c  ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:libusbwrap.c  ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:libusbwrap.c  ****  * GNU Lesser General Public License for more details.
  13:libusbwrap.c  ****  *
  14:libusbwrap.c  ****  * You should have received a copy of the GNU Lesser General Public License
  15:libusbwrap.c  ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:libusbwrap.c  ****  */
  17:libusbwrap.c  **** #ifdef WIN32
  18:libusbwrap.c  **** #include <Windows.h>
  19:libusbwrap.c  **** #else
  20:libusbwrap.c  **** #define _BSD_SOURCE
  21:libusbwrap.c  **** #include <unistd.h>
  22:libusbwrap.c  **** #endif
  23:libusbwrap.c  **** #include <stdio.h>
  24:libusbwrap.c  **** #include <stdlib.h>
  25:libusbwrap.c  **** #include <string.h>
  26:libusbwrap.c  **** #include <makestuff.h>
  27:libusbwrap.c  **** #include <liberror.h>
  28:libusbwrap.c  **** #include "private.h"
  29:libusbwrap.c  **** 
  30:libusbwrap.c  **** static struct libusb_context *m_ctx = NULL;
  31:libusbwrap.c  **** 
  32:libusbwrap.c  **** // Modified from libusb_open_device_with_vid_pid in core.c of libusbx
  33:libusbwrap.c  **** //
  34:libusbwrap.c  **** static libusb_device_handle *libusbOpenWithVidPid(
  35:libusbwrap.c  **** 	libusb_context *ctx, uint16 vid, uint16 pid, uint16 did, const char **error)
  36:libusbwrap.c  **** {
  93              		.loc 3 36 0
  94              		.cfi_startproc
  95 0088 55       		pushq	%rbp
  96              		.cfi_def_cfa_offset 16
  97              		.cfi_offset 6, -16
  98 0089 4889E5   		movq	%rsp, %rbp
  99              		.cfi_def_cfa_register 6
 100 008c 4883EC70 		subq	$112, %rsp
 101 0090 48897DA8 		movq	%rdi, -88(%rbp)
 102 0094 89C8     		movl	%ecx, %eax
 103 0096 4C894590 		movq	%r8, -112(%rbp)
 104 009a 668975A4 		movw	%si, -92(%rbp)
 105 009e 668955A0 		movw	%dx, -96(%rbp)
 106 00a2 6689459C 		movw	%ax, -100(%rbp)
 107              		.loc 3 36 0
 108 00a6 64488B04 		movq	%fs:40, %rax
 108      25280000 
 108      00
 109 00af 488945F8 		movq	%rax, -8(%rbp)
 110 00b3 31C0     		xorl	%eax, %eax
  37:libusbwrap.c  **** 	libusb_device_handle *retVal = NULL;
 111              		.loc 3 37 0
 112 00b5 48C745B8 		movq	$0, -72(%rbp)
 112      00000000 
  38:libusbwrap.c  **** 	struct libusb_device **devs;
  39:libusbwrap.c  **** 	struct libusb_device *found = NULL;
 113              		.loc 3 39 0
 114 00bd 48C745C8 		movq	$0, -56(%rbp)
 114      00000000 
  40:libusbwrap.c  **** 	struct libusb_device *dev;
  41:libusbwrap.c  **** 	size_t i = 0;
 115              		.loc 3 41 0
 116 00c5 48C745D8 		movq	$0, -40(%rbp)
 116      00000000 
  42:libusbwrap.c  **** 	int status = (int)libusb_get_device_list(ctx, &devs);
 117              		.loc 3 42 0
 118 00cd 488D55C0 		leaq	-64(%rbp), %rdx
 119 00d1 488B45A8 		movq	-88(%rbp), %rax
 120 00d5 4889D6   		movq	%rdx, %rsi
 121 00d8 4889C7   		movq	%rax, %rdi
 122 00db E8000000 		call	libusb_get_device_list@PLT
 122      00
 123 00e0 8945B4   		movl	%eax, -76(%rbp)
  43:libusbwrap.c  **** 	CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 124              		.loc 3 43 0
 125 00e3 837DB400 		cmpl	$0, -76(%rbp)
 126 00e7 7929     		jns	.L5
 127              		.loc 3 43 0 is_stmt 0 discriminator 1
 128 00e9 8B45B4   		movl	-76(%rbp), %eax
 129 00ec 89C7     		movl	%eax, %edi
 130 00ee E8000000 		call	libusb_error_name@PLT
 130      00
 131 00f3 4889C2   		movq	%rax, %rdx
 132 00f6 488B4590 		movq	-112(%rbp), %rax
 133 00fa 4889D6   		movq	%rdx, %rsi
 134 00fd 4889C7   		movq	%rax, %rdi
 135 0100 E8000000 		call	errPrefix@PLT
 135      00
 136 0105 48C745B8 		movq	$0, -72(%rbp)
 136      00000000 
 137 010d E9210100 		jmp	.L6
 137      00
 138              	.L5:
  44:libusbwrap.c  **** 	dev = devs[i++];
 139              		.loc 3 44 0 is_stmt 1
 140 0112 488B4DC0 		movq	-64(%rbp), %rcx
 141 0116 488B45D8 		movq	-40(%rbp), %rax
 142 011a 488D5001 		leaq	1(%rax), %rdx
 143 011e 488955D8 		movq	%rdx, -40(%rbp)
 144 0122 48C1E003 		salq	$3, %rax
 145 0126 4801C8   		addq	%rcx, %rax
 146 0129 488B00   		movq	(%rax), %rax
 147 012c 488945D0 		movq	%rax, -48(%rbp)
  45:libusbwrap.c  **** 	while ( dev ) {
 148              		.loc 3 45 0
 149 0130 E9920000 		jmp	.L7
 149      00
 150              	.L12:
 151              	.LBB2:
  46:libusbwrap.c  **** 		struct libusb_device_descriptor desc;
  47:libusbwrap.c  **** 		status = libusb_get_device_descriptor(dev, &desc);
 152              		.loc 3 47 0
 153 0135 488D55E0 		leaq	-32(%rbp), %rdx
 154 0139 488B45D0 		movq	-48(%rbp), %rax
 155 013d 4889D6   		movq	%rdx, %rsi
 156 0140 4889C7   		movq	%rax, %rdi
 157 0143 E8000000 		call	libusb_get_device_descriptor@PLT
 157      00
 158 0148 8945B4   		movl	%eax, -76(%rbp)
  48:libusbwrap.c  **** 		CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 159              		.loc 3 48 0
 160 014b 837DB400 		cmpl	$0, -76(%rbp)
 161 014f 7929     		jns	.L8
 162              		.loc 3 48 0 is_stmt 0 discriminator 1
 163 0151 8B45B4   		movl	-76(%rbp), %eax
 164 0154 89C7     		movl	%eax, %edi
 165 0156 E8000000 		call	libusb_error_name@PLT
 165      00
 166 015b 4889C2   		movq	%rax, %rdx
 167 015e 488B4590 		movq	-112(%rbp), %rax
 168 0162 4889D6   		movq	%rdx, %rsi
 169 0165 4889C7   		movq	%rax, %rdi
 170 0168 E8000000 		call	errPrefix@PLT
 170      00
 171 016d 48C745B8 		movq	$0, -72(%rbp)
 171      00000000 
 172 0175 E9B90000 		jmp	.L6
 172      00
 173              	.L8:
  49:libusbwrap.c  **** 		if (
  50:libusbwrap.c  **** 			desc.idVendor == vid &&
 174              		.loc 3 50 0 is_stmt 1
 175 017a 0FB745E8 		movzwl	-24(%rbp), %eax
  49:libusbwrap.c  **** 		if (
 176              		.loc 3 49 0
 177 017e 663B45A4 		cmpw	-92(%rbp), %ax
 178 0182 7525     		jne	.L9
  51:libusbwrap.c  **** 			desc.idProduct == pid &&
 179              		.loc 3 51 0
 180 0184 0FB745EA 		movzwl	-22(%rbp), %eax
  50:libusbwrap.c  **** 			desc.idProduct == pid &&
 181              		.loc 3 50 0
 182 0188 663B45A0 		cmpw	-96(%rbp), %ax
 183 018c 751B     		jne	.L9
 184              		.loc 3 51 0
 185 018e 66837D9C 		cmpw	$0, -100(%rbp)
 185      00
 186 0193 740A     		je	.L10
  52:libusbwrap.c  **** 			(did == 0x0000 || desc.bcdDevice == did)
 187              		.loc 3 52 0
 188 0195 0FB745EC 		movzwl	-20(%rbp), %eax
 189 0199 663B459C 		cmpw	-100(%rbp), %ax
 190 019d 750A     		jne	.L9
 191              	.L10:
  53:libusbwrap.c  **** 		) {
  54:libusbwrap.c  **** 			found = dev;
 192              		.loc 3 54 0
 193 019f 488B45D0 		movq	-48(%rbp), %rax
 194 01a3 488945C8 		movq	%rax, -56(%rbp)
 195 01a7 EB29     		jmp	.L11
 196              	.L9:
  55:libusbwrap.c  **** 			break;
  56:libusbwrap.c  **** 		}
  57:libusbwrap.c  **** 		dev = devs[i++];
 197              		.loc 3 57 0
 198 01a9 488B4DC0 		movq	-64(%rbp), %rcx
 199 01ad 488B45D8 		movq	-40(%rbp), %rax
 200 01b1 488D5001 		leaq	1(%rax), %rdx
 201 01b5 488955D8 		movq	%rdx, -40(%rbp)
 202 01b9 48C1E003 		salq	$3, %rax
 203 01bd 4801C8   		addq	%rcx, %rax
 204 01c0 488B00   		movq	(%rax), %rax
 205 01c3 488945D0 		movq	%rax, -48(%rbp)
 206              	.L7:
 207              	.LBE2:
  45:libusbwrap.c  **** 		struct libusb_device_descriptor desc;
 208              		.loc 3 45 0
 209 01c7 48837DD0 		cmpq	$0, -48(%rbp)
 209      00
 210 01cc 0F8563FF 		jne	.L12
 210      FFFF
 211              	.L11:
  58:libusbwrap.c  **** 	}
  59:libusbwrap.c  **** 
  60:libusbwrap.c  **** 	if ( found ) {
 212              		.loc 3 60 0
 213 01d2 48837DC8 		cmpq	$0, -56(%rbp)
 213      00
 214 01d7 7442     		je	.L13
  61:libusbwrap.c  **** 		status = libusb_open(found, &retVal);
 215              		.loc 3 61 0
 216 01d9 488D55B8 		leaq	-72(%rbp), %rdx
 217 01dd 488B45C8 		movq	-56(%rbp), %rax
 218 01e1 4889D6   		movq	%rdx, %rsi
 219 01e4 4889C7   		movq	%rax, %rdi
 220 01e7 E8000000 		call	libusb_open@PLT
 220      00
 221 01ec 8945B4   		movl	%eax, -76(%rbp)
  62:libusbwrap.c  **** 		CHECK_STATUS(status < 0, NULL, cleanup, libusb_error_name(status));
 222              		.loc 3 62 0
 223 01ef 837DB400 		cmpl	$0, -76(%rbp)
 224 01f3 793E     		jns	.L6
 225              		.loc 3 62 0 is_stmt 0 discriminator 1
 226 01f5 8B45B4   		movl	-76(%rbp), %eax
 227 01f8 89C7     		movl	%eax, %edi
 228 01fa E8000000 		call	libusb_error_name@PLT
 228      00
 229 01ff 4889C2   		movq	%rax, %rdx
 230 0202 488B4590 		movq	-112(%rbp), %rax
 231 0206 4889D6   		movq	%rdx, %rsi
 232 0209 4889C7   		movq	%rax, %rdi
 233 020c E8000000 		call	errPrefix@PLT
 233      00
 234 0211 48C745B8 		movq	$0, -72(%rbp)
 234      00000000 
 235 0219 EB18     		jmp	.L6
 236              	.L13:
  63:libusbwrap.c  **** 	} else {
  64:libusbwrap.c  **** 		errRender(error, "device not found");
 237              		.loc 3 64 0 is_stmt 1
 238 021b 488B4590 		movq	-112(%rbp), %rax
 239 021f 488D3500 		leaq	.LC0(%rip), %rsi
 239      000000
 240 0226 4889C7   		movq	%rax, %rdi
 241 0229 B8000000 		movl	$0, %eax
 241      00
 242 022e E8000000 		call	errRender@PLT
 242      00
 243              	.L6:
  65:libusbwrap.c  **** 	}
  66:libusbwrap.c  **** 
  67:libusbwrap.c  **** cleanup:
  68:libusbwrap.c  **** 	libusb_free_device_list(devs, 1);
 244              		.loc 3 68 0
 245 0233 488B45C0 		movq	-64(%rbp), %rax
 246 0237 BE010000 		movl	$1, %esi
 246      00
 247 023c 4889C7   		movq	%rax, %rdi
 248 023f E8000000 		call	libusb_free_device_list@PLT
 248      00
  69:libusbwrap.c  **** 	return retVal;
 249              		.loc 3 69 0
 250 0244 488B45B8 		movq	-72(%rbp), %rax
  70:libusbwrap.c  **** }
 251              		.loc 3 70 0
 252 0248 488B4DF8 		movq	-8(%rbp), %rcx
 253 024c 6448330C 		xorq	%fs:40, %rcx
 253      25280000 
 253      00
 254 0255 7405     		je	.L15
 255 0257 E8000000 		call	__stack_chk_fail@PLT
 255      00
 256              	.L15:
 257 025c C9       		leave
 258              		.cfi_def_cfa 7, 8
 259 025d C3       		ret
 260              		.cfi_endproc
 261              	.LFE21:
 263              		.globl	usbValidateVidPid
 265              	usbValidateVidPid:
 266              	.LFB22:
  71:libusbwrap.c  **** 
  72:libusbwrap.c  **** // Return true if vp is VVVV:PPPP where V and P are hex digits:
  73:libusbwrap.c  **** //
  74:libusbwrap.c  **** DLLEXPORT(bool) usbValidateVidPid(const char *vp) {
 267              		.loc 3 74 0
 268              		.cfi_startproc
 269 025e 55       		pushq	%rbp
 270              		.cfi_def_cfa_offset 16
 271              		.cfi_offset 6, -16
 272 025f 4889E5   		movq	%rsp, %rbp
 273              		.cfi_def_cfa_register 6
 274 0262 4883EC20 		subq	$32, %rsp
 275 0266 48897DE8 		movq	%rdi, -24(%rbp)
  75:libusbwrap.c  **** 	int i;
  76:libusbwrap.c  **** 	char ch;
  77:libusbwrap.c  **** 	const size_t len = strlen(vp);
 276              		.loc 3 77 0
 277 026a 488B45E8 		movq	-24(%rbp), %rax
 278 026e 4889C7   		movq	%rax, %rdi
 279 0271 E8000000 		call	strlen@PLT
 279      00
 280 0276 488945F8 		movq	%rax, -8(%rbp)
  78:libusbwrap.c  **** 	bool hasDID;
  79:libusbwrap.c  **** 	if ( !vp ) {
 281              		.loc 3 79 0
 282 027a 48837DE8 		cmpq	$0, -24(%rbp)
 282      00
 283 027f 750A     		jne	.L17
  80:libusbwrap.c  **** 		return false;
 284              		.loc 3 80 0
 285 0281 B8000000 		movl	$0, %eax
 285      00
 286 0286 E9530100 		jmp	.L18
 286      00
 287              	.L17:
  81:libusbwrap.c  **** 	}
  82:libusbwrap.c  **** 	if ( len == 9 ) {
 288              		.loc 3 82 0
 289 028b 48837DF8 		cmpq	$9, -8(%rbp)
 289      09
 290 0290 7506     		jne	.L19
  83:libusbwrap.c  **** 		hasDID = false;
 291              		.loc 3 83 0
 292 0292 C645F200 		movb	$0, -14(%rbp)
 293 0296 EB17     		jmp	.L20
 294              	.L19:
  84:libusbwrap.c  **** 	} else if ( len == 14 ) {
 295              		.loc 3 84 0
 296 0298 48837DF8 		cmpq	$14, -8(%rbp)
 296      0E
 297 029d 7506     		jne	.L21
  85:libusbwrap.c  **** 		hasDID = true;
 298              		.loc 3 85 0
 299 029f C645F201 		movb	$1, -14(%rbp)
 300 02a3 EB0A     		jmp	.L20
 301              	.L21:
  86:libusbwrap.c  **** 	} else {
  87:libusbwrap.c  **** 		return false;
 302              		.loc 3 87 0
 303 02a5 B8000000 		movl	$0, %eax
 303      00
 304 02aa E92F0100 		jmp	.L18
 304      00
 305              	.L20:
  88:libusbwrap.c  **** 	}
  89:libusbwrap.c  **** 	if ( vp[4] != ':' || (hasDID && vp[9] != ':') ) {
 306              		.loc 3 89 0
 307 02af 488B45E8 		movq	-24(%rbp), %rax
 308 02b3 4883C004 		addq	$4, %rax
 309 02b7 0FB600   		movzbl	(%rax), %eax
 310 02ba 3C3A     		cmpb	$58, %al
 311 02bc 7515     		jne	.L22
 312              		.loc 3 89 0 is_stmt 0 discriminator 1
 313 02be 807DF200 		cmpb	$0, -14(%rbp)
 314 02c2 7419     		je	.L23
 315              		.loc 3 89 0 discriminator 2
 316 02c4 488B45E8 		movq	-24(%rbp), %rax
 317 02c8 4883C009 		addq	$9, %rax
 318 02cc 0FB600   		movzbl	(%rax), %eax
 319 02cf 3C3A     		cmpb	$58, %al
 320 02d1 740A     		je	.L23
 321              	.L22:
  90:libusbwrap.c  **** 		return false;
 322              		.loc 3 90 0 is_stmt 1
 323 02d3 B8000000 		movl	$0, %eax
 323      00
 324 02d8 E9010100 		jmp	.L18
 324      00
 325              	.L23:
  91:libusbwrap.c  **** 	}
  92:libusbwrap.c  **** 	for ( i = 0; i < 4; i++ ) {
 326              		.loc 3 92 0
 327 02dd C745F400 		movl	$0, -12(%rbp)
 327      000000
 328 02e4 EB45     		jmp	.L24
 329              	.L29:
  93:libusbwrap.c  **** 		ch = vp[i];
 330              		.loc 3 93 0
 331 02e6 8B45F4   		movl	-12(%rbp), %eax
 332 02e9 4863D0   		movslq	%eax, %rdx
 333 02ec 488B45E8 		movq	-24(%rbp), %rax
 334 02f0 4801D0   		addq	%rdx, %rax
 335 02f3 0FB600   		movzbl	(%rax), %eax
 336 02f6 8845F3   		movb	%al, -13(%rbp)
  94:libusbwrap.c  **** 		if (
 337              		.loc 3 94 0
 338 02f9 807DF32F 		cmpb	$47, -13(%rbp)
 339 02fd 7E1E     		jle	.L25
  95:libusbwrap.c  **** 			ch < '0' ||
 340              		.loc 3 95 0
 341 02ff 807DF339 		cmpb	$57, -13(%rbp)
 342 0303 7E06     		jle	.L26
  96:libusbwrap.c  **** 			(ch > '9' && ch < 'A') ||
 343              		.loc 3 96 0
 344 0305 807DF340 		cmpb	$64, -13(%rbp)
 345 0309 7E12     		jle	.L25
 346              	.L26:
 347              		.loc 3 96 0 is_stmt 0 discriminator 1
 348 030b 807DF346 		cmpb	$70, -13(%rbp)
 349 030f 7E06     		jle	.L27
  97:libusbwrap.c  **** 			(ch > 'F' && ch < 'a') ||
 350              		.loc 3 97 0 is_stmt 1
 351 0311 807DF360 		cmpb	$96, -13(%rbp)
 352 0315 7E06     		jle	.L25
 353              	.L27:
 354              		.loc 3 97 0 is_stmt 0 discriminator 1
 355 0317 807DF366 		cmpb	$102, -13(%rbp)
 356 031b 7E0A     		jle	.L28
 357              	.L25:
  98:libusbwrap.c  **** 			ch > 'f')
  99:libusbwrap.c  **** 		{
 100:libusbwrap.c  **** 			return false;
 358              		.loc 3 100 0 is_stmt 1
 359 031d B8000000 		movl	$0, %eax
 359      00
 360 0322 E9B70000 		jmp	.L18
 360      00
 361              	.L28:
  92:libusbwrap.c  **** 		ch = vp[i];
 362              		.loc 3 92 0 discriminator 2
 363 0327 8345F401 		addl	$1, -12(%rbp)
 364              	.L24:
  92:libusbwrap.c  **** 		ch = vp[i];
 365              		.loc 3 92 0 is_stmt 0 discriminator 1
 366 032b 837DF403 		cmpl	$3, -12(%rbp)
 367 032f 7EB5     		jle	.L29
 101:libusbwrap.c  **** 		}
 102:libusbwrap.c  **** 	}
 103:libusbwrap.c  **** 	for ( i = 5; i < 9; i++ ) {
 368              		.loc 3 103 0 is_stmt 1
 369 0331 C745F405 		movl	$5, -12(%rbp)
 369      000000
 370 0338 EB42     		jmp	.L30
 371              	.L35:
 104:libusbwrap.c  **** 		ch = vp[i];
 372              		.loc 3 104 0
 373 033a 8B45F4   		movl	-12(%rbp), %eax
 374 033d 4863D0   		movslq	%eax, %rdx
 375 0340 488B45E8 		movq	-24(%rbp), %rax
 376 0344 4801D0   		addq	%rdx, %rax
 377 0347 0FB600   		movzbl	(%rax), %eax
 378 034a 8845F3   		movb	%al, -13(%rbp)
 105:libusbwrap.c  **** 		if (
 379              		.loc 3 105 0
 380 034d 807DF32F 		cmpb	$47, -13(%rbp)
 381 0351 7E1E     		jle	.L31
 106:libusbwrap.c  **** 			ch < '0' ||
 382              		.loc 3 106 0
 383 0353 807DF339 		cmpb	$57, -13(%rbp)
 384 0357 7E06     		jle	.L32
 107:libusbwrap.c  **** 			(ch > '9' && ch < 'A') ||
 385              		.loc 3 107 0
 386 0359 807DF340 		cmpb	$64, -13(%rbp)
 387 035d 7E12     		jle	.L31
 388              	.L32:
 389              		.loc 3 107 0 is_stmt 0 discriminator 1
 390 035f 807DF346 		cmpb	$70, -13(%rbp)
 391 0363 7E06     		jle	.L33
 108:libusbwrap.c  **** 			(ch > 'F' && ch < 'a') ||
 392              		.loc 3 108 0 is_stmt 1
 393 0365 807DF360 		cmpb	$96, -13(%rbp)
 394 0369 7E06     		jle	.L31
 395              	.L33:
 396              		.loc 3 108 0 is_stmt 0 discriminator 1
 397 036b 807DF366 		cmpb	$102, -13(%rbp)
 398 036f 7E07     		jle	.L34
 399              	.L31:
 109:libusbwrap.c  **** 			ch > 'f')
 110:libusbwrap.c  **** 		{
 111:libusbwrap.c  **** 			return false;
 400              		.loc 3 111 0 is_stmt 1
 401 0371 B8000000 		movl	$0, %eax
 401      00
 402 0376 EB66     		jmp	.L18
 403              	.L34:
 103:libusbwrap.c  **** 		ch = vp[i];
 404              		.loc 3 103 0 discriminator 2
 405 0378 8345F401 		addl	$1, -12(%rbp)
 406              	.L30:
 103:libusbwrap.c  **** 		ch = vp[i];
 407              		.loc 3 103 0 is_stmt 0 discriminator 1
 408 037c 837DF408 		cmpl	$8, -12(%rbp)
 409 0380 7EB8     		jle	.L35
 112:libusbwrap.c  **** 		}
 113:libusbwrap.c  **** 	}
 114:libusbwrap.c  **** 	if ( hasDID ) {
 410              		.loc 3 114 0 is_stmt 1
 411 0382 807DF200 		cmpb	$0, -14(%rbp)
 412 0386 7451     		je	.L36
 115:libusbwrap.c  **** 		for ( i = 10; i < 14; i++ ) {
 413              		.loc 3 115 0
 414 0388 C745F40A 		movl	$10, -12(%rbp)
 414      000000
 415 038f EB42     		jmp	.L37
 416              	.L42:
 116:libusbwrap.c  **** 			ch = vp[i];
 417              		.loc 3 116 0
 418 0391 8B45F4   		movl	-12(%rbp), %eax
 419 0394 4863D0   		movslq	%eax, %rdx
 420 0397 488B45E8 		movq	-24(%rbp), %rax
 421 039b 4801D0   		addq	%rdx, %rax
 422 039e 0FB600   		movzbl	(%rax), %eax
 423 03a1 8845F3   		movb	%al, -13(%rbp)
 117:libusbwrap.c  **** 			if (
 424              		.loc 3 117 0
 425 03a4 807DF32F 		cmpb	$47, -13(%rbp)
 426 03a8 7E1E     		jle	.L38
 118:libusbwrap.c  **** 				ch < '0' ||
 427              		.loc 3 118 0
 428 03aa 807DF339 		cmpb	$57, -13(%rbp)
 429 03ae 7E06     		jle	.L39
 119:libusbwrap.c  **** 				(ch > '9' && ch < 'A') ||
 430              		.loc 3 119 0
 431 03b0 807DF340 		cmpb	$64, -13(%rbp)
 432 03b4 7E12     		jle	.L38
 433              	.L39:
 434              		.loc 3 119 0 is_stmt 0 discriminator 1
 435 03b6 807DF346 		cmpb	$70, -13(%rbp)
 436 03ba 7E06     		jle	.L40
 120:libusbwrap.c  **** 				(ch > 'F' && ch < 'a') ||
 437              		.loc 3 120 0 is_stmt 1
 438 03bc 807DF360 		cmpb	$96, -13(%rbp)
 439 03c0 7E06     		jle	.L38
 440              	.L40:
 441              		.loc 3 120 0 is_stmt 0 discriminator 1
 442 03c2 807DF366 		cmpb	$102, -13(%rbp)
 443 03c6 7E07     		jle	.L41
 444              	.L38:
 121:libusbwrap.c  **** 				ch > 'f')
 122:libusbwrap.c  **** 			{
 123:libusbwrap.c  **** 				return false;
 445              		.loc 3 123 0 is_stmt 1
 446 03c8 B8000000 		movl	$0, %eax
 446      00
 447 03cd EB0F     		jmp	.L18
 448              	.L41:
 115:libusbwrap.c  **** 			ch = vp[i];
 449              		.loc 3 115 0 discriminator 2
 450 03cf 8345F401 		addl	$1, -12(%rbp)
 451              	.L37:
 115:libusbwrap.c  **** 			ch = vp[i];
 452              		.loc 3 115 0 is_stmt 0 discriminator 1
 453 03d3 837DF40D 		cmpl	$13, -12(%rbp)
 454 03d7 7EB8     		jle	.L42
 455              	.L36:
 124:libusbwrap.c  **** 			}
 125:libusbwrap.c  **** 		}
 126:libusbwrap.c  **** 	}
 127:libusbwrap.c  **** 	return true;
 456              		.loc 3 127 0 is_stmt 1
 457 03d9 B8010000 		movl	$1, %eax
 457      00
 458              	.L18:
 128:libusbwrap.c  **** }
 459              		.loc 3 128 0
 460 03de C9       		leave
 461              		.cfi_def_cfa 7, 8
 462 03df C3       		ret
 463              		.cfi_endproc
 464              	.LFE22:
 466              		.section	.rodata
 467              	.LC1:
 468 0011 75736249 		.string	"usbInitialise(): %s"
 468      6E697469 
 468      616C6973 
 468      6528293A 
 468      20257300 
 469              		.text
 470              		.globl	usbInitialise
 472              	usbInitialise:
 473              	.LFB23:
 129:libusbwrap.c  **** 
 130:libusbwrap.c  **** // Initialise LibUSB with the given log level.
 131:libusbwrap.c  **** //
 132:libusbwrap.c  **** DLLEXPORT(USBStatus) usbInitialise(int debugLevel, const char **error) {
 474              		.loc 3 132 0
 475              		.cfi_startproc
 476 03e0 55       		pushq	%rbp
 477              		.cfi_def_cfa_offset 16
 478              		.cfi_offset 6, -16
 479 03e1 4889E5   		movq	%rsp, %rbp
 480              		.cfi_def_cfa_register 6
 481 03e4 4883EC20 		subq	$32, %rsp
 482 03e8 897DEC   		movl	%edi, -20(%rbp)
 483 03eb 488975E0 		movq	%rsi, -32(%rbp)
 133:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 484              		.loc 3 133 0
 485 03ef C745F800 		movl	$0, -8(%rbp)
 485      000000
 134:libusbwrap.c  **** 	int status = libusb_init(&m_ctx);
 486              		.loc 3 134 0
 487 03f6 488D3D00 		leaq	m_ctx(%rip), %rdi
 487      000000
 488 03fd E8000000 		call	libusb_init@PLT
 488      00
 489 0402 8945FC   		movl	%eax, -4(%rbp)
 135:libusbwrap.c  **** 	CHECK_STATUS(status, USB_INIT, cleanup, "usbInitialise(): %s", libusb_error_name(status));
 490              		.loc 3 135 0
 491 0405 837DFC00 		cmpl	$0, -4(%rbp)
 492 0409 742E     		je	.L44
 493              		.loc 3 135 0 is_stmt 0 discriminator 1
 494 040b 8B45FC   		movl	-4(%rbp), %eax
 495 040e 89C7     		movl	%eax, %edi
 496 0410 E8000000 		call	libusb_error_name@PLT
 496      00
 497 0415 4889C2   		movq	%rax, %rdx
 498 0418 488B45E0 		movq	-32(%rbp), %rax
 499 041c 488D3500 		leaq	.LC1(%rip), %rsi
 499      000000
 500 0423 4889C7   		movq	%rax, %rdi
 501 0426 B8000000 		movl	$0, %eax
 501      00
 502 042b E8000000 		call	errRender@PLT
 502      00
 503 0430 C745F802 		movl	$2, -8(%rbp)
 503      000000
 504 0437 EB14     		jmp	.L45
 505              	.L44:
 136:libusbwrap.c  **** 	libusb_set_debug(m_ctx, debugLevel);
 506              		.loc 3 136 0 is_stmt 1
 507 0439 488B0500 		movq	m_ctx(%rip), %rax
 507      000000
 508 0440 8B55EC   		movl	-20(%rbp), %edx
 509 0443 89D6     		movl	%edx, %esi
 510 0445 4889C7   		movq	%rax, %rdi
 511 0448 E8000000 		call	libusb_set_debug@PLT
 511      00
 512              	.L45:
 137:libusbwrap.c  **** cleanup:
 138:libusbwrap.c  **** 	return retVal;
 513              		.loc 3 138 0
 514 044d 8B45F8   		movl	-8(%rbp), %eax
 139:libusbwrap.c  **** }
 515              		.loc 3 139 0
 516 0450 C9       		leave
 517              		.cfi_def_cfa 7, 8
 518 0451 C3       		ret
 519              		.cfi_endproc
 520              	.LFE23:
 522              		.section	.rodata
 523 0025 000000   		.align 8
 524              	.LC2:
 525 0028 75736249 		.string	"usbIsDeviceAvailable(): you forgot to call usbInitialise()!"
 525      73446576 
 525      69636541 
 525      7661696C 
 525      61626C65 
 526              	.LC3:
 527 0064 75736249 		.string	"usbIsDeviceAvailable(): %s"
 527      73446576 
 527      69636541 
 527      7661696C 
 527      61626C65 
 528 007f 00       		.align 8
 529              	.LC4:
 530 0080 75736249 		.string	"usbIsDeviceAvailable(): The supplied VID:PID:DID \"%s\" is invalid; it should look like 1
 530      73446576 
 530      69636541 
 530      7661696C 
 530      61626C65 
 531              		.text
 532              		.globl	usbIsDeviceAvailable
 534              	usbIsDeviceAvailable:
 535              	.LFB24:
 140:libusbwrap.c  **** 
 141:libusbwrap.c  **** #define isMatching (thisDevice->descriptor.idVendor == vid && thisDevice->descriptor.idProduct == p
 142:libusbwrap.c  **** 
 143:libusbwrap.c  **** #define FORMAT_ERR "The supplied VID:PID:DID \"%s\" is invalid; it should look like 1D50:602B or 1D
 144:libusbwrap.c  **** 
 145:libusbwrap.c  **** // Find the descriptor of the first occurance of the specified device
 146:libusbwrap.c  **** //
 147:libusbwrap.c  **** DLLEXPORT(USBStatus) usbIsDeviceAvailable(const char *vp, bool *isAvailable, const char **error) {
 536              		.loc 3 147 0
 537              		.cfi_startproc
 538 0452 55       		pushq	%rbp
 539              		.cfi_def_cfa_offset 16
 540              		.cfi_offset 6, -16
 541 0453 4889E5   		movq	%rsp, %rbp
 542              		.cfi_def_cfa_register 6
 543 0456 4883EC70 		subq	$112, %rsp
 544 045a 48897DA8 		movq	%rdi, -88(%rbp)
 545 045e 488975A0 		movq	%rsi, -96(%rbp)
 546 0462 48895598 		movq	%rdx, -104(%rbp)
 547              		.loc 3 147 0
 548 0466 64488B04 		movq	%fs:40, %rax
 548      25280000 
 548      00
 549 046f 488945F8 		movq	%rax, -8(%rbp)
 550 0473 31C0     		xorl	%eax, %eax
 148:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 551              		.loc 3 148 0
 552 0475 C745C400 		movl	$0, -60(%rbp)
 552      000000
 149:libusbwrap.c  **** 	struct libusb_device **devList = NULL;
 553              		.loc 3 149 0
 554 047c 48C745D0 		movq	$0, -48(%rbp)
 554      00000000 
 150:libusbwrap.c  **** 	struct libusb_device *thisDev;
 151:libusbwrap.c  **** 	struct libusb_device_descriptor desc;
 152:libusbwrap.c  **** 	uint16 vid, pid, did;
 153:libusbwrap.c  **** 	int status, count;
 154:libusbwrap.c  **** 	CHECK_STATUS(
 555              		.loc 3 154 0
 556 0484 488B0500 		movq	m_ctx(%rip), %rax
 556      000000
 557 048b 4885C0   		testq	%rax, %rax
 558 048e 751F     		jne	.L48
 559              		.loc 3 154 0 is_stmt 0 discriminator 1
 560 0490 488B4598 		movq	-104(%rbp), %rax
 561 0494 488D3500 		leaq	.LC2(%rip), %rsi
 561      000000
 562 049b 4889C7   		movq	%rax, %rdi
 563 049e E8000000 		call	errPrefix@PLT
 563      00
 564 04a3 C745C402 		movl	$2, -60(%rbp)
 564      000000
 565 04aa E9A70100 		jmp	.L49
 565      00
 566              	.L48:
 155:libusbwrap.c  **** 		!m_ctx, USB_INIT, cleanup,
 156:libusbwrap.c  **** 		"usbIsDeviceAvailable(): you forgot to call usbInitialise()!");
 157:libusbwrap.c  **** 	count = (int)libusb_get_device_list(m_ctx, &devList);
 567              		.loc 3 157 0 is_stmt 1
 568 04af 488B0500 		movq	m_ctx(%rip), %rax
 568      000000
 569 04b6 488D55D0 		leaq	-48(%rbp), %rdx
 570 04ba 4889D6   		movq	%rdx, %rsi
 571 04bd 4889C7   		movq	%rax, %rdi
 572 04c0 E8000000 		call	libusb_get_device_list@PLT
 572      00
 573 04c5 8945C8   		movl	%eax, -56(%rbp)
 158:libusbwrap.c  **** 	CHECK_STATUS(
 574              		.loc 3 158 0
 575 04c8 837DC800 		cmpl	$0, -56(%rbp)
 576 04cc 7931     		jns	.L50
 577              		.loc 3 158 0 is_stmt 0 discriminator 1
 578 04ce 8B45C8   		movl	-56(%rbp), %eax
 579 04d1 89C7     		movl	%eax, %edi
 580 04d3 E8000000 		call	libusb_error_name@PLT
 580      00
 581 04d8 4889C2   		movq	%rax, %rdx
 582 04db 488B4598 		movq	-104(%rbp), %rax
 583 04df 488D3500 		leaq	.LC3(%rip), %rsi
 583      000000
 584 04e6 4889C7   		movq	%rax, %rdi
 585 04e9 B8000000 		movl	$0, %eax
 585      00
 586 04ee E8000000 		call	errRender@PLT
 586      00
 587 04f3 C745C405 		movl	$5, -60(%rbp)
 587      000000
 588 04fa E9570100 		jmp	.L49
 588      00
 589              	.L50:
 159:libusbwrap.c  **** 		count < 0, USB_CANNOT_OPEN_DEVICE, cleanup,
 160:libusbwrap.c  **** 		"usbIsDeviceAvailable(): %s", libusb_error_name(count));
 161:libusbwrap.c  **** 	CHECK_STATUS(
 590              		.loc 3 161 0 is_stmt 1
 591 04ff 488B45A8 		movq	-88(%rbp), %rax
 592 0503 4889C7   		movq	%rax, %rdi
 593 0506 E8000000 		call	usbValidateVidPid@PLT
 593      00
 594 050b 83F001   		xorl	$1, %eax
 595 050e 84C0     		testb	%al, %al
 596 0510 7428     		je	.L51
 597              		.loc 3 161 0 is_stmt 0 discriminator 1
 598 0512 488B55A8 		movq	-88(%rbp), %rdx
 599 0516 488B4598 		movq	-104(%rbp), %rax
 600 051a 488D3500 		leaq	.LC4(%rip), %rsi
 600      000000
 601 0521 4889C7   		movq	%rax, %rdi
 602 0524 B8000000 		movl	$0, %eax
 602      00
 603 0529 E8000000 		call	errRender@PLT
 603      00
 604 052e C745C401 		movl	$1, -60(%rbp)
 604      000000
 605 0535 E91C0100 		jmp	.L49
 605      00
 606              	.L51:
 162:libusbwrap.c  **** 		!usbValidateVidPid(vp), USB_INVALID_VIDPID, cleanup,
 163:libusbwrap.c  **** 		"usbIsDeviceAvailable(): "FORMAT_ERR, vp);
 164:libusbwrap.c  **** 	vid = (uint16)strtoul(vp, NULL, 16);
 607              		.loc 3 164 0 is_stmt 1
 608 053a 488B45A8 		movq	-88(%rbp), %rax
 609 053e BA100000 		movl	$16, %edx
 609      00
 610 0543 BE000000 		movl	$0, %esi
 610      00
 611 0548 4889C7   		movq	%rax, %rdi
 612 054b E8000000 		call	strtoul@PLT
 612      00
 613 0550 668945BE 		movw	%ax, -66(%rbp)
 165:libusbwrap.c  **** 	pid = (uint16)strtoul(vp+5, NULL, 16);
 614              		.loc 3 165 0
 615 0554 488B45A8 		movq	-88(%rbp), %rax
 616 0558 4883C005 		addq	$5, %rax
 617 055c BA100000 		movl	$16, %edx
 617      00
 618 0561 BE000000 		movl	$0, %esi
 618      00
 619 0566 4889C7   		movq	%rax, %rdi
 620 0569 E8000000 		call	strtoul@PLT
 620      00
 621 056e 668945C0 		movw	%ax, -64(%rbp)
 166:libusbwrap.c  **** 	did = (uint16)((strlen(vp) == 14) ? strtoul(vp+10, NULL, 16) : 0x0000);
 622              		.loc 3 166 0
 623 0572 488B45A8 		movq	-88(%rbp), %rax
 624 0576 4889C7   		movq	%rax, %rdi
 625 0579 E8000000 		call	strlen@PLT
 625      00
 626 057e 4883F80E 		cmpq	$14, %rax
 627 0582 751C     		jne	.L52
 628              		.loc 3 166 0 is_stmt 0 discriminator 1
 629 0584 488B45A8 		movq	-88(%rbp), %rax
 630 0588 4883C00A 		addq	$10, %rax
 631 058c BA100000 		movl	$16, %edx
 631      00
 632 0591 BE000000 		movl	$0, %esi
 632      00
 633 0596 4889C7   		movq	%rax, %rdi
 634 0599 E8000000 		call	strtoul@PLT
 634      00
 635 059e EB05     		jmp	.L53
 636              	.L52:
 637              		.loc 3 166 0 discriminator 2
 638 05a0 B8000000 		movl	$0, %eax
 638      00
 639              	.L53:
 640              		.loc 3 166 0 discriminator 4
 641 05a5 668945C2 		movw	%ax, -62(%rbp)
 167:libusbwrap.c  **** 	*isAvailable = false;
 642              		.loc 3 167 0 is_stmt 1 discriminator 4
 643 05a9 488B45A0 		movq	-96(%rbp), %rax
 644 05ad C60000   		movb	$0, (%rax)
 168:libusbwrap.c  **** 	while ( count-- ) {
 645              		.loc 3 168 0 discriminator 4
 646 05b0 E9900000 		jmp	.L54
 646      00
 647              	.L57:
 169:libusbwrap.c  **** 		thisDev = devList[count];
 648              		.loc 3 169 0
 649 05b5 488B45D0 		movq	-48(%rbp), %rax
 650 05b9 8B55C8   		movl	-56(%rbp), %edx
 651 05bc 4863D2   		movslq	%edx, %rdx
 652 05bf 48C1E203 		salq	$3, %rdx
 653 05c3 4801D0   		addq	%rdx, %rax
 654 05c6 488B00   		movq	(%rax), %rax
 655 05c9 488945D8 		movq	%rax, -40(%rbp)
 170:libusbwrap.c  **** 		status = libusb_get_device_descriptor(thisDev, &desc);
 656              		.loc 3 170 0
 657 05cd 488D55E0 		leaq	-32(%rbp), %rdx
 658 05d1 488B45D8 		movq	-40(%rbp), %rax
 659 05d5 4889D6   		movq	%rdx, %rsi
 660 05d8 4889C7   		movq	%rax, %rdi
 661 05db E8000000 		call	libusb_get_device_descriptor@PLT
 661      00
 662 05e0 8945CC   		movl	%eax, -52(%rbp)
 171:libusbwrap.c  **** 		CHECK_STATUS(
 663              		.loc 3 171 0
 664 05e3 837DCC00 		cmpl	$0, -52(%rbp)
 665 05e7 742E     		je	.L55
 666              		.loc 3 171 0 is_stmt 0 discriminator 1
 667 05e9 8B45CC   		movl	-52(%rbp), %eax
 668 05ec 89C7     		movl	%eax, %edi
 669 05ee E8000000 		call	libusb_error_name@PLT
 669      00
 670 05f3 4889C2   		movq	%rax, %rdx
 671 05f6 488B4598 		movq	-104(%rbp), %rax
 672 05fa 488D3500 		leaq	.LC3(%rip), %rsi
 672      000000
 673 0601 4889C7   		movq	%rax, %rdi
 674 0604 B8000000 		movl	$0, %eax
 674      00
 675 0609 E8000000 		call	errRender@PLT
 675      00
 676 060e C745C409 		movl	$9, -60(%rbp)
 676      000000
 677 0615 EB3F     		jmp	.L49
 678              	.L55:
 172:libusbwrap.c  **** 			status, USB_CANNOT_GET_DESCRIPTOR, cleanup,
 173:libusbwrap.c  **** 			"usbIsDeviceAvailable(): %s", libusb_error_name(status));
 174:libusbwrap.c  **** 		if (
 175:libusbwrap.c  **** 			desc.idVendor == vid &&
 679              		.loc 3 175 0 is_stmt 1
 680 0617 0FB745E8 		movzwl	-24(%rbp), %eax
 174:libusbwrap.c  **** 			desc.idVendor == vid &&
 681              		.loc 3 174 0
 682 061b 663B45BE 		cmpw	-66(%rbp), %ax
 683 061f 7524     		jne	.L54
 176:libusbwrap.c  **** 			desc.idProduct == pid &&
 684              		.loc 3 176 0
 685 0621 0FB745EA 		movzwl	-22(%rbp), %eax
 175:libusbwrap.c  **** 			desc.idProduct == pid &&
 686              		.loc 3 175 0
 687 0625 663B45C0 		cmpw	-64(%rbp), %ax
 688 0629 751A     		jne	.L54
 689              		.loc 3 176 0
 690 062b 66837DC2 		cmpw	$0, -62(%rbp)
 690      00
 691 0630 740A     		je	.L56
 177:libusbwrap.c  **** 			(did == 0x0000 || desc.bcdDevice == did)
 692              		.loc 3 177 0
 693 0632 0FB745EC 		movzwl	-20(%rbp), %eax
 694 0636 663B45C2 		cmpw	-62(%rbp), %ax
 695 063a 7509     		jne	.L54
 696              	.L56:
 178:libusbwrap.c  **** 		) {
 179:libusbwrap.c  **** 			*isAvailable = true;
 697              		.loc 3 179 0
 698 063c 488B45A0 		movq	-96(%rbp), %rax
 699 0640 C60001   		movb	$1, (%rax)
 180:libusbwrap.c  **** 			break;
 700              		.loc 3 180 0
 701 0643 EB11     		jmp	.L49
 702              	.L54:
 168:libusbwrap.c  **** 		thisDev = devList[count];
 703              		.loc 3 168 0
 704 0645 8B45C8   		movl	-56(%rbp), %eax
 705 0648 8D50FF   		leal	-1(%rax), %edx
 706 064b 8955C8   		movl	%edx, -56(%rbp)
 707 064e 85C0     		testl	%eax, %eax
 708 0650 0F855FFF 		jne	.L57
 708      FFFF
 709              	.L49:
 181:libusbwrap.c  **** 		}
 182:libusbwrap.c  **** 	}
 183:libusbwrap.c  **** cleanup:
 184:libusbwrap.c  **** 	libusb_free_device_list(devList, 1);
 710              		.loc 3 184 0
 711 0656 488B45D0 		movq	-48(%rbp), %rax
 712 065a BE010000 		movl	$1, %esi
 712      00
 713 065f 4889C7   		movq	%rax, %rdi
 714 0662 E8000000 		call	libusb_free_device_list@PLT
 714      00
 185:libusbwrap.c  **** 	return retVal;
 715              		.loc 3 185 0
 716 0667 8B45C4   		movl	-60(%rbp), %eax
 186:libusbwrap.c  **** }
 717              		.loc 3 186 0
 718 066a 488B4DF8 		movq	-8(%rbp), %rcx
 719 066e 6448330C 		xorq	%fs:40, %rcx
 719      25280000 
 719      00
 720 0677 7405     		je	.L59
 721 0679 E8000000 		call	__stack_chk_fail@PLT
 721      00
 722              	.L59:
 723 067e C9       		leave
 724              		.cfi_def_cfa 7, 8
 725 067f C3       		ret
 726              		.cfi_endproc
 727              	.LFE24:
 729              		.globl	createTransfer
 731              	createTransfer:
 732              	.LFB25:
 187:libusbwrap.c  **** 
 188:libusbwrap.c  **** struct TransferWrapper {
 189:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 190:libusbwrap.c  **** 	int completed;
 191:libusbwrap.c  **** 	struct AsyncTransferFlags flags;
 192:libusbwrap.c  **** 	uint8 buffer[0x10000];  // can use this...
 193:libusbwrap.c  **** 	uint8 *bufPtr;          // ...or this.
 194:libusbwrap.c  **** };
 195:libusbwrap.c  **** struct TransferWrapper *createTransfer(void) {
 733              		.loc 3 195 0
 734              		.cfi_startproc
 735 0680 55       		pushq	%rbp
 736              		.cfi_def_cfa_offset 16
 737              		.cfi_offset 6, -16
 738 0681 4889E5   		movq	%rsp, %rbp
 739              		.cfi_def_cfa_register 6
 740 0684 4883EC10 		subq	$16, %rsp
 196:libusbwrap.c  **** 	struct TransferWrapper *retVal = (struct TransferWrapper *)calloc(1, sizeof(struct TransferWrapper
 741              		.loc 3 196 0
 742 0688 BE180001 		movl	$65560, %esi
 742      00
 743 068d BF010000 		movl	$1, %edi
 743      00
 744 0692 E8000000 		call	calloc@PLT
 744      00
 745 0697 488945F8 		movq	%rax, -8(%rbp)
 197:libusbwrap.c  **** 	CHECK_STATUS(retVal == NULL, NULL, exit);
 746              		.loc 3 197 0
 747 069b 48837DF8 		cmpq	$0, -8(%rbp)
 747      00
 748 06a0 750A     		jne	.L61
 749              		.loc 3 197 0 is_stmt 0 discriminator 1
 750 06a2 48C745F8 		movq	$0, -8(%rbp)
 750      00000000 
 751 06aa EB3D     		jmp	.L62
 752              	.L61:
 198:libusbwrap.c  **** 	retVal->transfer = libusb_alloc_transfer(0);
 753              		.loc 3 198 0 is_stmt 1
 754 06ac BF000000 		movl	$0, %edi
 754      00
 755 06b1 E8000000 		call	libusb_alloc_transfer@PLT
 755      00
 756 06b6 4889C2   		movq	%rax, %rdx
 757 06b9 488B45F8 		movq	-8(%rbp), %rax
 758 06bd 488910   		movq	%rdx, (%rax)
 199:libusbwrap.c  **** 	CHECK_STATUS(retVal->transfer == NULL, NULL, freeWrap);
 759              		.loc 3 199 0
 760 06c0 488B45F8 		movq	-8(%rbp), %rax
 761 06c4 488B00   		movq	(%rax), %rax
 762 06c7 4885C0   		testq	%rax, %rax
 763 06ca 7517     		jne	.L63
 764              		.loc 3 199 0 is_stmt 0 discriminator 1
 765 06cc 48C745F8 		movq	$0, -8(%rbp)
 765      00000000 
 766 06d4 90       		nop
 767              	.L64:
 200:libusbwrap.c  **** 	return retVal;
 201:libusbwrap.c  **** freeWrap:
 202:libusbwrap.c  **** 	free((void*)retVal);
 768              		.loc 3 202 0 is_stmt 1 discriminator 1
 769 06d5 488B45F8 		movq	-8(%rbp), %rax
 770 06d9 4889C7   		movq	%rax, %rdi
 771 06dc E8000000 		call	free@PLT
 771      00
 772 06e1 EB06     		jmp	.L62
 773              	.L63:
 200:libusbwrap.c  **** 	return retVal;
 774              		.loc 3 200 0
 775 06e3 488B45F8 		movq	-8(%rbp), %rax
 776 06e7 EB05     		jmp	.L65
 777              	.L62:
 203:libusbwrap.c  **** exit:
 204:libusbwrap.c  **** 	return NULL;
 778              		.loc 3 204 0
 779 06e9 B8000000 		movl	$0, %eax
 779      00
 780              	.L65:
 205:libusbwrap.c  **** }
 781              		.loc 3 205 0
 782 06ee C9       		leave
 783              		.cfi_def_cfa 7, 8
 784 06ef C3       		ret
 785              		.cfi_endproc
 786              	.LFE25:
 789              	destroyTransfer:
 790              	.LFB26:
 206:libusbwrap.c  **** 
 207:libusbwrap.c  **** static void destroyTransfer(struct TransferWrapper *tx) {
 791              		.loc 3 207 0
 792              		.cfi_startproc
 793 06f0 55       		pushq	%rbp
 794              		.cfi_def_cfa_offset 16
 795              		.cfi_offset 6, -16
 796 06f1 4889E5   		movq	%rsp, %rbp
 797              		.cfi_def_cfa_register 6
 798 06f4 4883EC10 		subq	$16, %rsp
 799 06f8 48897DF8 		movq	%rdi, -8(%rbp)
 208:libusbwrap.c  **** 	if ( tx ) {
 800              		.loc 3 208 0
 801 06fc 48837DF8 		cmpq	$0, -8(%rbp)
 801      00
 802 0701 741B     		je	.L68
 209:libusbwrap.c  **** 		libusb_free_transfer(tx->transfer);
 803              		.loc 3 209 0
 804 0703 488B45F8 		movq	-8(%rbp), %rax
 805 0707 488B00   		movq	(%rax), %rax
 806 070a 4889C7   		movq	%rax, %rdi
 807 070d E8000000 		call	libusb_free_transfer@PLT
 807      00
 210:libusbwrap.c  **** 		free((void*)tx);
 808              		.loc 3 210 0
 809 0712 488B45F8 		movq	-8(%rbp), %rax
 810 0716 4889C7   		movq	%rax, %rdi
 811 0719 E8000000 		call	free@PLT
 811      00
 812              	.L68:
 211:libusbwrap.c  **** 	}
 212:libusbwrap.c  **** }
 813              		.loc 3 212 0
 814 071e 90       		nop
 815 071f C9       		leave
 816              		.cfi_def_cfa 7, 8
 817 0720 C3       		ret
 818              		.cfi_endproc
 819              	.LFE26:
 821              		.section	.rodata
 822 00f2 00000000 		.align 8
 822      0000
 823              	.LC5:
 824 00f8 7573624F 		.string	"usbOpenDevice(): you forgot to call usbInitialise()!"
 824      70656E44 
 824      65766963 
 824      6528293A 
 824      20796F75 
 825 012d 000000   		.align 8
 826              	.LC6:
 827 0130 7573624F 		.string	"usbOpenDevice(): The supplied VID:PID:DID \"%s\" is invalid; it should look like 1D50:602
 827      70656E44 
 827      65766963 
 827      6528293A 
 827      20546865 
 828 019b 00000000 		.align 8
 828      00
 829              	.LC7:
 830 01a0 7573624F 		.string	"usbOpenDevice(): Out of memory!"
 830      70656E44 
 830      65766963 
 830      6528293A 
 830      204F7574 
 831              	.LC8:
 832 01c0 7573624F 		.string	"usbOpenDevice()"
 832      70656E44 
 832      65766963 
 832      65282900 
 833              	.LC9:
 834 01d0 7573624F 		.string	"usbOpenDevice(): %s"
 834      70656E44 
 834      65766963 
 834      6528293A 
 834      20257300 
 835              		.text
 836              		.globl	usbOpenDevice
 838              	usbOpenDevice:
 839              	.LFB27:
 213:libusbwrap.c  **** 
 214:libusbwrap.c  **** // Find the descriptor of the first occurance of the specified device
 215:libusbwrap.c  **** //
 216:libusbwrap.c  **** DLLEXPORT(USBStatus) usbOpenDevice(
 217:libusbwrap.c  **** 	const char *vp, int configuration, int iface, int altSetting,
 218:libusbwrap.c  **** 	struct USBDevice **devHandlePtr, const char **error)
 219:libusbwrap.c  **** {
 840              		.loc 3 219 0
 841              		.cfi_startproc
 842 0721 55       		pushq	%rbp
 843              		.cfi_def_cfa_offset 16
 844              		.cfi_offset 6, -16
 845 0722 4889E5   		movq	%rsp, %rbp
 846              		.cfi_def_cfa_register 6
 847 0725 4883EC50 		subq	$80, %rsp
 848 0729 48897DD8 		movq	%rdi, -40(%rbp)
 849 072d 8975D4   		movl	%esi, -44(%rbp)
 850 0730 8955D0   		movl	%edx, -48(%rbp)
 851 0733 894DCC   		movl	%ecx, -52(%rbp)
 852 0736 4C8945C0 		movq	%r8, -64(%rbp)
 853 073a 4C894DB8 		movq	%r9, -72(%rbp)
 220:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 854              		.loc 3 220 0
 855 073e C745E800 		movl	$0, -24(%rbp)
 855      000000
 221:libusbwrap.c  **** 	uint16 vid, pid, did;
 222:libusbwrap.c  **** 	int status;
 223:libusbwrap.c  **** 	struct USBDevice *newWrapper;
 224:libusbwrap.c  **** 	struct libusb_device_handle *newHandle;
 225:libusbwrap.c  **** 	CHECK_STATUS(
 856              		.loc 3 225 0
 857 0745 488B0500 		movq	m_ctx(%rip), %rax
 857      000000
 858 074c 4885C0   		testq	%rax, %rax
 859 074f 751F     		jne	.L70
 860              		.loc 3 225 0 is_stmt 0 discriminator 1
 861 0751 488B45B8 		movq	-72(%rbp), %rax
 862 0755 488D3500 		leaq	.LC5(%rip), %rsi
 862      000000
 863 075c 4889C7   		movq	%rax, %rdi
 864 075f E8000000 		call	errPrefix@PLT
 864      00
 865 0764 C745E802 		movl	$2, -24(%rbp)
 865      000000
 866 076b E9AA0200 		jmp	.L71
 866      00
 867              	.L70:
 226:libusbwrap.c  **** 		!m_ctx, USB_INIT, exit,
 227:libusbwrap.c  **** 		"usbOpenDevice(): you forgot to call usbInitialise()!");
 228:libusbwrap.c  **** 	CHECK_STATUS(
 868              		.loc 3 228 0 is_stmt 1
 869 0770 488B45D8 		movq	-40(%rbp), %rax
 870 0774 4889C7   		movq	%rax, %rdi
 871 0777 E8000000 		call	usbValidateVidPid@PLT
 871      00
 872 077c 83F001   		xorl	$1, %eax
 873 077f 84C0     		testb	%al, %al
 874 0781 7428     		je	.L72
 875              		.loc 3 228 0 is_stmt 0 discriminator 1
 876 0783 488B55D8 		movq	-40(%rbp), %rdx
 877 0787 488B45B8 		movq	-72(%rbp), %rax
 878 078b 488D3500 		leaq	.LC6(%rip), %rsi
 878      000000
 879 0792 4889C7   		movq	%rax, %rdi
 880 0795 B8000000 		movl	$0, %eax
 880      00
 881 079a E8000000 		call	errRender@PLT
 881      00
 882 079f C745E801 		movl	$1, -24(%rbp)
 882      000000
 883 07a6 E96F0200 		jmp	.L71
 883      00
 884              	.L72:
 229:libusbwrap.c  **** 		!usbValidateVidPid(vp), USB_INVALID_VIDPID, exit,
 230:libusbwrap.c  **** 		"usbOpenDevice(): "FORMAT_ERR, vp);
 231:libusbwrap.c  **** 	vid = (uint16)strtoul(vp, NULL, 16);
 885              		.loc 3 231 0 is_stmt 1
 886 07ab 488B45D8 		movq	-40(%rbp), %rax
 887 07af BA100000 		movl	$16, %edx
 887      00
 888 07b4 BE000000 		movl	$0, %esi
 888      00
 889 07b9 4889C7   		movq	%rax, %rdi
 890 07bc E8000000 		call	strtoul@PLT
 890      00
 891 07c1 668945E2 		movw	%ax, -30(%rbp)
 232:libusbwrap.c  **** 	pid = (uint16)strtoul(vp+5, NULL, 16);
 892              		.loc 3 232 0
 893 07c5 488B45D8 		movq	-40(%rbp), %rax
 894 07c9 4883C005 		addq	$5, %rax
 895 07cd BA100000 		movl	$16, %edx
 895      00
 896 07d2 BE000000 		movl	$0, %esi
 896      00
 897 07d7 4889C7   		movq	%rax, %rdi
 898 07da E8000000 		call	strtoul@PLT
 898      00
 899 07df 668945E4 		movw	%ax, -28(%rbp)
 233:libusbwrap.c  **** 	did = (uint16)((strlen(vp) == 14) ? strtoul(vp+10, NULL, 16) : 0x0000);
 900              		.loc 3 233 0
 901 07e3 488B45D8 		movq	-40(%rbp), %rax
 902 07e7 4889C7   		movq	%rax, %rdi
 903 07ea E8000000 		call	strlen@PLT
 903      00
 904 07ef 4883F80E 		cmpq	$14, %rax
 905 07f3 751C     		jne	.L73
 906              		.loc 3 233 0 is_stmt 0 discriminator 1
 907 07f5 488B45D8 		movq	-40(%rbp), %rax
 908 07f9 4883C00A 		addq	$10, %rax
 909 07fd BA100000 		movl	$16, %edx
 909      00
 910 0802 BE000000 		movl	$0, %esi
 910      00
 911 0807 4889C7   		movq	%rax, %rdi
 912 080a E8000000 		call	strtoul@PLT
 912      00
 913 080f EB05     		jmp	.L74
 914              	.L73:
 915              		.loc 3 233 0 discriminator 2
 916 0811 B8000000 		movl	$0, %eax
 916      00
 917              	.L74:
 918              		.loc 3 233 0 discriminator 4
 919 0816 668945E6 		movw	%ax, -26(%rbp)
 234:libusbwrap.c  **** 	newWrapper = (struct USBDevice *)malloc(sizeof(struct USBDevice));
 920              		.loc 3 234 0 is_stmt 1 discriminator 4
 921 081a BF400000 		movl	$64, %edi
 921      00
 922 081f E8000000 		call	malloc@PLT
 922      00
 923 0824 488945F0 		movq	%rax, -16(%rbp)
 235:libusbwrap.c  **** 	CHECK_STATUS(newWrapper == NULL, USB_ALLOC_ERR, exit, "usbOpenDevice(): Out of memory!");
 924              		.loc 3 235 0 discriminator 4
 925 0828 48837DF0 		cmpq	$0, -16(%rbp)
 925      00
 926 082d 751F     		jne	.L75
 927              		.loc 3 235 0 is_stmt 0 discriminator 1
 928 082f 488B45B8 		movq	-72(%rbp), %rax
 929 0833 488D3500 		leaq	.LC7(%rip), %rsi
 929      000000
 930 083a 4889C7   		movq	%rax, %rdi
 931 083d E8000000 		call	errPrefix@PLT
 931      00
 932 0842 C745E80C 		movl	$12, -24(%rbp)
 932      000000
 933 0849 E9CC0100 		jmp	.L71
 933      00
 934              	.L75:
 236:libusbwrap.c  **** 	status = queueInit(&newWrapper->queue, 4, (CreateFunc)createTransfer, (DestroyFunc)destroyTransfer
 935              		.loc 3 236 0 is_stmt 1
 936 084e 488B45F0 		movq	-16(%rbp), %rax
 937 0852 488D7808 		leaq	8(%rax), %rdi
 938 0856 488D0D93 		leaq	destroyTransfer(%rip), %rcx
 938      FEFFFF
 939 085d 488B0500 		movq	createTransfer@GOTPCREL(%rip), %rax
 939      000000
 940 0864 4889C2   		movq	%rax, %rdx
 941 0867 BE040000 		movl	$4, %esi
 941      00
 942 086c E8000000 		call	queueInit@PLT
 942      00
 943 0871 8945EC   		movl	%eax, -20(%rbp)
 237:libusbwrap.c  **** 	CHECK_STATUS(status, USB_ALLOC_ERR, freeWrap, "usbOpenDevice(): Out of memory!");
 944              		.loc 3 237 0
 945 0874 837DEC00 		cmpl	$0, -20(%rbp)
 946 0878 741F     		je	.L76
 947              		.loc 3 237 0 is_stmt 0 discriminator 1
 948 087a 488B45B8 		movq	-72(%rbp), %rax
 949 087e 488D3500 		leaq	.LC7(%rip), %rsi
 949      000000
 950 0885 4889C7   		movq	%rax, %rdi
 951 0888 E8000000 		call	errPrefix@PLT
 951      00
 952 088d C745E80C 		movl	$12, -24(%rbp)
 952      000000
 953 0894 E9750100 		jmp	.L77
 953      00
 954              	.L76:
 238:libusbwrap.c  **** 	newHandle = libusbOpenWithVidPid(m_ctx, vid, pid, did, error);
 955              		.loc 3 238 0 is_stmt 1
 956 0899 0FB74DE6 		movzwl	-26(%rbp), %ecx
 957 089d 0FB755E4 		movzwl	-28(%rbp), %edx
 958 08a1 0FB775E2 		movzwl	-30(%rbp), %esi
 959 08a5 488B0500 		movq	m_ctx(%rip), %rax
 959      000000
 960 08ac 488B7DB8 		movq	-72(%rbp), %rdi
 961 08b0 4989F8   		movq	%rdi, %r8
 962 08b3 4889C7   		movq	%rax, %rdi
 963 08b6 E8CDF7FF 		call	libusbOpenWithVidPid
 963      FF
 964 08bb 488945F8 		movq	%rax, -8(%rbp)
 239:libusbwrap.c  **** 	CHECK_STATUS(!newHandle, USB_CANNOT_OPEN_DEVICE, freeQueue, "usbOpenDevice()");
 965              		.loc 3 239 0
 966 08bf 48837DF8 		cmpq	$0, -8(%rbp)
 966      00
 967 08c4 751F     		jne	.L78
 968              		.loc 3 239 0 is_stmt 0 discriminator 1
 969 08c6 488B45B8 		movq	-72(%rbp), %rax
 970 08ca 488D3500 		leaq	.LC8(%rip), %rsi
 970      000000
 971 08d1 4889C7   		movq	%rax, %rdi
 972 08d4 E8000000 		call	errPrefix@PLT
 972      00
 973 08d9 C745E805 		movl	$5, -24(%rbp)
 973      000000
 974 08e0 E9190100 		jmp	.L79
 974      00
 975              	.L78:
 240:libusbwrap.c  **** 	status = libusb_set_configuration(newHandle, configuration);
 976              		.loc 3 240 0 is_stmt 1
 977 08e5 8B55D4   		movl	-44(%rbp), %edx
 978 08e8 488B45F8 		movq	-8(%rbp), %rax
 979 08ec 89D6     		movl	%edx, %esi
 980 08ee 4889C7   		movq	%rax, %rdi
 981 08f1 E8000000 		call	libusb_set_configuration@PLT
 981      00
 982 08f6 8945EC   		movl	%eax, -20(%rbp)
 241:libusbwrap.c  **** 	CHECK_STATUS(
 983              		.loc 3 241 0
 984 08f9 837DEC00 		cmpl	$0, -20(%rbp)
 985 08fd 7931     		jns	.L80
 986              		.loc 3 241 0 is_stmt 0 discriminator 1
 987 08ff 8B45EC   		movl	-20(%rbp), %eax
 988 0902 89C7     		movl	%eax, %edi
 989 0904 E8000000 		call	libusb_error_name@PLT
 989      00
 990 0909 4889C2   		movq	%rax, %rdx
 991 090c 488B45B8 		movq	-72(%rbp), %rax
 992 0910 488D3500 		leaq	.LC9(%rip), %rsi
 992      000000
 993 0917 4889C7   		movq	%rax, %rdi
 994 091a B8000000 		movl	$0, %eax
 994      00
 995 091f E8000000 		call	errRender@PLT
 995      00
 996 0924 C745E806 		movl	$6, -24(%rbp)
 996      000000
 997 092b E9C20000 		jmp	.L81
 997      00
 998              	.L80:
 242:libusbwrap.c  **** 		status < 0, USB_CANNOT_SET_CONFIGURATION, closeDev,
 243:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 244:libusbwrap.c  **** 	status = libusb_claim_interface(newHandle, iface);
 999              		.loc 3 244 0 is_stmt 1
 1000 0930 8B55D0   		movl	-48(%rbp), %edx
 1001 0933 488B45F8 		movq	-8(%rbp), %rax
 1002 0937 89D6     		movl	%edx, %esi
 1003 0939 4889C7   		movq	%rax, %rdi
 1004 093c E8000000 		call	libusb_claim_interface@PLT
 1004      00
 1005 0941 8945EC   		movl	%eax, -20(%rbp)
 245:libusbwrap.c  **** 	CHECK_STATUS(
 1006              		.loc 3 245 0
 1007 0944 837DEC00 		cmpl	$0, -20(%rbp)
 1008 0948 792E     		jns	.L82
 1009              		.loc 3 245 0 is_stmt 0 discriminator 1
 1010 094a 8B45EC   		movl	-20(%rbp), %eax
 1011 094d 89C7     		movl	%eax, %edi
 1012 094f E8000000 		call	libusb_error_name@PLT
 1012      00
 1013 0954 4889C2   		movq	%rax, %rdx
 1014 0957 488B45B8 		movq	-72(%rbp), %rax
 1015 095b 488D3500 		leaq	.LC9(%rip), %rsi
 1015      000000
 1016 0962 4889C7   		movq	%rax, %rdi
 1017 0965 B8000000 		movl	$0, %eax
 1017      00
 1018 096a E8000000 		call	errRender@PLT
 1018      00
 1019 096f C745E807 		movl	$7, -24(%rbp)
 1019      000000
 1020 0976 EB7A     		jmp	.L81
 1021              	.L82:
 246:libusbwrap.c  **** 		status < 0, USB_CANNOT_CLAIM_INTERFACE, closeDev,
 247:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 248:libusbwrap.c  **** 	status = libusb_set_interface_alt_setting(newHandle, iface, altSetting);
 1022              		.loc 3 248 0 is_stmt 1
 1023 0978 8B55CC   		movl	-52(%rbp), %edx
 1024 097b 8B4DD0   		movl	-48(%rbp), %ecx
 1025 097e 488B45F8 		movq	-8(%rbp), %rax
 1026 0982 89CE     		movl	%ecx, %esi
 1027 0984 4889C7   		movq	%rax, %rdi
 1028 0987 E8000000 		call	libusb_set_interface_alt_setting@PLT
 1028      00
 1029 098c 8945EC   		movl	%eax, -20(%rbp)
 249:libusbwrap.c  **** 	CHECK_STATUS(
 1030              		.loc 3 249 0
 1031 098f 837DEC00 		cmpl	$0, -20(%rbp)
 1032 0993 7940     		jns	.L83
 1033              		.loc 3 249 0 is_stmt 0 discriminator 1
 1034 0995 8B45EC   		movl	-20(%rbp), %eax
 1035 0998 89C7     		movl	%eax, %edi
 1036 099a E8000000 		call	libusb_error_name@PLT
 1036      00
 1037 099f 4889C2   		movq	%rax, %rdx
 1038 09a2 488B45B8 		movq	-72(%rbp), %rax
 1039 09a6 488D3500 		leaq	.LC9(%rip), %rsi
 1039      000000
 1040 09ad 4889C7   		movq	%rax, %rdi
 1041 09b0 B8000000 		movl	$0, %eax
 1041      00
 1042 09b5 E8000000 		call	errRender@PLT
 1042      00
 1043 09ba C745E808 		movl	$8, -24(%rbp)
 1043      000000
 1044 09c1 90       		nop
 1045              	.L84:
 250:libusbwrap.c  **** 		status < 0, USB_CANNOT_SET_ALTINT, release,
 251:libusbwrap.c  **** 		"usbOpenDevice(): %s", libusb_error_name(status));
 252:libusbwrap.c  **** 	newWrapper->handle = newHandle;	
 253:libusbwrap.c  **** 	*devHandlePtr = newWrapper;
 254:libusbwrap.c  **** 	return USB_SUCCESS;
 255:libusbwrap.c  **** release:
 256:libusbwrap.c  **** 	libusb_release_interface(newHandle, iface);
 1046              		.loc 3 256 0 is_stmt 1 discriminator 1
 1047 09c2 8B55D0   		movl	-48(%rbp), %edx
 1048 09c5 488B45F8 		movq	-8(%rbp), %rax
 1049 09c9 89D6     		movl	%edx, %esi
 1050 09cb 4889C7   		movq	%rax, %rdi
 1051 09ce E8000000 		call	libusb_release_interface@PLT
 1051      00
 1052 09d3 EB1D     		jmp	.L81
 1053              	.L83:
 252:libusbwrap.c  **** 	*devHandlePtr = newWrapper;
 1054              		.loc 3 252 0
 1055 09d5 488B45F0 		movq	-16(%rbp), %rax
 1056 09d9 488B55F8 		movq	-8(%rbp), %rdx
 1057 09dd 488910   		movq	%rdx, (%rax)
 253:libusbwrap.c  **** 	return USB_SUCCESS;
 1058              		.loc 3 253 0
 1059 09e0 488B45C0 		movq	-64(%rbp), %rax
 1060 09e4 488B55F0 		movq	-16(%rbp), %rdx
 1061 09e8 488910   		movq	%rdx, (%rax)
 254:libusbwrap.c  **** release:
 1062              		.loc 3 254 0
 1063 09eb B8000000 		movl	$0, %eax
 1063      00
 1064 09f0 EB36     		jmp	.L85
 1065              	.L81:
 257:libusbwrap.c  **** closeDev:
 258:libusbwrap.c  **** 	libusb_close(newHandle);	
 1066              		.loc 3 258 0
 1067 09f2 488B45F8 		movq	-8(%rbp), %rax
 1068 09f6 4889C7   		movq	%rax, %rdi
 1069 09f9 E8000000 		call	libusb_close@PLT
 1069      00
 1070              	.L79:
 259:libusbwrap.c  **** freeQueue:
 260:libusbwrap.c  **** 	queueDestroy(&newWrapper->queue);
 1071              		.loc 3 260 0
 1072 09fe 488B45F0 		movq	-16(%rbp), %rax
 1073 0a02 4883C008 		addq	$8, %rax
 1074 0a06 4889C7   		movq	%rax, %rdi
 1075 0a09 E8000000 		call	queueDestroy@PLT
 1075      00
 1076              	.L77:
 261:libusbwrap.c  **** freeWrap:
 262:libusbwrap.c  **** 	free((void*)newWrapper);
 1077              		.loc 3 262 0
 1078 0a0e 488B45F0 		movq	-16(%rbp), %rax
 1079 0a12 4889C7   		movq	%rax, %rdi
 1080 0a15 E8000000 		call	free@PLT
 1080      00
 1081              	.L71:
 263:libusbwrap.c  **** exit:
 264:libusbwrap.c  **** 	*devHandlePtr = NULL;
 1082              		.loc 3 264 0
 1083 0a1a 488B45C0 		movq	-64(%rbp), %rax
 1084 0a1e 48C70000 		movq	$0, (%rax)
 1084      000000
 265:libusbwrap.c  **** 	return retVal;
 1085              		.loc 3 265 0
 1086 0a25 8B45E8   		movl	-24(%rbp), %eax
 1087              	.L85:
 266:libusbwrap.c  **** }
 1088              		.loc 3 266 0
 1089 0a28 C9       		leave
 1090              		.cfi_def_cfa 7, 8
 1091 0a29 C3       		ret
 1092              		.cfi_endproc
 1093              	.LFE27:
 1095              		.globl	usbCloseDevice
 1097              	usbCloseDevice:
 1098              	.LFB28:
 267:libusbwrap.c  **** 
 268:libusbwrap.c  **** DLLEXPORT(void) usbCloseDevice(struct USBDevice *dev, int iface) {
 1099              		.loc 3 268 0
 1100              		.cfi_startproc
 1101 0a2a 55       		pushq	%rbp
 1102              		.cfi_def_cfa_offset 16
 1103              		.cfi_offset 6, -16
 1104 0a2b 4889E5   		movq	%rsp, %rbp
 1105              		.cfi_def_cfa_register 6
 1106 0a2e 4883EC20 		subq	$32, %rsp
 1107 0a32 48897DE8 		movq	%rdi, -24(%rbp)
 1108 0a36 8975E4   		movl	%esi, -28(%rbp)
 269:libusbwrap.c  **** 	if ( dev ) {
 1109              		.loc 3 269 0
 1110 0a39 48837DE8 		cmpq	$0, -24(%rbp)
 1110      00
 1111 0a3e 7444     		je	.L88
 1112              	.LBB3:
 270:libusbwrap.c  **** 		struct libusb_device_handle *ptr = dev->handle;
 1113              		.loc 3 270 0
 1114 0a40 488B45E8 		movq	-24(%rbp), %rax
 1115 0a44 488B00   		movq	(%rax), %rax
 1116 0a47 488945F8 		movq	%rax, -8(%rbp)
 271:libusbwrap.c  **** 		libusb_release_interface(ptr, iface);
 1117              		.loc 3 271 0
 1118 0a4b 8B55E4   		movl	-28(%rbp), %edx
 1119 0a4e 488B45F8 		movq	-8(%rbp), %rax
 1120 0a52 89D6     		movl	%edx, %esi
 1121 0a54 4889C7   		movq	%rax, %rdi
 1122 0a57 E8000000 		call	libusb_release_interface@PLT
 1122      00
 272:libusbwrap.c  **** 		libusb_close(ptr);
 1123              		.loc 3 272 0
 1124 0a5c 488B45F8 		movq	-8(%rbp), %rax
 1125 0a60 4889C7   		movq	%rax, %rdi
 1126 0a63 E8000000 		call	libusb_close@PLT
 1126      00
 273:libusbwrap.c  **** 		queueDestroy(&dev->queue);
 1127              		.loc 3 273 0
 1128 0a68 488B45E8 		movq	-24(%rbp), %rax
 1129 0a6c 4883C008 		addq	$8, %rax
 1130 0a70 4889C7   		movq	%rax, %rdi
 1131 0a73 E8000000 		call	queueDestroy@PLT
 1131      00
 274:libusbwrap.c  **** 		free((void*)dev);
 1132              		.loc 3 274 0
 1133 0a78 488B45E8 		movq	-24(%rbp), %rax
 1134 0a7c 4889C7   		movq	%rax, %rdi
 1135 0a7f E8000000 		call	free@PLT
 1135      00
 1136              	.L88:
 1137              	.LBE3:
 275:libusbwrap.c  **** 	}
 276:libusbwrap.c  **** }
 1138              		.loc 3 276 0
 1139 0a84 90       		nop
 1140 0a85 C9       		leave
 1141              		.cfi_def_cfa 7, 8
 1142 0a86 C3       		ret
 1143              		.cfi_endproc
 1144              	.LFE28:
 1146              		.section	.rodata
 1147              	.LC10:
 1148 01e4 75736243 		.string	"usbControlRead(): Timeout!"
 1148      6F6E7472 
 1148      6F6C5265 
 1148      61642829 
 1148      3A205469 
 1149              	.LC11:
 1150 01ff 75736243 		.string	"usbControlRead(): %s"
 1150      6F6E7472 
 1150      6F6C5265 
 1150      61642829 
 1150      3A202573 
 1151 0214 00000000 		.align 8
 1152              	.LC12:
 1153 0218 75736243 		.string	"usbControlRead(): Expected to read %d bytes but actually read %d"
 1153      6F6E7472 
 1153      6F6C5265 
 1153      61642829 
 1153      3A204578 
 1154              		.text
 1155              		.globl	usbControlRead
 1157              	usbControlRead:
 1158              	.LFB29:
 277:libusbwrap.c  **** 
 278:libusbwrap.c  **** DLLEXPORT(USBStatus) usbControlRead(
 279:libusbwrap.c  **** 	struct USBDevice *dev, uint8 bRequest, uint16 wValue, uint16 wIndex,
 280:libusbwrap.c  **** 	uint8 *data, uint16 wLength,
 281:libusbwrap.c  **** 	uint32 timeout, const char **error)
 282:libusbwrap.c  **** {
 1159              		.loc 3 282 0
 1160              		.cfi_startproc
 1161 0a87 55       		pushq	%rbp
 1162              		.cfi_def_cfa_offset 16
 1163              		.cfi_offset 6, -16
 1164 0a88 4889E5   		movq	%rsp, %rbp
 1165              		.cfi_def_cfa_register 6
 1166 0a8b 4883EC30 		subq	$48, %rsp
 1167 0a8f 48897DE8 		movq	%rdi, -24(%rbp)
 1168 0a93 89C8     		movl	%ecx, %eax
 1169 0a95 4C8945D0 		movq	%r8, -48(%rbp)
 1170 0a99 4489C9   		movl	%r9d, %ecx
 1171 0a9c 408875E4 		movb	%sil, -28(%rbp)
 1172 0aa0 668955E0 		movw	%dx, -32(%rbp)
 1173 0aa4 668945DC 		movw	%ax, -36(%rbp)
 1174 0aa8 66894DD8 		movw	%cx, -40(%rbp)
 283:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1175              		.loc 3 283 0
 1176 0aac C745F800 		movl	$0, -8(%rbp)
 1176      000000
 284:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1177              		.loc 3 284 0
 1178 0ab3 0FB775D8 		movzwl	-40(%rbp), %esi
 1179 0ab7 440FB745 		movzwl	-36(%rbp), %r8d
 1179      DC
 1180 0abc 0FB74DE0 		movzwl	-32(%rbp), %ecx
 1181 0ac0 0FB655E4 		movzbl	-28(%rbp), %edx
 285:libusbwrap.c  **** 		dev->handle,
 1182              		.loc 3 285 0
 1183 0ac4 488B45E8 		movq	-24(%rbp), %rax
 1184 0ac8 488B00   		movq	(%rax), %rax
 284:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1185              		.loc 3 284 0
 1186 0acb 4C8B4DD0 		movq	-48(%rbp), %r9
 1187 0acf 8B7D10   		movl	16(%rbp), %edi
 1188 0ad2 57       		pushq	%rdi
 1189 0ad3 56       		pushq	%rsi
 1190 0ad4 BEC00000 		movl	$192, %esi
 1190      00
 1191 0ad9 4889C7   		movq	%rax, %rdi
 1192 0adc E8000000 		call	libusb_control_transfer@PLT
 1192      00
 1193 0ae1 4883C410 		addq	$16, %rsp
 1194 0ae5 8945FC   		movl	%eax, -4(%rbp)
 286:libusbwrap.c  **** 		LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
 287:libusbwrap.c  **** 		bRequest,
 288:libusbwrap.c  **** 		wValue,
 289:libusbwrap.c  **** 		wIndex,
 290:libusbwrap.c  **** 		(uint8 *)data,
 291:libusbwrap.c  **** 		wLength,
 292:libusbwrap.c  **** 		timeout
 293:libusbwrap.c  **** 	);
 294:libusbwrap.c  **** 	CHECK_STATUS(
 1195              		.loc 3 294 0
 1196 0ae8 837DFCF9 		cmpl	$-7, -4(%rbp)
 1197 0aec 751C     		jne	.L90
 1198              		.loc 3 294 0 is_stmt 0 discriminator 1
 1199 0aee 488B4518 		movq	24(%rbp), %rax
 1200 0af2 488D3500 		leaq	.LC10(%rip), %rsi
 1200      000000
 1201 0af9 4889C7   		movq	%rax, %rdi
 1202 0afc E8000000 		call	errPrefix@PLT
 1202      00
 1203 0b01 C745F812 		movl	$18, -8(%rbp)
 1203      000000
 1204 0b08 EB64     		jmp	.L91
 1205              	.L90:
 295:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 296:libusbwrap.c  **** 		"usbControlRead(): Timeout!");
 297:libusbwrap.c  **** 	CHECK_STATUS(
 1206              		.loc 3 297 0 is_stmt 1
 1207 0b0a 837DFC00 		cmpl	$0, -4(%rbp)
 1208 0b0e 792E     		jns	.L92
 1209              		.loc 3 297 0 is_stmt 0 discriminator 1
 1210 0b10 8B45FC   		movl	-4(%rbp), %eax
 1211 0b13 89C7     		movl	%eax, %edi
 1212 0b15 E8000000 		call	libusb_error_name@PLT
 1212      00
 1213 0b1a 4889C2   		movq	%rax, %rdx
 1214 0b1d 488B4518 		movq	24(%rbp), %rax
 1215 0b21 488D3500 		leaq	.LC11(%rip), %rsi
 1215      000000
 1216 0b28 4889C7   		movq	%rax, %rdi
 1217 0b2b B8000000 		movl	$0, %eax
 1217      00
 1218 0b30 E8000000 		call	errRender@PLT
 1218      00
 1219 0b35 C745F80A 		movl	$10, -8(%rbp)
 1219      000000
 1220 0b3c EB30     		jmp	.L91
 1221              	.L92:
 298:libusbwrap.c  **** 		status < 0, USB_CONTROL, cleanup,
 299:libusbwrap.c  **** 		"usbControlRead(): %s", libusb_error_name(status));
 300:libusbwrap.c  **** 	CHECK_STATUS(
 1222              		.loc 3 300 0 is_stmt 1
 1223 0b3e 0FB745D8 		movzwl	-40(%rbp), %eax
 1224 0b42 3B45FC   		cmpl	-4(%rbp), %eax
 1225 0b45 7427     		je	.L91
 1226              		.loc 3 300 0 is_stmt 0 discriminator 1
 1227 0b47 0FB755D8 		movzwl	-40(%rbp), %edx
 1228 0b4b 8B4DFC   		movl	-4(%rbp), %ecx
 1229 0b4e 488B4518 		movq	24(%rbp), %rax
 1230 0b52 488D3500 		leaq	.LC12(%rip), %rsi
 1230      000000
 1231 0b59 4889C7   		movq	%rax, %rdi
 1232 0b5c B8000000 		movl	$0, %eax
 1232      00
 1233 0b61 E8000000 		call	errRender@PLT
 1233      00
 1234 0b66 C745F80A 		movl	$10, -8(%rbp)
 1234      000000
 1235 0b6d 90       		nop
 1236              	.L91:
 301:libusbwrap.c  **** 		status != wLength, USB_CONTROL, cleanup,
 302:libusbwrap.c  **** 		"usbControlRead(): Expected to read %d bytes but actually read %d", wLength, status);
 303:libusbwrap.c  **** cleanup:
 304:libusbwrap.c  **** 	return retVal;
 1237              		.loc 3 304 0 is_stmt 1
 1238 0b6e 8B45F8   		movl	-8(%rbp), %eax
 305:libusbwrap.c  **** }
 1239              		.loc 3 305 0
 1240 0b71 C9       		leave
 1241              		.cfi_def_cfa 7, 8
 1242 0b72 C3       		ret
 1243              		.cfi_endproc
 1244              	.LFE29:
 1246              		.section	.rodata
 1247              	.LC13:
 1248 0259 75736243 		.string	"usbControlWrite(): Timeout"
 1248      6F6E7472 
 1248      6F6C5772 
 1248      69746528 
 1248      293A2054 
 1249              	.LC14:
 1250 0274 75736243 		.string	"usbControlWrite(): %s"
 1250      6F6E7472 
 1250      6F6C5772 
 1250      69746528 
 1250      293A2025 
 1251 028a 00000000 		.align 8
 1251      0000
 1252              	.LC15:
 1253 0290 75736243 		.string	"usbControlWrite(): Expected to write %d bytes but actually wrote %d"
 1253      6F6E7472 
 1253      6F6C5772 
 1253      69746528 
 1253      293A2045 
 1254              		.text
 1255              		.globl	usbControlWrite
 1257              	usbControlWrite:
 1258              	.LFB30:
 306:libusbwrap.c  **** 
 307:libusbwrap.c  **** DLLEXPORT(USBStatus) usbControlWrite(
 308:libusbwrap.c  **** 	struct USBDevice *dev, uint8 bRequest, uint16 wValue, uint16 wIndex,
 309:libusbwrap.c  **** 	const uint8 *data, uint16 wLength,
 310:libusbwrap.c  **** 	uint32 timeout, const char **error)
 311:libusbwrap.c  **** {
 1259              		.loc 3 311 0
 1260              		.cfi_startproc
 1261 0b73 55       		pushq	%rbp
 1262              		.cfi_def_cfa_offset 16
 1263              		.cfi_offset 6, -16
 1264 0b74 4889E5   		movq	%rsp, %rbp
 1265              		.cfi_def_cfa_register 6
 1266 0b77 4883EC30 		subq	$48, %rsp
 1267 0b7b 48897DE8 		movq	%rdi, -24(%rbp)
 1268 0b7f 89C8     		movl	%ecx, %eax
 1269 0b81 4C8945D0 		movq	%r8, -48(%rbp)
 1270 0b85 4489C9   		movl	%r9d, %ecx
 1271 0b88 408875E4 		movb	%sil, -28(%rbp)
 1272 0b8c 668955E0 		movw	%dx, -32(%rbp)
 1273 0b90 668945DC 		movw	%ax, -36(%rbp)
 1274 0b94 66894DD8 		movw	%cx, -40(%rbp)
 312:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1275              		.loc 3 312 0
 1276 0b98 C745F800 		movl	$0, -8(%rbp)
 1276      000000
 313:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1277              		.loc 3 313 0
 1278 0b9f 0FB775D8 		movzwl	-40(%rbp), %esi
 1279 0ba3 440FB745 		movzwl	-36(%rbp), %r8d
 1279      DC
 1280 0ba8 0FB74DE0 		movzwl	-32(%rbp), %ecx
 1281 0bac 0FB655E4 		movzbl	-28(%rbp), %edx
 314:libusbwrap.c  **** 		dev->handle,
 1282              		.loc 3 314 0
 1283 0bb0 488B45E8 		movq	-24(%rbp), %rax
 1284 0bb4 488B00   		movq	(%rax), %rax
 313:libusbwrap.c  **** 	int status = libusb_control_transfer(
 1285              		.loc 3 313 0
 1286 0bb7 4C8B4DD0 		movq	-48(%rbp), %r9
 1287 0bbb 8B7D10   		movl	16(%rbp), %edi
 1288 0bbe 57       		pushq	%rdi
 1289 0bbf 56       		pushq	%rsi
 1290 0bc0 BE400000 		movl	$64, %esi
 1290      00
 1291 0bc5 4889C7   		movq	%rax, %rdi
 1292 0bc8 E8000000 		call	libusb_control_transfer@PLT
 1292      00
 1293 0bcd 4883C410 		addq	$16, %rsp
 1294 0bd1 8945FC   		movl	%eax, -4(%rbp)
 315:libusbwrap.c  **** 		LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
 316:libusbwrap.c  **** 		bRequest,
 317:libusbwrap.c  **** 		wValue,
 318:libusbwrap.c  **** 		wIndex,
 319:libusbwrap.c  **** 		(uint8 *)data,
 320:libusbwrap.c  **** 		wLength,
 321:libusbwrap.c  **** 		timeout
 322:libusbwrap.c  **** 	);
 323:libusbwrap.c  **** 	CHECK_STATUS(
 1295              		.loc 3 323 0
 1296 0bd4 837DFCF9 		cmpl	$-7, -4(%rbp)
 1297 0bd8 751C     		jne	.L95
 1298              		.loc 3 323 0 is_stmt 0 discriminator 1
 1299 0bda 488B4518 		movq	24(%rbp), %rax
 1300 0bde 488D3500 		leaq	.LC13(%rip), %rsi
 1300      000000
 1301 0be5 4889C7   		movq	%rax, %rdi
 1302 0be8 E8000000 		call	errPrefix@PLT
 1302      00
 1303 0bed C745F812 		movl	$18, -8(%rbp)
 1303      000000
 1304 0bf4 EB64     		jmp	.L96
 1305              	.L95:
 324:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 325:libusbwrap.c  **** 		"usbControlWrite(): Timeout");
 326:libusbwrap.c  **** 	CHECK_STATUS(
 1306              		.loc 3 326 0 is_stmt 1
 1307 0bf6 837DFC00 		cmpl	$0, -4(%rbp)
 1308 0bfa 792E     		jns	.L97
 1309              		.loc 3 326 0 is_stmt 0 discriminator 1
 1310 0bfc 8B45FC   		movl	-4(%rbp), %eax
 1311 0bff 89C7     		movl	%eax, %edi
 1312 0c01 E8000000 		call	libusb_error_name@PLT
 1312      00
 1313 0c06 4889C2   		movq	%rax, %rdx
 1314 0c09 488B4518 		movq	24(%rbp), %rax
 1315 0c0d 488D3500 		leaq	.LC14(%rip), %rsi
 1315      000000
 1316 0c14 4889C7   		movq	%rax, %rdi
 1317 0c17 B8000000 		movl	$0, %eax
 1317      00
 1318 0c1c E8000000 		call	errRender@PLT
 1318      00
 1319 0c21 C745F80A 		movl	$10, -8(%rbp)
 1319      000000
 1320 0c28 EB30     		jmp	.L96
 1321              	.L97:
 327:libusbwrap.c  **** 		status < 0, USB_CONTROL, cleanup,
 328:libusbwrap.c  **** 		"usbControlWrite(): %s", libusb_error_name(status));
 329:libusbwrap.c  **** 	CHECK_STATUS(
 1322              		.loc 3 329 0 is_stmt 1
 1323 0c2a 0FB745D8 		movzwl	-40(%rbp), %eax
 1324 0c2e 3B45FC   		cmpl	-4(%rbp), %eax
 1325 0c31 7427     		je	.L96
 1326              		.loc 3 329 0 is_stmt 0 discriminator 1
 1327 0c33 0FB755D8 		movzwl	-40(%rbp), %edx
 1328 0c37 8B4DFC   		movl	-4(%rbp), %ecx
 1329 0c3a 488B4518 		movq	24(%rbp), %rax
 1330 0c3e 488D3500 		leaq	.LC15(%rip), %rsi
 1330      000000
 1331 0c45 4889C7   		movq	%rax, %rdi
 1332 0c48 B8000000 		movl	$0, %eax
 1332      00
 1333 0c4d E8000000 		call	errRender@PLT
 1333      00
 1334 0c52 C745F80A 		movl	$10, -8(%rbp)
 1334      000000
 1335 0c59 90       		nop
 1336              	.L96:
 330:libusbwrap.c  **** 		status != wLength, USB_CONTROL, cleanup,
 331:libusbwrap.c  **** 		"usbControlWrite(): Expected to write %d bytes but actually wrote %d", wLength, status);
 332:libusbwrap.c  **** cleanup:
 333:libusbwrap.c  **** 	return retVal;
 1337              		.loc 3 333 0 is_stmt 1
 1338 0c5a 8B45F8   		movl	-8(%rbp), %eax
 334:libusbwrap.c  **** }
 1339              		.loc 3 334 0
 1340 0c5d C9       		leave
 1341              		.cfi_def_cfa 7, 8
 1342 0c5e C3       		ret
 1343              		.cfi_endproc
 1344              	.LFE30:
 1346              		.section	.rodata
 1347              	.LC16:
 1348 02d4 75736242 		.string	"usbBulkRead(): Timeout"
 1348      756C6B52 
 1348      65616428 
 1348      293A2054 
 1348      696D656F 
 1349              	.LC17:
 1350 02eb 75736242 		.string	"usbBulkRead(): %s"
 1350      756C6B52 
 1350      65616428 
 1350      293A2025 
 1350      7300
 1351 02fd 000000   		.align 8
 1352              	.LC18:
 1353 0300 75736242 		.string	"usbBulkRead(): Expected to read %d bytes but actually read %d (status = %d): %s"
 1353      756C6B52 
 1353      65616428 
 1353      293A2045 
 1353      78706563 
 1354              		.text
 1355              		.globl	usbBulkRead
 1357              	usbBulkRead:
 1358              	.LFB31:
 335:libusbwrap.c  **** 
 336:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkRead(
 337:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint8 *data, uint32 count,
 338:libusbwrap.c  **** 	uint32 timeout, const char **error)
 339:libusbwrap.c  **** {
 1359              		.loc 3 339 0
 1360              		.cfi_startproc
 1361 0c5f 55       		pushq	%rbp
 1362              		.cfi_def_cfa_offset 16
 1363              		.cfi_offset 6, -16
 1364 0c60 4889E5   		movq	%rsp, %rbp
 1365              		.cfi_def_cfa_register 6
 1366 0c63 4883EC50 		subq	$80, %rsp
 1367 0c67 48897DD8 		movq	%rdi, -40(%rbp)
 1368 0c6b 89F0     		movl	%esi, %eax
 1369 0c6d 488955C8 		movq	%rdx, -56(%rbp)
 1370 0c71 894DD0   		movl	%ecx, -48(%rbp)
 1371 0c74 448945C4 		movl	%r8d, -60(%rbp)
 1372 0c78 4C894DB8 		movq	%r9, -72(%rbp)
 1373 0c7c 8845D4   		movb	%al, -44(%rbp)
 1374              		.loc 3 339 0
 1375 0c7f 64488B04 		movq	%fs:40, %rax
 1375      25280000 
 1375      00
 1376 0c88 488945F8 		movq	%rax, -8(%rbp)
 1377 0c8c 31C0     		xorl	%eax, %eax
 340:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1378              		.loc 3 340 0
 1379 0c8e C745F000 		movl	$0, -16(%rbp)
 1379      000000
 341:libusbwrap.c  **** 	int numRead;
 342:libusbwrap.c  **** 	int status = libusb_bulk_transfer(
 1380              		.loc 3 342 0
 1381 0c95 8B4DD0   		movl	-48(%rbp), %ecx
 1382 0c98 0FB645D4 		movzbl	-44(%rbp), %eax
 1383 0c9c 83C880   		orl	$-128, %eax
 1384 0c9f 0FB6F0   		movzbl	%al, %esi
 343:libusbwrap.c  **** 		dev->handle,
 1385              		.loc 3 343 0
 1386 0ca2 488B45D8 		movq	-40(%rbp), %rax
 1387 0ca6 488B00   		movq	(%rax), %rax
 342:libusbwrap.c  **** 		dev->handle,
 1388              		.loc 3 342 0
 1389 0ca9 448B45C4 		movl	-60(%rbp), %r8d
 1390 0cad 488D7DEC 		leaq	-20(%rbp), %rdi
 1391 0cb1 488B55C8 		movq	-56(%rbp), %rdx
 1392 0cb5 4589C1   		movl	%r8d, %r9d
 1393 0cb8 4989F8   		movq	%rdi, %r8
 1394 0cbb 4889C7   		movq	%rax, %rdi
 1395 0cbe E8000000 		call	libusb_bulk_transfer@PLT
 1395      00
 1396 0cc3 8945F4   		movl	%eax, -12(%rbp)
 344:libusbwrap.c  **** 		LIBUSB_ENDPOINT_IN | endpoint,
 345:libusbwrap.c  **** 		data,
 346:libusbwrap.c  **** 		(int)count,
 347:libusbwrap.c  **** 		&numRead,
 348:libusbwrap.c  **** 		timeout
 349:libusbwrap.c  **** 	);
 350:libusbwrap.c  **** 	CHECK_STATUS(
 1397              		.loc 3 350 0
 1398 0cc6 837DF4F9 		cmpl	$-7, -12(%rbp)
 1399 0cca 751C     		jne	.L100
 1400              		.loc 3 350 0 is_stmt 0 discriminator 1
 1401 0ccc 488B45B8 		movq	-72(%rbp), %rax
 1402 0cd0 488D3500 		leaq	.LC16(%rip), %rsi
 1402      000000
 1403 0cd7 4889C7   		movq	%rax, %rdi
 1404 0cda E8000000 		call	errPrefix@PLT
 1404      00
 1405 0cdf C745F012 		movl	$18, -16(%rbp)
 1405      000000
 1406 0ce6 EB78     		jmp	.L101
 1407              	.L100:
 351:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 352:libusbwrap.c  **** 		"usbBulkRead(): Timeout");
 353:libusbwrap.c  **** 	CHECK_STATUS(
 1408              		.loc 3 353 0 is_stmt 1
 1409 0ce8 837DF400 		cmpl	$0, -12(%rbp)
 1410 0cec 792E     		jns	.L102
 1411              		.loc 3 353 0 is_stmt 0 discriminator 1
 1412 0cee 8B45F4   		movl	-12(%rbp), %eax
 1413 0cf1 89C7     		movl	%eax, %edi
 1414 0cf3 E8000000 		call	libusb_error_name@PLT
 1414      00
 1415 0cf8 4889C2   		movq	%rax, %rdx
 1416 0cfb 488B45B8 		movq	-72(%rbp), %rax
 1417 0cff 488D3500 		leaq	.LC17(%rip), %rsi
 1417      000000
 1418 0d06 4889C7   		movq	%rax, %rdi
 1419 0d09 B8000000 		movl	$0, %eax
 1419      00
 1420 0d0e E8000000 		call	errRender@PLT
 1420      00
 1421 0d13 C745F00B 		movl	$11, -16(%rbp)
 1421      000000
 1422 0d1a EB44     		jmp	.L101
 1423              	.L102:
 354:libusbwrap.c  **** 		status < 0, USB_BULK, cleanup,
 355:libusbwrap.c  **** 		"usbBulkRead(): %s", libusb_error_name(status));
 356:libusbwrap.c  **** 	CHECK_STATUS(
 1424              		.loc 3 356 0 is_stmt 1
 1425 0d1c 8B45EC   		movl	-20(%rbp), %eax
 1426 0d1f 3B45D0   		cmpl	-48(%rbp), %eax
 1427 0d22 743C     		je	.L101
 1428              		.loc 3 356 0 is_stmt 0 discriminator 1
 1429 0d24 8B45F4   		movl	-12(%rbp), %eax
 1430 0d27 89C7     		movl	%eax, %edi
 1431 0d29 E8000000 		call	libusb_error_name@PLT
 1431      00
 1432 0d2e 4889C7   		movq	%rax, %rdi
 1433 0d31 8B4DEC   		movl	-20(%rbp), %ecx
 1434 0d34 8B75F4   		movl	-12(%rbp), %esi
 1435 0d37 8B55D0   		movl	-48(%rbp), %edx
 1436 0d3a 488B45B8 		movq	-72(%rbp), %rax
 1437 0d3e 4989F9   		movq	%rdi, %r9
 1438 0d41 4189F0   		movl	%esi, %r8d
 1439 0d44 488D3500 		leaq	.LC18(%rip), %rsi
 1439      000000
 1440 0d4b 4889C7   		movq	%rax, %rdi
 1441 0d4e B8000000 		movl	$0, %eax
 1441      00
 1442 0d53 E8000000 		call	errRender@PLT
 1442      00
 1443 0d58 C745F00B 		movl	$11, -16(%rbp)
 1443      000000
 1444 0d5f 90       		nop
 1445              	.L101:
 357:libusbwrap.c  **** 		(uint32)numRead != count, USB_BULK, cleanup,
 358:libusbwrap.c  **** 		"usbBulkRead(): Expected to read %d bytes but actually read %d (status = %d): %s",
 359:libusbwrap.c  **** 		count, numRead, status, libusb_error_name(status));
 360:libusbwrap.c  **** cleanup:
 361:libusbwrap.c  **** 	return retVal;
 1446              		.loc 3 361 0 is_stmt 1
 1447 0d60 8B45F0   		movl	-16(%rbp), %eax
 362:libusbwrap.c  **** }
 1448              		.loc 3 362 0
 1449 0d63 488B4DF8 		movq	-8(%rbp), %rcx
 1450 0d67 6448330C 		xorq	%fs:40, %rcx
 1450      25280000 
 1450      00
 1451 0d70 7405     		je	.L104
 1452 0d72 E8000000 		call	__stack_chk_fail@PLT
 1452      00
 1453              	.L104:
 1454 0d77 C9       		leave
 1455              		.cfi_def_cfa 7, 8
 1456 0d78 C3       		ret
 1457              		.cfi_endproc
 1458              	.LFE31:
 1460              		.section	.rodata
 1461              	.LC19:
 1462 0350 75736242 		.string	"usbBulkWrite(): Timeout"
 1462      756C6B57 
 1462      72697465 
 1462      28293A20 
 1462      54696D65 
 1463              	.LC20:
 1464 0368 75736242 		.string	"usbBulkWrite(): %s"
 1464      756C6B57 
 1464      72697465 
 1464      28293A20 
 1464      257300
 1465 037b 00000000 		.align 8
 1465      00
 1466              	.LC21:
 1467 0380 75736242 		.string	"usbBulkWrite(): Expected to write %d bytes but actually wrote %d (status = %d): %s"
 1467      756C6B57 
 1467      72697465 
 1467      28293A20 
 1467      45787065 
 1468              		.text
 1469              		.globl	usbBulkWrite
 1471              	usbBulkWrite:
 1472              	.LFB32:
 363:libusbwrap.c  **** 
 364:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWrite(
 365:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, const uint8 *data, uint32 count,
 366:libusbwrap.c  **** 	uint32 timeout, const char **error)
 367:libusbwrap.c  **** {
 1473              		.loc 3 367 0
 1474              		.cfi_startproc
 1475 0d79 55       		pushq	%rbp
 1476              		.cfi_def_cfa_offset 16
 1477              		.cfi_offset 6, -16
 1478 0d7a 4889E5   		movq	%rsp, %rbp
 1479              		.cfi_def_cfa_register 6
 1480 0d7d 4883EC50 		subq	$80, %rsp
 1481 0d81 48897DD8 		movq	%rdi, -40(%rbp)
 1482 0d85 89F0     		movl	%esi, %eax
 1483 0d87 488955C8 		movq	%rdx, -56(%rbp)
 1484 0d8b 894DD0   		movl	%ecx, -48(%rbp)
 1485 0d8e 448945C4 		movl	%r8d, -60(%rbp)
 1486 0d92 4C894DB8 		movq	%r9, -72(%rbp)
 1487 0d96 8845D4   		movb	%al, -44(%rbp)
 1488              		.loc 3 367 0
 1489 0d99 64488B04 		movq	%fs:40, %rax
 1489      25280000 
 1489      00
 1490 0da2 488945F8 		movq	%rax, -8(%rbp)
 1491 0da6 31C0     		xorl	%eax, %eax
 368:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1492              		.loc 3 368 0
 1493 0da8 C745F000 		movl	$0, -16(%rbp)
 1493      000000
 369:libusbwrap.c  **** 	int numWritten;
 370:libusbwrap.c  **** 	int status = libusb_bulk_transfer(
 1494              		.loc 3 370 0
 1495 0daf 8B4DD0   		movl	-48(%rbp), %ecx
 1496 0db2 0FB675D4 		movzbl	-44(%rbp), %esi
 371:libusbwrap.c  **** 		dev->handle,
 1497              		.loc 3 371 0
 1498 0db6 488B45D8 		movq	-40(%rbp), %rax
 1499 0dba 488B00   		movq	(%rax), %rax
 370:libusbwrap.c  **** 		dev->handle,
 1500              		.loc 3 370 0
 1501 0dbd 448B45C4 		movl	-60(%rbp), %r8d
 1502 0dc1 488D7DEC 		leaq	-20(%rbp), %rdi
 1503 0dc5 488B55C8 		movq	-56(%rbp), %rdx
 1504 0dc9 4589C1   		movl	%r8d, %r9d
 1505 0dcc 4989F8   		movq	%rdi, %r8
 1506 0dcf 4889C7   		movq	%rax, %rdi
 1507 0dd2 E8000000 		call	libusb_bulk_transfer@PLT
 1507      00
 1508 0dd7 8945F4   		movl	%eax, -12(%rbp)
 372:libusbwrap.c  **** 		LIBUSB_ENDPOINT_OUT | endpoint,
 373:libusbwrap.c  **** 		(uint8 *)data,
 374:libusbwrap.c  **** 		(int)count,
 375:libusbwrap.c  **** 		&numWritten,
 376:libusbwrap.c  **** 		timeout
 377:libusbwrap.c  **** 	);
 378:libusbwrap.c  **** 	CHECK_STATUS(
 1509              		.loc 3 378 0
 1510 0dda 837DF4F9 		cmpl	$-7, -12(%rbp)
 1511 0dde 751C     		jne	.L106
 1512              		.loc 3 378 0 is_stmt 0 discriminator 1
 1513 0de0 488B45B8 		movq	-72(%rbp), %rax
 1514 0de4 488D3500 		leaq	.LC19(%rip), %rsi
 1514      000000
 1515 0deb 4889C7   		movq	%rax, %rdi
 1516 0dee E8000000 		call	errPrefix@PLT
 1516      00
 1517 0df3 C745F012 		movl	$18, -16(%rbp)
 1517      000000
 1518 0dfa EB78     		jmp	.L107
 1519              	.L106:
 379:libusbwrap.c  **** 		status == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, cleanup,
 380:libusbwrap.c  **** 		"usbBulkWrite(): Timeout");
 381:libusbwrap.c  **** 	CHECK_STATUS(
 1520              		.loc 3 381 0 is_stmt 1
 1521 0dfc 837DF400 		cmpl	$0, -12(%rbp)
 1522 0e00 792E     		jns	.L108
 1523              		.loc 3 381 0 is_stmt 0 discriminator 1
 1524 0e02 8B45F4   		movl	-12(%rbp), %eax
 1525 0e05 89C7     		movl	%eax, %edi
 1526 0e07 E8000000 		call	libusb_error_name@PLT
 1526      00
 1527 0e0c 4889C2   		movq	%rax, %rdx
 1528 0e0f 488B45B8 		movq	-72(%rbp), %rax
 1529 0e13 488D3500 		leaq	.LC20(%rip), %rsi
 1529      000000
 1530 0e1a 4889C7   		movq	%rax, %rdi
 1531 0e1d B8000000 		movl	$0, %eax
 1531      00
 1532 0e22 E8000000 		call	errRender@PLT
 1532      00
 1533 0e27 C745F00B 		movl	$11, -16(%rbp)
 1533      000000
 1534 0e2e EB44     		jmp	.L107
 1535              	.L108:
 382:libusbwrap.c  **** 		status < 0, USB_BULK, cleanup,
 383:libusbwrap.c  **** 		"usbBulkWrite(): %s", libusb_error_name(status));
 384:libusbwrap.c  **** 	CHECK_STATUS(
 1536              		.loc 3 384 0 is_stmt 1
 1537 0e30 8B45EC   		movl	-20(%rbp), %eax
 1538 0e33 3B45D0   		cmpl	-48(%rbp), %eax
 1539 0e36 743C     		je	.L107
 1540              		.loc 3 384 0 is_stmt 0 discriminator 1
 1541 0e38 8B45F4   		movl	-12(%rbp), %eax
 1542 0e3b 89C7     		movl	%eax, %edi
 1543 0e3d E8000000 		call	libusb_error_name@PLT
 1543      00
 1544 0e42 4889C7   		movq	%rax, %rdi
 1545 0e45 8B4DEC   		movl	-20(%rbp), %ecx
 1546 0e48 8B75F4   		movl	-12(%rbp), %esi
 1547 0e4b 8B55D0   		movl	-48(%rbp), %edx
 1548 0e4e 488B45B8 		movq	-72(%rbp), %rax
 1549 0e52 4989F9   		movq	%rdi, %r9
 1550 0e55 4189F0   		movl	%esi, %r8d
 1551 0e58 488D3500 		leaq	.LC21(%rip), %rsi
 1551      000000
 1552 0e5f 4889C7   		movq	%rax, %rdi
 1553 0e62 B8000000 		movl	$0, %eax
 1553      00
 1554 0e67 E8000000 		call	errRender@PLT
 1554      00
 1555 0e6c C745F00B 		movl	$11, -16(%rbp)
 1555      000000
 1556 0e73 90       		nop
 1557              	.L107:
 385:libusbwrap.c  **** 		(uint32)numWritten != count, USB_BULK, cleanup,
 386:libusbwrap.c  **** 		"usbBulkWrite(): Expected to write %d bytes but actually wrote %d (status = %d): %s",
 387:libusbwrap.c  **** 		count, numWritten, status, libusb_error_name(status));
 388:libusbwrap.c  **** cleanup:
 389:libusbwrap.c  **** 	return retVal;
 1558              		.loc 3 389 0 is_stmt 1
 1559 0e74 8B45F0   		movl	-16(%rbp), %eax
 390:libusbwrap.c  **** }
 1560              		.loc 3 390 0
 1561 0e77 488B4DF8 		movq	-8(%rbp), %rcx
 1562 0e7b 6448330C 		xorq	%fs:40, %rcx
 1562      25280000 
 1562      00
 1563 0e84 7405     		je	.L110
 1564 0e86 E8000000 		call	__stack_chk_fail@PLT
 1564      00
 1565              	.L110:
 1566 0e8b C9       		leave
 1567              		.cfi_def_cfa 7, 8
 1568 0e8c C3       		ret
 1569              		.cfi_endproc
 1570              	.LFE32:
 1573              	bulk_transfer_cb:
 1574              	.LFB33:
 391:libusbwrap.c  **** 
 392:libusbwrap.c  **** static void LIBUSB_CALL bulk_transfer_cb(struct libusb_transfer *transfer) {
 1575              		.loc 3 392 0
 1576              		.cfi_startproc
 1577 0e8d 55       		pushq	%rbp
 1578              		.cfi_def_cfa_offset 16
 1579              		.cfi_offset 6, -16
 1580 0e8e 4889E5   		movq	%rsp, %rbp
 1581              		.cfi_def_cfa_register 6
 1582 0e91 48897DE8 		movq	%rdi, -24(%rbp)
 393:libusbwrap.c  **** 	int *completed = transfer->user_data;
 1583              		.loc 3 393 0
 1584 0e95 488B45E8 		movq	-24(%rbp), %rax
 1585 0e99 488B4028 		movq	40(%rax), %rax
 1586 0e9d 488945F8 		movq	%rax, -8(%rbp)
 394:libusbwrap.c  **** 	*completed = 1;
 1587              		.loc 3 394 0
 1588 0ea1 488B45F8 		movq	-8(%rbp), %rax
 1589 0ea5 C7000100 		movl	$1, (%rax)
 1589      0000
 395:libusbwrap.c  **** }
 1590              		.loc 3 395 0
 1591 0eab 90       		nop
 1592 0eac 5D       		popq	%rbp
 1593              		.cfi_def_cfa 7, 8
 1594 0ead C3       		ret
 1595              		.cfi_endproc
 1596              	.LFE33:
 1598              		.section	.rodata
 1599 03d3 00000000 		.align 8
 1599      00
 1600              	.LC22:
 1601 03d8 75736242 		.string	"usbBulkWriteAsync(): Submission error: %s"
 1601      756C6B57 
 1601      72697465 
 1601      4173796E 
 1601      6328293A 
 1602              		.text
 1603              		.globl	usbBulkWriteAsync
 1605              	usbBulkWriteAsync:
 1606              	.LFB34:
 396:libusbwrap.c  **** 
 397:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsync(
 398:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, const uint8 *buffer, uint32 length, uint32 timeout,
 399:libusbwrap.c  **** 	const char **error)
 400:libusbwrap.c  **** {
 1607              		.loc 3 400 0
 1608              		.cfi_startproc
 1609 0eae 55       		pushq	%rbp
 1610              		.cfi_def_cfa_offset 16
 1611              		.cfi_offset 6, -16
 1612 0eaf 4889E5   		movq	%rsp, %rbp
 1613              		.cfi_def_cfa_register 6
 1614 0eb2 4883EC60 		subq	$96, %rsp
 1615 0eb6 48897DC8 		movq	%rdi, -56(%rbp)
 1616 0eba 89F0     		movl	%esi, %eax
 1617 0ebc 488955B8 		movq	%rdx, -72(%rbp)
 1618 0ec0 894DC0   		movl	%ecx, -64(%rbp)
 1619 0ec3 448945B4 		movl	%r8d, -76(%rbp)
 1620 0ec7 4C894DA8 		movq	%r9, -88(%rbp)
 1621 0ecb 8845C4   		movb	%al, -60(%rbp)
 1622              		.loc 3 400 0
 1623 0ece 64488B04 		movq	%fs:40, %rax
 1623      25280000 
 1623      00
 1624 0ed7 488945F8 		movq	%rax, -8(%rbp)
 1625 0edb 31C0     		xorl	%eax, %eax
 401:libusbwrap.c  **** 	int retVal = USB_SUCCESS;
 1626              		.loc 3 401 0
 1627 0edd C745D400 		movl	$0, -44(%rbp)
 1627      000000
 402:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 403:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 404:libusbwrap.c  **** 	int *completed;
 405:libusbwrap.c  **** 	int iStatus;
 406:libusbwrap.c  **** 	USBStatus uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1628              		.loc 3 406 0
 1629 0ee4 488B45C8 		movq	-56(%rbp), %rax
 1630 0ee8 488D5008 		leaq	8(%rax), %rdx
 1631 0eec 488D45E0 		leaq	-32(%rbp), %rax
 1632 0ef0 4889C6   		movq	%rax, %rsi
 1633 0ef3 4889D7   		movq	%rdx, %rdi
 1634 0ef6 E8000000 		call	queuePut@PLT
 1634      00
 1635 0efb 8945D8   		movl	%eax, -40(%rbp)
 407:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup);
 1636              		.loc 3 407 0
 1637 0efe 837DD800 		cmpl	$0, -40(%rbp)
 1638 0f02 740B     		je	.L113
 1639              		.loc 3 407 0 is_stmt 0 discriminator 1
 1640 0f04 8B45D8   		movl	-40(%rbp), %eax
 1641 0f07 8945D4   		movl	%eax, -44(%rbp)
 1642 0f0a E9BB0000 		jmp	.L114
 1642      00
 1643              	.L113:
 408:libusbwrap.c  **** 	transfer = wrapper->transfer;
 1644              		.loc 3 408 0 is_stmt 1
 1645 0f0f 488B45E0 		movq	-32(%rbp), %rax
 1646 0f13 488B00   		movq	(%rax), %rax
 1647 0f16 488945E8 		movq	%rax, -24(%rbp)
 409:libusbwrap.c  **** 	completed = &wrapper->completed;
 1648              		.loc 3 409 0
 1649 0f1a 488B45E0 		movq	-32(%rbp), %rax
 1650 0f1e 4883C008 		addq	$8, %rax
 1651 0f22 488945F0 		movq	%rax, -16(%rbp)
 410:libusbwrap.c  **** 	*completed = 0;
 1652              		.loc 3 410 0
 1653 0f26 488B45F0 		movq	-16(%rbp), %rax
 1654 0f2a C7000000 		movl	$0, (%rax)
 1654      0000
 411:libusbwrap.c  **** 	wrapper->flags.isRead = 0;
 1655              		.loc 3 411 0
 1656 0f30 488B45E0 		movq	-32(%rbp), %rax
 1657 0f34 0FB6500C 		movzbl	12(%rax), %edx
 1658 0f38 83E2FE   		andl	$-2, %edx
 1659 0f3b 88500C   		movb	%dl, 12(%rax)
 412:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1660              		.loc 3 412 0
 1661 0f3e 448B45C0 		movl	-64(%rbp), %r8d
 1662 0f42 0FB655C4 		movzbl	-60(%rbp), %edx
 413:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_OUT | endpoint, (uint8 *)buffer, (int)length,
 1663              		.loc 3 413 0
 1664 0f46 488B45C8 		movq	-56(%rbp), %rax
 1665 0f4a 488B30   		movq	(%rax), %rsi
 412:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1666              		.loc 3 412 0
 1667 0f4d 488B4DB8 		movq	-72(%rbp), %rcx
 1668 0f51 488B45E8 		movq	-24(%rbp), %rax
 1669 0f55 8B7DB4   		movl	-76(%rbp), %edi
 1670 0f58 57       		pushq	%rdi
 1671 0f59 FF75F0   		pushq	-16(%rbp)
 1672 0f5c 4C8D0D2A 		leaq	bulk_transfer_cb(%rip), %r9
 1672      FFFFFF
 1673 0f63 4889C7   		movq	%rax, %rdi
 1674 0f66 E8A7F0FF 		call	libusb_fill_bulk_transfer
 1674      FF
 1675 0f6b 4883C410 		addq	$16, %rsp
 414:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 415:libusbwrap.c  **** 	);
 416:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 1676              		.loc 3 416 0
 1677 0f6f 488B45E8 		movq	-24(%rbp), %rax
 1678 0f73 C6400A02 		movb	$2, 10(%rax)
 417:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 1679              		.loc 3 417 0
 1680 0f77 488B45E8 		movq	-24(%rbp), %rax
 1681 0f7b 4889C7   		movq	%rax, %rdi
 1682 0f7e E8000000 		call	libusb_submit_transfer@PLT
 1682      00
 1683 0f83 8945DC   		movl	%eax, -36(%rbp)
 418:libusbwrap.c  **** 	CHECK_STATUS(
 1684              		.loc 3 418 0
 1685 0f86 837DDC00 		cmpl	$0, -36(%rbp)
 1686 0f8a 742E     		je	.L115
 1687              		.loc 3 418 0 is_stmt 0 discriminator 1
 1688 0f8c 8B45DC   		movl	-36(%rbp), %eax
 1689 0f8f 89C7     		movl	%eax, %edi
 1690 0f91 E8000000 		call	libusb_error_name@PLT
 1690      00
 1691 0f96 4889C2   		movq	%rax, %rdx
 1692 0f99 488B45A8 		movq	-88(%rbp), %rax
 1693 0f9d 488D3500 		leaq	.LC22(%rip), %rsi
 1693      000000
 1694 0fa4 4889C7   		movq	%rax, %rdi
 1695 0fa7 B8000000 		movl	$0, %eax
 1695      00
 1696 0fac E8000000 		call	errRender@PLT
 1696      00
 1697 0fb1 C745D40E 		movl	$14, -44(%rbp)
 1697      000000
 1698 0fb8 EB10     		jmp	.L114
 1699              	.L115:
 419:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 420:libusbwrap.c  **** 		"usbBulkWriteAsync(): Submission error: %s", libusb_error_name(iStatus)
 421:libusbwrap.c  **** 	);
 422:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 1700              		.loc 3 422 0 is_stmt 1
 1701 0fba 488B45C8 		movq	-56(%rbp), %rax
 1702 0fbe 4883C008 		addq	$8, %rax
 1703 0fc2 4889C7   		movq	%rax, %rdi
 1704 0fc5 E8000000 		call	queueCommitPut@PLT
 1704      00
 1705              	.L114:
 423:libusbwrap.c  **** cleanup:
 424:libusbwrap.c  **** 	return retVal;
 1706              		.loc 3 424 0
 1707 0fca 8B45D4   		movl	-44(%rbp), %eax
 425:libusbwrap.c  **** }
 1708              		.loc 3 425 0
 1709 0fcd 488B4DF8 		movq	-8(%rbp), %rcx
 1710 0fd1 6448330C 		xorq	%fs:40, %rcx
 1710      25280000 
 1710      00
 1711 0fda 7405     		je	.L117
 1712 0fdc E8000000 		call	__stack_chk_fail@PLT
 1712      00
 1713              	.L117:
 1714 0fe1 C9       		leave
 1715              		.cfi_def_cfa 7, 8
 1716 0fe2 C3       		ret
 1717              		.cfi_endproc
 1718              	.LFE34:
 1720              		.section	.rodata
 1721 0402 00000000 		.align 8
 1721      0000
 1722              	.LC23:
 1723 0408 75736242 		.string	"usbBulkWriteAsyncPrepare(): Work queue insertion error"
 1723      756C6B57 
 1723      72697465 
 1723      4173796E 
 1723      63507265 
 1724              		.text
 1725              		.globl	usbBulkWriteAsyncPrepare
 1727              	usbBulkWriteAsyncPrepare:
 1728              	.LFB35:
 426:libusbwrap.c  **** 
 427:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsyncPrepare(
 428:libusbwrap.c  **** 	struct USBDevice *dev, uint8 **buffer, const char **error)
 429:libusbwrap.c  **** {
 1729              		.loc 3 429 0
 1730              		.cfi_startproc
 1731 0fe3 55       		pushq	%rbp
 1732              		.cfi_def_cfa_offset 16
 1733              		.cfi_offset 6, -16
 1734 0fe4 4889E5   		movq	%rsp, %rbp
 1735              		.cfi_def_cfa_register 6
 1736 0fe7 4883EC40 		subq	$64, %rsp
 1737 0feb 48897DD8 		movq	%rdi, -40(%rbp)
 1738 0fef 488975D0 		movq	%rsi, -48(%rbp)
 1739 0ff3 488955C8 		movq	%rdx, -56(%rbp)
 1740              		.loc 3 429 0
 1741 0ff7 64488B04 		movq	%fs:40, %rax
 1741      25280000 
 1741      00
 1742 1000 488945F8 		movq	%rax, -8(%rbp)
 1743 1004 31C0     		xorl	%eax, %eax
 430:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1744              		.loc 3 430 0
 1745 1006 C745E800 		movl	$0, -24(%rbp)
 1745      000000
 431:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 432:libusbwrap.c  **** 	USBStatus status = queuePut(&dev->queue, (Item*)&wrapper);
 1746              		.loc 3 432 0
 1747 100d 488B45D8 		movq	-40(%rbp), %rax
 1748 1011 488D5008 		leaq	8(%rax), %rdx
 1749 1015 488D45F0 		leaq	-16(%rbp), %rax
 1750 1019 4889C6   		movq	%rax, %rsi
 1751 101c 4889D7   		movq	%rdx, %rdi
 1752 101f E8000000 		call	queuePut@PLT
 1752      00
 1753 1024 8945EC   		movl	%eax, -20(%rbp)
 433:libusbwrap.c  **** 	CHECK_STATUS(status, status, cleanup, "usbBulkWriteAsyncPrepare(): Work queue insertion error");
 1754              		.loc 3 433 0
 1755 1027 837DEC00 		cmpl	$0, -20(%rbp)
 1756 102b 741B     		je	.L119
 1757              		.loc 3 433 0 is_stmt 0 discriminator 1
 1758 102d 488B45C8 		movq	-56(%rbp), %rax
 1759 1031 488D3500 		leaq	.LC23(%rip), %rsi
 1759      000000
 1760 1038 4889C7   		movq	%rax, %rdi
 1761 103b E8000000 		call	errPrefix@PLT
 1761      00
 1762 1040 8B45EC   		movl	-20(%rbp), %eax
 1763 1043 8945E8   		movl	%eax, -24(%rbp)
 1764 1046 EB0F     		jmp	.L120
 1765              	.L119:
 434:libusbwrap.c  **** 	*buffer = wrapper->buffer;
 1766              		.loc 3 434 0 is_stmt 1
 1767 1048 488B45F0 		movq	-16(%rbp), %rax
 1768 104c 488D5010 		leaq	16(%rax), %rdx
 1769 1050 488B45D0 		movq	-48(%rbp), %rax
 1770 1054 488910   		movq	%rdx, (%rax)
 1771              	.L120:
 435:libusbwrap.c  **** cleanup:
 436:libusbwrap.c  **** 	return retVal;
 1772              		.loc 3 436 0
 1773 1057 8B45E8   		movl	-24(%rbp), %eax
 437:libusbwrap.c  **** }
 1774              		.loc 3 437 0
 1775 105a 488B4DF8 		movq	-8(%rbp), %rcx
 1776 105e 6448330C 		xorq	%fs:40, %rcx
 1776      25280000 
 1776      00
 1777 1067 7405     		je	.L122
 1778 1069 E8000000 		call	__stack_chk_fail@PLT
 1778      00
 1779              	.L122:
 1780 106e C9       		leave
 1781              		.cfi_def_cfa 7, 8
 1782 106f C3       		ret
 1783              		.cfi_endproc
 1784              	.LFE35:
 1786              		.section	.rodata
 1787 043f 00       		.align 8
 1788              	.LC24:
 1789 0440 75736242 		.string	"usbBulkWriteAsyncSubmit(): Transfer length exceeds 0x10000"
 1789      756C6B57 
 1789      72697465 
 1789      4173796E 
 1789      63537562 
 1790 047b 00000000 		.align 8
 1790      00
 1791              	.LC25:
 1792 0480 75736242 		.string	"usbBulkWriteAsyncSubmit(): Work queue insertion error"
 1792      756C6B57 
 1792      72697465 
 1792      4173796E 
 1792      63537562 
 1793 04b6 0000     		.align 8
 1794              	.LC26:
 1795 04b8 75736242 		.string	"usbBulkWriteAsyncSubmit(): Submission error: %s"
 1795      756C6B57 
 1795      72697465 
 1795      4173796E 
 1795      63537562 
 1796              		.text
 1797              		.globl	usbBulkWriteAsyncSubmit
 1799              	usbBulkWriteAsyncSubmit:
 1800              	.LFB36:
 438:libusbwrap.c  **** 
 439:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkWriteAsyncSubmit(
 440:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint32 length, uint32 timeout, const char **error)
 441:libusbwrap.c  **** {
 1801              		.loc 3 441 0
 1802              		.cfi_startproc
 1803 1070 55       		pushq	%rbp
 1804              		.cfi_def_cfa_offset 16
 1805              		.cfi_offset 6, -16
 1806 1071 4889E5   		movq	%rsp, %rbp
 1807              		.cfi_def_cfa_register 6
 1808 1074 4883EC50 		subq	$80, %rsp
 1809 1078 48897DC8 		movq	%rdi, -56(%rbp)
 1810 107c 89F0     		movl	%esi, %eax
 1811 107e 8955C0   		movl	%edx, -64(%rbp)
 1812 1081 894DBC   		movl	%ecx, -68(%rbp)
 1813 1084 4C8945B0 		movq	%r8, -80(%rbp)
 1814 1088 8845C4   		movb	%al, -60(%rbp)
 1815              		.loc 3 441 0
 1816 108b 64488B04 		movq	%fs:40, %rax
 1816      25280000 
 1816      00
 1817 1094 488945F8 		movq	%rax, -8(%rbp)
 1818 1098 31C0     		xorl	%eax, %eax
 442:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1819              		.loc 3 442 0
 1820 109a C745D400 		movl	$0, -44(%rbp)
 1820      000000
 443:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 444:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 445:libusbwrap.c  **** 	int *completed;
 446:libusbwrap.c  **** 	USBStatus uStatus;
 447:libusbwrap.c  **** 	int iStatus;
 448:libusbwrap.c  **** 	CHECK_STATUS(
 1821              		.loc 3 448 0
 1822 10a1 817DC000 		cmpl	$65536, -64(%rbp)
 1822      000100
 1823 10a8 761F     		jbe	.L124
 1824              		.loc 3 448 0 is_stmt 0 discriminator 1
 1825 10aa 488B45B0 		movq	-80(%rbp), %rax
 1826 10ae 488D3500 		leaq	.LC24(%rip), %rsi
 1826      000000
 1827 10b5 4889C7   		movq	%rax, %rdi
 1828 10b8 E8000000 		call	errPrefix@PLT
 1828      00
 1829 10bd C745D411 		movl	$17, -44(%rbp)
 1829      000000
 1830 10c4 E9000100 		jmp	.L125
 1830      00
 1831              	.L124:
 449:libusbwrap.c  **** 		length > 0x10000, USB_ASYNC_SIZE, cleanup,
 450:libusbwrap.c  **** 		"usbBulkWriteAsyncSubmit(): Transfer length exceeds 0x10000");
 451:libusbwrap.c  **** 	uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1832              		.loc 3 451 0 is_stmt 1
 1833 10c9 488B45C8 		movq	-56(%rbp), %rax
 1834 10cd 488D5008 		leaq	8(%rax), %rdx
 1835 10d1 488D45E0 		leaq	-32(%rbp), %rax
 1836 10d5 4889C6   		movq	%rax, %rsi
 1837 10d8 4889D7   		movq	%rdx, %rdi
 1838 10db E8000000 		call	queuePut@PLT
 1838      00
 1839 10e0 8945D8   		movl	%eax, -40(%rbp)
 452:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup, "usbBulkWriteAsyncSubmit(): Work queue insertion error");
 1840              		.loc 3 452 0
 1841 10e3 837DD800 		cmpl	$0, -40(%rbp)
 1842 10e7 741E     		je	.L126
 1843              		.loc 3 452 0 is_stmt 0 discriminator 1
 1844 10e9 488B45B0 		movq	-80(%rbp), %rax
 1845 10ed 488D3500 		leaq	.LC25(%rip), %rsi
 1845      000000
 1846 10f4 4889C7   		movq	%rax, %rdi
 1847 10f7 E8000000 		call	errPrefix@PLT
 1847      00
 1848 10fc 8B45D8   		movl	-40(%rbp), %eax
 1849 10ff 8945D4   		movl	%eax, -44(%rbp)
 1850 1102 E9C20000 		jmp	.L125
 1850      00
 1851              	.L126:
 453:libusbwrap.c  **** 	transfer = wrapper->transfer;
 1852              		.loc 3 453 0 is_stmt 1
 1853 1107 488B45E0 		movq	-32(%rbp), %rax
 1854 110b 488B00   		movq	(%rax), %rax
 1855 110e 488945E8 		movq	%rax, -24(%rbp)
 454:libusbwrap.c  **** 	completed = &wrapper->completed;
 1856              		.loc 3 454 0
 1857 1112 488B45E0 		movq	-32(%rbp), %rax
 1858 1116 4883C008 		addq	$8, %rax
 1859 111a 488945F0 		movq	%rax, -16(%rbp)
 455:libusbwrap.c  **** 	*completed = 0;
 1860              		.loc 3 455 0
 1861 111e 488B45F0 		movq	-16(%rbp), %rax
 1862 1122 C7000000 		movl	$0, (%rax)
 1862      0000
 456:libusbwrap.c  **** 	wrapper->flags.isRead = 0;
 1863              		.loc 3 456 0
 1864 1128 488B45E0 		movq	-32(%rbp), %rax
 1865 112c 0FB6500C 		movzbl	12(%rax), %edx
 1866 1130 83E2FE   		andl	$-2, %edx
 1867 1133 88500C   		movb	%dl, 12(%rax)
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1868              		.loc 3 457 0
 1869 1136 448B45C0 		movl	-64(%rbp), %r8d
 458:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_OUT | endpoint, wrapper->buffer, (int)length,
 1870              		.loc 3 458 0
 1871 113a 488B45E0 		movq	-32(%rbp), %rax
 1872 113e 488D7810 		leaq	16(%rax), %rdi
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1873              		.loc 3 457 0
 1874 1142 0FB655C4 		movzbl	-60(%rbp), %edx
 1875              		.loc 3 458 0
 1876 1146 488B45C8 		movq	-56(%rbp), %rax
 1877 114a 488B30   		movq	(%rax), %rsi
 457:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 1878              		.loc 3 457 0
 1879 114d 488B45E8 		movq	-24(%rbp), %rax
 1880 1151 8B4DBC   		movl	-68(%rbp), %ecx
 1881 1154 51       		pushq	%rcx
 1882 1155 FF75F0   		pushq	-16(%rbp)
 1883 1158 4C8D0D2E 		leaq	bulk_transfer_cb(%rip), %r9
 1883      FDFFFF
 1884 115f 4889F9   		movq	%rdi, %rcx
 1885 1162 4889C7   		movq	%rax, %rdi
 1886 1165 E8A8EEFF 		call	libusb_fill_bulk_transfer
 1886      FF
 1887 116a 4883C410 		addq	$16, %rsp
 459:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 460:libusbwrap.c  **** 	);
 461:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 1888              		.loc 3 461 0
 1889 116e 488B45E8 		movq	-24(%rbp), %rax
 1890 1172 C6400A02 		movb	$2, 10(%rax)
 462:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 1891              		.loc 3 462 0
 1892 1176 488B45E8 		movq	-24(%rbp), %rax
 1893 117a 4889C7   		movq	%rax, %rdi
 1894 117d E8000000 		call	libusb_submit_transfer@PLT
 1894      00
 1895 1182 8945DC   		movl	%eax, -36(%rbp)
 463:libusbwrap.c  **** 	CHECK_STATUS(
 1896              		.loc 3 463 0
 1897 1185 837DDC00 		cmpl	$0, -36(%rbp)
 1898 1189 742E     		je	.L127
 1899              		.loc 3 463 0 is_stmt 0 discriminator 1
 1900 118b 8B45DC   		movl	-36(%rbp), %eax
 1901 118e 89C7     		movl	%eax, %edi
 1902 1190 E8000000 		call	libusb_error_name@PLT
 1902      00
 1903 1195 4889C2   		movq	%rax, %rdx
 1904 1198 488B45B0 		movq	-80(%rbp), %rax
 1905 119c 488D3500 		leaq	.LC26(%rip), %rsi
 1905      000000
 1906 11a3 4889C7   		movq	%rax, %rdi
 1907 11a6 B8000000 		movl	$0, %eax
 1907      00
 1908 11ab E8000000 		call	errRender@PLT
 1908      00
 1909 11b0 C745D40E 		movl	$14, -44(%rbp)
 1909      000000
 1910 11b7 EB10     		jmp	.L125
 1911              	.L127:
 464:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 465:libusbwrap.c  **** 		"usbBulkWriteAsyncSubmit(): Submission error: %s", libusb_error_name(iStatus));
 466:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 1912              		.loc 3 466 0 is_stmt 1
 1913 11b9 488B45C8 		movq	-56(%rbp), %rax
 1914 11bd 4883C008 		addq	$8, %rax
 1915 11c1 4889C7   		movq	%rax, %rdi
 1916 11c4 E8000000 		call	queueCommitPut@PLT
 1916      00
 1917              	.L125:
 467:libusbwrap.c  **** cleanup:
 468:libusbwrap.c  **** 	return retVal;
 1918              		.loc 3 468 0
 1919 11c9 8B45D4   		movl	-44(%rbp), %eax
 469:libusbwrap.c  **** }
 1920              		.loc 3 469 0
 1921 11cc 488B4DF8 		movq	-8(%rbp), %rcx
 1922 11d0 6448330C 		xorq	%fs:40, %rcx
 1922      25280000 
 1922      00
 1923 11d9 7405     		je	.L129
 1924 11db E8000000 		call	__stack_chk_fail@PLT
 1924      00
 1925              	.L129:
 1926 11e0 C9       		leave
 1927              		.cfi_def_cfa 7, 8
 1928 11e1 C3       		ret
 1929              		.cfi_endproc
 1930              	.LFE36:
 1932              		.section	.rodata
 1933              		.align 8
 1934              	.LC27:
 1935 04e8 75736242 		.string	"usbBulkReadAsync(): Transfer length exceeds 0x10000"
 1935      756C6B52 
 1935      65616441 
 1935      73796E63 
 1935      28293A20 
 1936 051c 00000000 		.align 8
 1937              	.LC28:
 1938 0520 75736242 		.string	"usbBulkReadAsync(): Work queue insertion error"
 1938      756C6B52 
 1938      65616441 
 1938      73796E63 
 1938      28293A20 
 1939 054f 00       		.align 8
 1940              	.LC29:
 1941 0550 75736242 		.string	"usbBulkReadAsync(): Submission error: %s"
 1941      756C6B52 
 1941      65616441 
 1941      73796E63 
 1941      28293A20 
 1942              		.text
 1943              		.globl	usbBulkReadAsync
 1945              	usbBulkReadAsync:
 1946              	.LFB37:
 470:libusbwrap.c  **** 
 471:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkReadAsync(
 472:libusbwrap.c  **** 	struct USBDevice *dev, uint8 endpoint, uint8 *buffer, uint32 length, uint32 timeout, const char **
 473:libusbwrap.c  **** {
 1947              		.loc 3 473 0
 1948              		.cfi_startproc
 1949 11e2 55       		pushq	%rbp
 1950              		.cfi_def_cfa_offset 16
 1951              		.cfi_offset 6, -16
 1952 11e3 4889E5   		movq	%rsp, %rbp
 1953              		.cfi_def_cfa_register 6
 1954 11e6 4883EC60 		subq	$96, %rsp
 1955 11ea 48897DC8 		movq	%rdi, -56(%rbp)
 1956 11ee 89F0     		movl	%esi, %eax
 1957 11f0 488955B8 		movq	%rdx, -72(%rbp)
 1958 11f4 894DC0   		movl	%ecx, -64(%rbp)
 1959 11f7 448945B4 		movl	%r8d, -76(%rbp)
 1960 11fb 4C894DA8 		movq	%r9, -88(%rbp)
 1961 11ff 8845C4   		movb	%al, -60(%rbp)
 1962              		.loc 3 473 0
 1963 1202 64488B04 		movq	%fs:40, %rax
 1963      25280000 
 1963      00
 1964 120b 488945F8 		movq	%rax, -8(%rbp)
 1965 120f 31C0     		xorl	%eax, %eax
 474:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 1966              		.loc 3 474 0
 1967 1211 C745D400 		movl	$0, -44(%rbp)
 1967      000000
 475:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 476:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 477:libusbwrap.c  **** 	int *completed;
 478:libusbwrap.c  **** 	USBStatus uStatus;
 479:libusbwrap.c  **** 	int iStatus;
 480:libusbwrap.c  **** 	CHECK_STATUS(
 1968              		.loc 3 480 0
 1969 1218 817DC000 		cmpl	$65536, -64(%rbp)
 1969      000100
 1970 121f 761F     		jbe	.L131
 1971              		.loc 3 480 0 is_stmt 0 discriminator 1
 1972 1221 488B45A8 		movq	-88(%rbp), %rax
 1973 1225 488D3500 		leaq	.LC27(%rip), %rsi
 1973      000000
 1974 122c 4889C7   		movq	%rax, %rdi
 1975 122f E8000000 		call	errPrefix@PLT
 1975      00
 1976 1234 C745D411 		movl	$17, -44(%rbp)
 1976      000000
 1977 123b E9230100 		jmp	.L132
 1977      00
 1978              	.L131:
 481:libusbwrap.c  **** 		length > 0x10000, USB_ASYNC_SIZE, cleanup,
 482:libusbwrap.c  **** 		"usbBulkReadAsync(): Transfer length exceeds 0x10000");
 483:libusbwrap.c  **** 	uStatus = queuePut(&dev->queue, (Item*)&wrapper);
 1979              		.loc 3 483 0 is_stmt 1
 1980 1240 488B45C8 		movq	-56(%rbp), %rax
 1981 1244 488D5008 		leaq	8(%rax), %rdx
 1982 1248 488D45E0 		leaq	-32(%rbp), %rax
 1983 124c 4889C6   		movq	%rax, %rsi
 1984 124f 4889D7   		movq	%rdx, %rdi
 1985 1252 E8000000 		call	queuePut@PLT
 1985      00
 1986 1257 8945D8   		movl	%eax, -40(%rbp)
 484:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, cleanup, "usbBulkReadAsync(): Work queue insertion error");
 1987              		.loc 3 484 0
 1988 125a 837DD800 		cmpl	$0, -40(%rbp)
 1989 125e 741E     		je	.L133
 1990              		.loc 3 484 0 is_stmt 0 discriminator 1
 1991 1260 488B45A8 		movq	-88(%rbp), %rax
 1992 1264 488D3500 		leaq	.LC28(%rip), %rsi
 1992      000000
 1993 126b 4889C7   		movq	%rax, %rdi
 1994 126e E8000000 		call	errPrefix@PLT
 1994      00
 1995 1273 8B45D8   		movl	-40(%rbp), %eax
 1996 1276 8945D4   		movl	%eax, -44(%rbp)
 1997 1279 E9E50000 		jmp	.L132
 1997      00
 1998              	.L133:
 485:libusbwrap.c  **** 	transfer = wrapper->transfer;
 1999              		.loc 3 485 0 is_stmt 1
 2000 127e 488B45E0 		movq	-32(%rbp), %rax
 2001 1282 488B00   		movq	(%rax), %rax
 2002 1285 488945E8 		movq	%rax, -24(%rbp)
 486:libusbwrap.c  **** 	completed = &wrapper->completed;
 2003              		.loc 3 486 0
 2004 1289 488B45E0 		movq	-32(%rbp), %rax
 2005 128d 4883C008 		addq	$8, %rax
 2006 1291 488945F0 		movq	%rax, -16(%rbp)
 487:libusbwrap.c  **** 	*completed = 0;
 2007              		.loc 3 487 0
 2008 1295 488B45F0 		movq	-16(%rbp), %rax
 2009 1299 C7000000 		movl	$0, (%rax)
 2009      0000
 488:libusbwrap.c  **** 	wrapper->flags.isRead = 1;
 2010              		.loc 3 488 0
 2011 129f 488B45E0 		movq	-32(%rbp), %rax
 2012 12a3 0FB6500C 		movzbl	12(%rax), %edx
 2013 12a7 83CA01   		orl	$1, %edx
 2014 12aa 88500C   		movb	%dl, 12(%rax)
 489:libusbwrap.c  **** 	if ( buffer ) {
 2015              		.loc 3 489 0
 2016 12ad 48837DB8 		cmpq	$0, -72(%rbp)
 2016      00
 2017 12b2 7411     		je	.L134
 490:libusbwrap.c  **** 		wrapper->bufPtr = buffer;
 2018              		.loc 3 490 0
 2019 12b4 488B45E0 		movq	-32(%rbp), %rax
 2020 12b8 488B55B8 		movq	-72(%rbp), %rdx
 2021 12bc 48899010 		movq	%rdx, 65552(%rax)
 2021      000100
 2022 12c3 EB0C     		jmp	.L135
 2023              	.L134:
 491:libusbwrap.c  **** 	} else {
 492:libusbwrap.c  **** 		buffer = wrapper->buffer;
 2024              		.loc 3 492 0
 2025 12c5 488B45E0 		movq	-32(%rbp), %rax
 2026 12c9 4883C010 		addq	$16, %rax
 2027 12cd 488945B8 		movq	%rax, -72(%rbp)
 2028              	.L135:
 493:libusbwrap.c  **** 	}
 494:libusbwrap.c  **** 	libusb_fill_bulk_transfer(
 2029              		.loc 3 494 0
 2030 12d1 448B45C0 		movl	-64(%rbp), %r8d
 2031 12d5 0FB645C4 		movzbl	-60(%rbp), %eax
 2032 12d9 83C880   		orl	$-128, %eax
 2033 12dc 0FB6D0   		movzbl	%al, %edx
 495:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_IN | endpoint, buffer, (int)length,
 2034              		.loc 3 495 0
 2035 12df 488B45C8 		movq	-56(%rbp), %rax
 2036 12e3 488B30   		movq	(%rax), %rsi
 494:libusbwrap.c  **** 		transfer, dev->handle, LIBUSB_ENDPOINT_IN | endpoint, buffer, (int)length,
 2037              		.loc 3 494 0
 2038 12e6 488B4DB8 		movq	-72(%rbp), %rcx
 2039 12ea 488B45E8 		movq	-24(%rbp), %rax
 2040 12ee 8B7DB4   		movl	-76(%rbp), %edi
 2041 12f1 57       		pushq	%rdi
 2042 12f2 FF75F0   		pushq	-16(%rbp)
 2043 12f5 4C8D0D91 		leaq	bulk_transfer_cb(%rip), %r9
 2043      FBFFFF
 2044 12fc 4889C7   		movq	%rax, %rdi
 2045 12ff E80EEDFF 		call	libusb_fill_bulk_transfer
 2045      FF
 2046 1304 4883C410 		addq	$16, %rsp
 496:libusbwrap.c  **** 		bulk_transfer_cb, completed, timeout
 497:libusbwrap.c  **** 	);
 498:libusbwrap.c  **** 	transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 2047              		.loc 3 498 0
 2048 1308 488B45E8 		movq	-24(%rbp), %rax
 2049 130c C6400A02 		movb	$2, 10(%rax)
 499:libusbwrap.c  **** 	iStatus = libusb_submit_transfer(transfer);
 2050              		.loc 3 499 0
 2051 1310 488B45E8 		movq	-24(%rbp), %rax
 2052 1314 4889C7   		movq	%rax, %rdi
 2053 1317 E8000000 		call	libusb_submit_transfer@PLT
 2053      00
 2054 131c 8945DC   		movl	%eax, -36(%rbp)
 500:libusbwrap.c  **** 	CHECK_STATUS(
 2055              		.loc 3 500 0
 2056 131f 837DDC00 		cmpl	$0, -36(%rbp)
 2057 1323 742E     		je	.L136
 2058              		.loc 3 500 0 is_stmt 0 discriminator 1
 2059 1325 8B45DC   		movl	-36(%rbp), %eax
 2060 1328 89C7     		movl	%eax, %edi
 2061 132a E8000000 		call	libusb_error_name@PLT
 2061      00
 2062 132f 4889C2   		movq	%rax, %rdx
 2063 1332 488B45A8 		movq	-88(%rbp), %rax
 2064 1336 488D3500 		leaq	.LC29(%rip), %rsi
 2064      000000
 2065 133d 4889C7   		movq	%rax, %rdi
 2066 1340 B8000000 		movl	$0, %eax
 2066      00
 2067 1345 E8000000 		call	errRender@PLT
 2067      00
 2068 134a C745D40E 		movl	$14, -44(%rbp)
 2068      000000
 2069 1351 EB10     		jmp	.L132
 2070              	.L136:
 501:libusbwrap.c  **** 		iStatus, USB_ASYNC_SUBMIT, cleanup,
 502:libusbwrap.c  **** 		"usbBulkReadAsync(): Submission error: %s", libusb_error_name(iStatus));
 503:libusbwrap.c  **** 	queueCommitPut(&dev->queue);
 2071              		.loc 3 503 0 is_stmt 1
 2072 1353 488B45C8 		movq	-56(%rbp), %rax
 2073 1357 4883C008 		addq	$8, %rax
 2074 135b 4889C7   		movq	%rax, %rdi
 2075 135e E8000000 		call	queueCommitPut@PLT
 2075      00
 2076              	.L132:
 504:libusbwrap.c  **** cleanup:
 505:libusbwrap.c  **** 	return retVal;
 2077              		.loc 3 505 0
 2078 1363 8B45D4   		movl	-44(%rbp), %eax
 506:libusbwrap.c  **** }
 2079              		.loc 3 506 0
 2080 1366 488B4DF8 		movq	-8(%rbp), %rcx
 2081 136a 6448330C 		xorq	%fs:40, %rcx
 2081      25280000 
 2081      00
 2082 1373 7405     		je	.L138
 2083 1375 E8000000 		call	__stack_chk_fail@PLT
 2083      00
 2084              	.L138:
 2085 137a C9       		leave
 2086              		.cfi_def_cfa 7, 8
 2087 137b C3       		ret
 2088              		.cfi_endproc
 2089              	.LFE37:
 2091              		.section	.rodata
 2092 0579 00000000 		.align 8
 2092      000000
 2093              	.LC30:
 2094 0580 75736242 		.string	"usbBulkAwaitCompletion(): Work queue fetch error"
 2094      756C6B41 
 2094      77616974 
 2094      436F6D70 
 2094      6C657469 
 2095 05b1 00000000 		.align 8
 2095      000000
 2096              	.LC31:
 2097 05b8 75736242 		.string	"usbBulkAwaitCompletion(): Event error: %s"
 2097      756C6B41 
 2097      77616974 
 2097      436F6D70 
 2097      6C657469 
 2098 05e2 00000000 		.align 8
 2098      0000
 2099              	.LC32:
 2100 05e8 75736242 		.string	"usbBulkAwaitCompletion(): Timeout"
 2100      756C6B41 
 2100      77616974 
 2100      436F6D70 
 2100      6C657469 
 2101 060a 00000000 		.align 8
 2101      0000
 2102              	.LC33:
 2103 0610 75736242 		.string	"usbBulkAwaitCompletion(): Transfer error: %s"
 2103      756C6B41 
 2103      77616974 
 2103      436F6D70 
 2103      6C657469 
 2104              		.text
 2105              		.globl	usbBulkAwaitCompletion
 2107              	usbBulkAwaitCompletion:
 2108              	.LFB38:
 507:libusbwrap.c  **** 
 508:libusbwrap.c  **** DLLEXPORT(USBStatus) usbBulkAwaitCompletion(
 509:libusbwrap.c  **** 	struct USBDevice *dev, struct CompletionReport *report, const char **error)
 510:libusbwrap.c  **** {
 2109              		.loc 3 510 0
 2110              		.cfi_startproc
 2111 137c 55       		pushq	%rbp
 2112              		.cfi_def_cfa_offset 16
 2113              		.cfi_offset 6, -16
 2114 137d 4889E5   		movq	%rsp, %rbp
 2115              		.cfi_def_cfa_register 6
 2116 1380 4883EC70 		subq	$112, %rsp
 2117 1384 48897DA8 		movq	%rdi, -88(%rbp)
 2118 1388 488975A0 		movq	%rsi, -96(%rbp)
 2119 138c 48895598 		movq	%rdx, -104(%rbp)
 2120              		.loc 3 510 0
 2121 1390 64488B04 		movq	%fs:40, %rax
 2121      25280000 
 2121      00
 2122 1399 488945F8 		movq	%rax, -8(%rbp)
 2123 139d 31C0     		xorl	%eax, %eax
 511:libusbwrap.c  **** 	USBStatus retVal = USB_SUCCESS;
 2124              		.loc 3 511 0
 2125 139f C745BC00 		movl	$0, -68(%rbp)
 2125      000000
 512:libusbwrap.c  **** 	struct TransferWrapper *wrapper;
 513:libusbwrap.c  **** 	struct libusb_transfer *transfer;
 514:libusbwrap.c  **** 	int *completed;
 515:libusbwrap.c  **** 	int iStatus;
 516:libusbwrap.c  **** 	struct timeval timeout = {UINT_MAX/1000, 1000*(UINT_MAX%1000)};
 2126              		.loc 3 516 0
 2127 13a6 48C745E0 		movq	$4294967, -32(%rbp)
 2127      37894100 
 2128 13ae 48C745E8 		movq	$295000, -24(%rbp)
 2128      58800400 
 517:libusbwrap.c  **** 	                         // This horrible thing should boil down to a call to poll() with
 518:libusbwrap.c  **** 	                         // timeout -1ms, which will be interpreted as "no timeout" on all
 519:libusbwrap.c  **** 	                         // platforms.
 520:libusbwrap.c  **** 	USBStatus uStatus = queueTake(&dev->queue, (Item*)&wrapper);
 2129              		.loc 3 520 0
 2130 13b6 488B45A8 		movq	-88(%rbp), %rax
 2131 13ba 488D5008 		leaq	8(%rax), %rdx
 2132 13be 488D45C8 		leaq	-56(%rbp), %rax
 2133 13c2 4889C6   		movq	%rax, %rsi
 2134 13c5 4889D7   		movq	%rdx, %rdi
 2135 13c8 E8000000 		call	queueTake@PLT
 2135      00
 2136 13cd 8945C4   		movl	%eax, -60(%rbp)
 521:libusbwrap.c  **** 	CHECK_STATUS(uStatus, uStatus, exit, "usbBulkAwaitCompletion(): Work queue fetch error");
 2137              		.loc 3 521 0
 2138 13d0 837DC400 		cmpl	$0, -60(%rbp)
 2139 13d4 741E     		je	.L140
 2140              		.loc 3 521 0 is_stmt 0 discriminator 1
 2141 13d6 488B4598 		movq	-104(%rbp), %rax
 2142 13da 488D3500 		leaq	.LC30(%rip), %rsi
 2142      000000
 2143 13e1 4889C7   		movq	%rax, %rdi
 2144 13e4 E8000000 		call	errPrefix@PLT
 2144      00
 2145 13e9 8B45C4   		movl	-60(%rbp), %eax
 2146 13ec 8945BC   		movl	%eax, -68(%rbp)
 2147 13ef E9E00100 		jmp	.L141
 2147      00
 2148              	.L140:
 522:libusbwrap.c  **** 	transfer = wrapper->transfer;
 2149              		.loc 3 522 0 is_stmt 1
 2150 13f4 488B45C8 		movq	-56(%rbp), %rax
 2151 13f8 488B00   		movq	(%rax), %rax
 2152 13fb 488945D0 		movq	%rax, -48(%rbp)
 523:libusbwrap.c  **** 	completed = &wrapper->completed;
 2153              		.loc 3 523 0
 2154 13ff 488B45C8 		movq	-56(%rbp), %rax
 2155 1403 4883C008 		addq	$8, %rax
 2156 1407 488945D8 		movq	%rax, -40(%rbp)
 524:libusbwrap.c  **** 	wrapper->bufPtr = NULL;
 2157              		.loc 3 524 0
 2158 140b 488B45C8 		movq	-56(%rbp), %rax
 2159 140f 48C78010 		movq	$0, 65552(%rax)
 2159      00010000 
 2159      000000
 525:libusbwrap.c  **** 	while ( *completed == 0 ) {
 2160              		.loc 3 525 0
 2161 141a E9990000 		jmp	.L142
 2161      00
 2162              	.L148:
 526:libusbwrap.c  **** 		iStatus = libusb_handle_events_timeout_completed(m_ctx, &timeout, completed);
 2163              		.loc 3 526 0
 2164 141f 488B0500 		movq	m_ctx(%rip), %rax
 2164      000000
 2165 1426 488B55D8 		movq	-40(%rbp), %rdx
 2166 142a 488D4DE0 		leaq	-32(%rbp), %rcx
 2167 142e 4889CE   		movq	%rcx, %rsi
 2168 1431 4889C7   		movq	%rax, %rdi
 2169 1434 E8000000 		call	libusb_handle_events_timeout_completed@PLT
 2169      00
 2170 1439 8945C0   		movl	%eax, -64(%rbp)
 527:libusbwrap.c  **** 		if ( iStatus < 0 ) {
 2171              		.loc 3 527 0
 2172 143c 837DC000 		cmpl	$0, -64(%rbp)
 2173 1440 7976     		jns	.L142
 528:libusbwrap.c  **** 			if ( iStatus == LIBUSB_ERROR_INTERRUPTED ) {
 2174              		.loc 3 528 0
 2175 1442 837DC0F6 		cmpl	$-10, -64(%rbp)
 2176 1446 7502     		jne	.L143
 529:libusbwrap.c  **** 				continue;
 2177              		.loc 3 529 0
 2178 1448 EB6E     		jmp	.L142
 2179              	.L143:
 530:libusbwrap.c  **** 			}
 531:libusbwrap.c  **** 			if ( libusb_cancel_transfer(transfer) == LIBUSB_SUCCESS ) {
 2180              		.loc 3 531 0
 2181 144a 488B45D0 		movq	-48(%rbp), %rax
 2182 144e 4889C7   		movq	%rax, %rdi
 2183 1451 E8000000 		call	libusb_cancel_transfer@PLT
 2183      00
 2184 1456 85C0     		testl	%eax, %eax
 2185 1458 752D     		jne	.L161
 532:libusbwrap.c  **** 				while ( *completed == 0 ) {
 2186              		.loc 3 532 0
 2187 145a EB1E     		jmp	.L145
 2188              	.L146:
 533:libusbwrap.c  **** 					if ( libusb_handle_events_timeout_completed(m_ctx, &timeout, completed) < 0 ) {
 2189              		.loc 3 533 0
 2190 145c 488B0500 		movq	m_ctx(%rip), %rax
 2190      000000
 2191 1463 488B55D8 		movq	-40(%rbp), %rdx
 2192 1467 488D4DE0 		leaq	-32(%rbp), %rcx
 2193 146b 4889CE   		movq	%rcx, %rsi
 2194 146e 4889C7   		movq	%rax, %rdi
 2195 1471 E8000000 		call	libusb_handle_events_timeout_completed@PLT
 2195      00
 2196 1476 85C0     		testl	%eax, %eax
 2197 1478 780C     		js	.L162
 2198              	.L145:
 532:libusbwrap.c  **** 				while ( *completed == 0 ) {
 2199              		.loc 3 532 0
 2200 147a 488B45D8 		movq	-40(%rbp), %rax
 2201 147e 8B00     		movl	(%rax), %eax
 2202 1480 85C0     		testl	%eax, %eax
 2203 1482 74D8     		je	.L146
 2204 1484 EB01     		jmp	.L161
 2205              	.L162:
 534:libusbwrap.c  **** 						break;
 2206              		.loc 3 534 0
 2207 1486 90       		nop
 2208              	.L161:
 535:libusbwrap.c  **** 					}
 536:libusbwrap.c  **** 				}
 537:libusbwrap.c  **** 			}
 538:libusbwrap.c  **** 			CHECK_STATUS(
 2209              		.loc 3 538 0 discriminator 1
 2210 1487 8B45C0   		movl	-64(%rbp), %eax
 2211 148a 89C7     		movl	%eax, %edi
 2212 148c E8000000 		call	libusb_error_name@PLT
 2212      00
 2213 1491 4889C2   		movq	%rax, %rdx
 2214 1494 488B4598 		movq	-104(%rbp), %rax
 2215 1498 488D3500 		leaq	.LC31(%rip), %rsi
 2215      000000
 2216 149f 4889C7   		movq	%rax, %rdi
 2217 14a2 B8000000 		movl	$0, %eax
 2217      00
 2218 14a7 E8000000 		call	errRender@PLT
 2218      00
 2219 14ac C745BC0F 		movl	$15, -68(%rbp)
 2219      000000
 2220 14b3 E90C0100 		jmp	.L147
 2220      00
 2221              	.L142:
 525:libusbwrap.c  **** 		iStatus = libusb_handle_events_timeout_completed(m_ctx, &timeout, completed);
 2222              		.loc 3 525 0
 2223 14b8 488B45D8 		movq	-40(%rbp), %rax
 2224 14bc 8B00     		movl	(%rax), %eax
 2225 14be 85C0     		testl	%eax, %eax
 2226 14c0 0F8459FF 		je	.L148
 2226      FFFF
 539:libusbwrap.c  **** 				true, USB_ASYNC_EVENT, commit,
 540:libusbwrap.c  **** 				"usbBulkAwaitCompletion(): Event error: %s", libusb_error_name(iStatus));
 541:libusbwrap.c  **** 		}
 542:libusbwrap.c  **** 	}
 543:libusbwrap.c  **** 
 544:libusbwrap.c  **** 	report->buffer = transfer->buffer;
 2227              		.loc 3 544 0
 2228 14c6 488B45D0 		movq	-48(%rbp), %rax
 2229 14ca 488B5030 		movq	48(%rax), %rdx
 2230 14ce 488B45A0 		movq	-96(%rbp), %rax
 2231 14d2 488910   		movq	%rdx, (%rax)
 545:libusbwrap.c  **** 	report->requestLength = (uint32)transfer->length;
 2232              		.loc 3 545 0
 2233 14d5 488B45D0 		movq	-48(%rbp), %rax
 2234 14d9 8B4014   		movl	20(%rax), %eax
 2235 14dc 89C2     		movl	%eax, %edx
 2236 14de 488B45A0 		movq	-96(%rbp), %rax
 2237 14e2 895008   		movl	%edx, 8(%rax)
 546:libusbwrap.c  **** 	report->actualLength = (uint32)transfer->actual_length;
 2238              		.loc 3 546 0
 2239 14e5 488B45D0 		movq	-48(%rbp), %rax
 2240 14e9 8B4018   		movl	24(%rax), %eax
 2241 14ec 89C2     		movl	%eax, %edx
 2242 14ee 488B45A0 		movq	-96(%rbp), %rax
 2243 14f2 89500C   		movl	%edx, 12(%rax)
 547:libusbwrap.c  **** 	report->flags = wrapper->flags;
 2244              		.loc 3 547 0
 2245 14f5 488B55C8 		movq	-56(%rbp), %rdx
 2246 14f9 488B45A0 		movq	-96(%rbp), %rax
 2247 14fd 8B520C   		movl	12(%rdx), %edx
 2248 1500 895010   		movl	%edx, 16(%rax)
 548:libusbwrap.c  **** 
 549:libusbwrap.c  **** 	switch ( transfer->status ) {
 2249              		.loc 3 549 0
 2250 1503 488B45D0 		movq	-48(%rbp), %rax
 2251 1507 8B4010   		movl	16(%rax), %eax
 2252 150a 83F806   		cmpl	$6, %eax
 2253 150d 7759     		ja	.L149
 2254 150f 89C0     		movl	%eax, %eax
 2255 1511 488D1485 		leaq	0(,%rax,4), %rdx
 2255      00000000 
 2256 1519 488D0500 		leaq	.L151(%rip), %rax
 2256      000000
 2257 1520 8B0402   		movl	(%rdx,%rax), %eax
 2258 1523 4863D0   		movslq	%eax, %rdx
 2259 1526 488D0500 		leaq	.L151(%rip), %rax
 2259      000000
 2260 152d 4801D0   		addq	%rdx, %rax
 2261 1530 FFE0     		jmp	*%rax
 2262              		.section	.rodata
 2263 063d 000000   		.align 4
 2264              		.align 4
 2265              	.L151:
 2266 0640 00000000 		.long	.L150-.L151
 2267 0644 00000000 		.long	.L152-.L151
 2268 0648 00000000 		.long	.L153-.L151
 2269 064c 00000000 		.long	.L152-.L151
 2270 0650 00000000 		.long	.L154-.L151
 2271 0654 00000000 		.long	.L155-.L151
 2272 0658 00000000 		.long	.L156-.L151
 2273              		.text
 2274              	.L150:
 550:libusbwrap.c  **** 	case LIBUSB_TRANSFER_COMPLETED:
 551:libusbwrap.c  **** 		iStatus = 0;
 2275              		.loc 3 551 0
 2276 1532 C745C000 		movl	$0, -64(%rbp)
 2276      000000
 552:libusbwrap.c  **** 		break;
 2277              		.loc 3 552 0
 2278 1539 EB34     		jmp	.L157
 2279              	.L153:
 553:libusbwrap.c  **** 	case LIBUSB_TRANSFER_TIMED_OUT:
 554:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_TIMEOUT;
 2280              		.loc 3 554 0
 2281 153b C745C0F9 		movl	$-7, -64(%rbp)
 2281      FFFFFF
 555:libusbwrap.c  **** 		break;
 2282              		.loc 3 555 0
 2283 1542 EB2B     		jmp	.L157
 2284              	.L154:
 556:libusbwrap.c  **** 	case LIBUSB_TRANSFER_STALL:
 557:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_PIPE;
 2285              		.loc 3 557 0
 2286 1544 C745C0F7 		movl	$-9, -64(%rbp)
 2286      FFFFFF
 558:libusbwrap.c  **** 		break;
 2287              		.loc 3 558 0
 2288 154b EB22     		jmp	.L157
 2289              	.L156:
 559:libusbwrap.c  **** 	case LIBUSB_TRANSFER_OVERFLOW:
 560:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_OVERFLOW;
 2290              		.loc 3 560 0
 2291 154d C745C0F8 		movl	$-8, -64(%rbp)
 2291      FFFFFF
 561:libusbwrap.c  **** 		break;
 2292              		.loc 3 561 0
 2293 1554 EB19     		jmp	.L157
 2294              	.L155:
 562:libusbwrap.c  **** 	case LIBUSB_TRANSFER_NO_DEVICE:
 563:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_NO_DEVICE;
 2295              		.loc 3 563 0
 2296 1556 C745C0FC 		movl	$-4, -64(%rbp)
 2296      FFFFFF
 564:libusbwrap.c  **** 		break;
 2297              		.loc 3 564 0
 2298 155d EB10     		jmp	.L157
 2299              	.L152:
 565:libusbwrap.c  **** 	case LIBUSB_TRANSFER_ERROR:
 566:libusbwrap.c  **** 	case LIBUSB_TRANSFER_CANCELLED:
 567:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_IO;
 2300              		.loc 3 567 0
 2301 155f C745C0FF 		movl	$-1, -64(%rbp)
 2301      FFFFFF
 568:libusbwrap.c  **** 		break;
 2302              		.loc 3 568 0
 2303 1566 EB07     		jmp	.L157
 2304              	.L149:
 569:libusbwrap.c  **** 	default:
 570:libusbwrap.c  **** 		iStatus = LIBUSB_ERROR_OTHER;
 2305              		.loc 3 570 0
 2306 1568 C745C09D 		movl	$-99, -64(%rbp)
 2306      FFFFFF
 2307              	.L157:
 571:libusbwrap.c  **** 	}
 572:libusbwrap.c  **** 	CHECK_STATUS(
 2308              		.loc 3 572 0
 2309 156f 837DC0F9 		cmpl	$-7, -64(%rbp)
 2310 1573 751C     		jne	.L158
 2311              		.loc 3 572 0 is_stmt 0 discriminator 1
 2312 1575 488B4598 		movq	-104(%rbp), %rax
 2313 1579 488D3500 		leaq	.LC32(%rip), %rsi
 2313      000000
 2314 1580 4889C7   		movq	%rax, %rdi
 2315 1583 E8000000 		call	errPrefix@PLT
 2315      00
 2316 1588 C745BC12 		movl	$18, -68(%rbp)
 2316      000000
 2317 158f EB33     		jmp	.L147
 2318              	.L158:
 573:libusbwrap.c  **** 		iStatus == LIBUSB_ERROR_TIMEOUT, USB_TIMEOUT, commit,
 574:libusbwrap.c  **** 		"usbBulkAwaitCompletion(): Timeout");
 575:libusbwrap.c  **** 	CHECK_STATUS(
 2319              		.loc 3 575 0 is_stmt 1
 2320 1591 837DC000 		cmpl	$0, -64(%rbp)
 2321 1595 742D     		je	.L147
 2322              		.loc 3 575 0 is_stmt 0 discriminator 1
 2323 1597 8B45C0   		movl	-64(%rbp), %eax
 2324 159a 89C7     		movl	%eax, %edi
 2325 159c E8000000 		call	libusb_error_name@PLT
 2325      00
 2326 15a1 4889C2   		movq	%rax, %rdx
 2327 15a4 488B4598 		movq	-104(%rbp), %rax
 2328 15a8 488D3500 		leaq	.LC33(%rip), %rsi
 2328      000000
 2329 15af 4889C7   		movq	%rax, %rdi
 2330 15b2 B8000000 		movl	$0, %eax
 2330      00
 2331 15b7 E8000000 		call	errRender@PLT
 2331      00
 2332 15bc C745BC10 		movl	$16, -68(%rbp)
 2332      000000
 2333 15c3 90       		nop
 2334              	.L147:
 576:libusbwrap.c  **** 		iStatus, USB_ASYNC_TRANSFER, commit,
 577:libusbwrap.c  **** 		"usbBulkAwaitCompletion(): Transfer error: %s", libusb_error_name(iStatus));
 578:libusbwrap.c  **** commit:
 579:libusbwrap.c  **** 	queueCommitTake(&dev->queue);
 2335              		.loc 3 579 0 is_stmt 1
 2336 15c4 488B45A8 		movq	-88(%rbp), %rax
 2337 15c8 4883C008 		addq	$8, %rax
 2338 15cc 4889C7   		movq	%rax, %rdi
 2339 15cf E8000000 		call	queueCommitTake@PLT
 2339      00
 2340              	.L141:
 580:libusbwrap.c  **** exit:
 581:libusbwrap.c  **** 	return retVal;
 2341              		.loc 3 581 0
 2342 15d4 8B45BC   		movl	-68(%rbp), %eax
 582:libusbwrap.c  **** }
 2343              		.loc 3 582 0
 2344 15d7 488B4DF8 		movq	-8(%rbp), %rcx
 2345 15db 6448330C 		xorq	%fs:40, %rcx
 2345      25280000 
 2345      00
 2346 15e4 7405     		je	.L160
 2347 15e6 E8000000 		call	__stack_chk_fail@PLT
 2347      00
 2348              	.L160:
 2349 15eb C9       		leave
 2350              		.cfi_def_cfa 7, 8
 2351 15ec C3       		ret
 2352              		.cfi_endproc
 2353              	.LFE38:
 2355              		.globl	usbNumOutstandingRequests
 2357              	usbNumOutstandingRequests:
 2358              	.LFB39:
 583:libusbwrap.c  **** 
 584:libusbwrap.c  **** DLLEXPORT(size_t) usbNumOutstandingRequests(struct USBDevice *dev) {
 2359              		.loc 3 584 0
 2360              		.cfi_startproc
 2361 15ed 55       		pushq	%rbp
 2362              		.cfi_def_cfa_offset 16
 2363              		.cfi_offset 6, -16
 2364 15ee 4889E5   		movq	%rsp, %rbp
 2365              		.cfi_def_cfa_register 6
 2366 15f1 4883EC08 		subq	$8, %rsp
 2367 15f5 48897DF8 		movq	%rdi, -8(%rbp)
 585:libusbwrap.c  **** 	return queueSize(&dev->queue);
 2368              		.loc 3 585 0
 2369 15f9 488B45F8 		movq	-8(%rbp), %rax
 2370 15fd 4883C008 		addq	$8, %rax
 2371 1601 4889C7   		movq	%rax, %rdi
 2372 1604 E8F7E9FF 		call	queueSize
 2372      FF
 586:libusbwrap.c  **** }
 2373              		.loc 3 586 0
 2374 1609 C9       		leave
 2375              		.cfi_def_cfa 7, 8
 2376 160a C3       		ret
 2377              		.cfi_endproc
 2378              	.LFE39:
 2380              	.Letext0:
 2381              		.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
 2382              		.file 5 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
 2383              		.file 6 "/usr/include/x86_64-linux-gnu/bits/time.h"
 2384              		.file 7 "/home/shubham/20140524/makestuff/common/makestuff.h"
 2385              		.file 8 "libusbwrap.h"
 2386              		.file 9 "/usr/include/stdint.h"
 2387              		.file 10 "/usr/include/x86_64-linux-gnu/sys/time.h"
 2388              		.file 11 "private.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 libusbwrap.c
     /tmp/ccc9Q9Hr.s:5      .text:0000000000000000 queueSize
     /tmp/ccc9Q9Hr.s:27     .text:0000000000000012 libusb_fill_bulk_transfer
     /tmp/ccc9Q9Hr.s:84     .bss:0000000000000000 m_ctx
     /tmp/ccc9Q9Hr.s:90     .text:0000000000000088 libusbOpenWithVidPid
     /tmp/ccc9Q9Hr.s:265    .text:000000000000025e usbValidateVidPid
     /tmp/ccc9Q9Hr.s:472    .text:00000000000003e0 usbInitialise
     /tmp/ccc9Q9Hr.s:534    .text:0000000000000452 usbIsDeviceAvailable
     /tmp/ccc9Q9Hr.s:731    .text:0000000000000680 createTransfer
     /tmp/ccc9Q9Hr.s:789    .text:00000000000006f0 destroyTransfer
     /tmp/ccc9Q9Hr.s:838    .text:0000000000000721 usbOpenDevice
     /tmp/ccc9Q9Hr.s:1097   .text:0000000000000a2a usbCloseDevice
     /tmp/ccc9Q9Hr.s:1157   .text:0000000000000a87 usbControlRead
     /tmp/ccc9Q9Hr.s:1257   .text:0000000000000b73 usbControlWrite
     /tmp/ccc9Q9Hr.s:1357   .text:0000000000000c5f usbBulkRead
     /tmp/ccc9Q9Hr.s:1471   .text:0000000000000d79 usbBulkWrite
     /tmp/ccc9Q9Hr.s:1573   .text:0000000000000e8d bulk_transfer_cb
     /tmp/ccc9Q9Hr.s:1605   .text:0000000000000eae usbBulkWriteAsync
     /tmp/ccc9Q9Hr.s:1727   .text:0000000000000fe3 usbBulkWriteAsyncPrepare
     /tmp/ccc9Q9Hr.s:1799   .text:0000000000001070 usbBulkWriteAsyncSubmit
     /tmp/ccc9Q9Hr.s:1945   .text:00000000000011e2 usbBulkReadAsync
     /tmp/ccc9Q9Hr.s:2107   .text:000000000000137c usbBulkAwaitCompletion
     /tmp/ccc9Q9Hr.s:2357   .text:00000000000015ed usbNumOutstandingRequests

UNDEFINED SYMBOLS
_GLOBAL_OFFSET_TABLE_
libusb_get_device_list
libusb_error_name
errPrefix
libusb_get_device_descriptor
libusb_open
errRender
libusb_free_device_list
__stack_chk_fail
strlen
libusb_init
libusb_set_debug
strtoul
calloc
libusb_alloc_transfer
free
libusb_free_transfer
malloc
queueInit
libusb_set_configuration
libusb_claim_interface
libusb_set_interface_alt_setting
libusb_release_interface
libusb_close
queueDestroy
libusb_control_transfer
libusb_bulk_transfer
queuePut
libusb_submit_transfer
queueCommitPut
queueTake
libusb_handle_events_timeout_completed
libusb_cancel_transfer
queueCommitTake
